[{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"summary-of-pertinent-api-changes","dir":"Articles","previous_headings":"","what":"Summary of Pertinent API Changes","title":"API Changes","text":"Listed API changes matter users original version R package (used original version API). Toward bottom page additional API changes matter called API directly wanted write python library API. Probably importantly, current shutdown date original version API February 12, 2025, communicated August 2024 newsletter. API key now required. fields can queried now seemingly distinction using string full text operators now, new case sensitivity caveat though. Note now fields returned nested objects need fully qualified query parameter. Ex. search_pv(qry_funs$begins(cpc_current.cpc_group_id=\"A01B1/00\")) fields parameter, nested fields can fully qualified new API shorthand can used, group names can specified. group names used, group’s nested fields returned API. Ex. new version API R package accept fields=c(“assignees”) using patent endpoint nested assignees fields returned API. similar get_fields(“patent”, groups=c(“assignees”)) except ’s API deciding fields return (case, assignees fields). result set’s size seems unbounded now, can now retrieve 100,000 rows. ’d need careful setting all_pages = TRUE R package page entire result set retrieved million rows. Note total_hits, previous version API capped 100,000 rows. Endpoint Changes nber_subcategories went away- endpoint original version API Endpoints now singular, ex. patent patents. returned entities still plural part. Now 23 endpoints, original 7   Comparison old new attributes can sent API o: (options) parameter via search_pv(). Note old parameters now deprecated.","code":"library(patentsview) search_pv('{\"patent_type\":\"utility\"}', all_pages = FALSE ) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10000000\" ... #>   ..$ patent_title: chr [1:1000] \"Coherent LADAR using intra-pixel quadrature\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 8,044,869, count = 1,000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"additional-r-package-changes","dir":"Articles","previous_headings":"","what":"Additional R Package Changes","title":"API Changes","text":"changes also made R package, addition API changes outlined API Changes R package changed internally using httr httr2. affects users passed additional arguments (…) search_pv(). Previously passed config = httr::timeout(40) ’d now pass timeout = 40 (name-value pairs valid curl options, found curl::curl_options() see req_options) Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request. Also fun seeing raw API response. HATEOAS sample links can retrieved using retrieve_linked_data() qry_funs$in_range() ropensci blog post announced original version R package reworked use new version R package API hex sticker created using GuangchuangYu’s hexSticker","code":"httr2::last_request() httr2::last_response() httr2::last_response() |> httr2::resp_body_json() range_query <- qry_funs$in_range(patent_date=c(\"1970-01-01\",\"1983-02-28\"))   # which will generate this, so you don't have to do it by hand range_query  #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1970-01-01\"}},{\"_lte\":{\"patent_date\":\"1983-02-28\"}}]}  # or this range_query <- qry_funs$in_range(patent_year=c(2010, 2021))  range_query #> {\"_and\":[{\"_gte\":{\"patent_year\":2010}},{\"_lte\":{\"patent_year\":2021}}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"swagger-ui-page","dir":"Articles","previous_headings":"","what":"Swagger UI Page","title":"API Changes","text":"Patentsview API team provided Swagger UI page new version API https://search.patentsview.org/swagger-ui/. cool ? Think online version Postman already loaded API’s endpoints returns. field listed 200 response sections requested fields parameter field supposed queryable (usable query parameter). Swagger UI page can used make requests, API key enter authorization screen. Swagger UI definition https://search.patentsview.org/static/openapi.json can imported Postman give nicely loaded collection new version API. ’ll just need set global variable PVIEW_KEY set authorization’s value {{PVIEW_KEY}} API key.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"other-api-changes","dir":"Articles","previous_headings":"","what":"Other API Changes","title":"API Changes","text":"API changes matter want call API directly want write python library API etc. maybe ’re receiving end PR need know API’s changes. options parameters went away: matched_subentities_only, subent_cnts page (paging now uses ‘’ instead ‘page’) Now API’s response always JSON. original version API ‘format’ parameter defaulted json set xml. original R package expose parameter script won’t know difference (unless calling API directly). Changes updated R package handles users: API now throttles requests. R package retries throttled requests. API’s paging completely different, users, all_pages=TRUE still works (however, note possibly unbounded result set size mentioned ). API change says POST requests need send JSON data (instead string representation JSON). Content-Type: application/json header added. subdomain API changed https://api.patentsview.org/ https://search.patentsview.org paths endpoints changed. order fields returned API changed Note now total_hits comes back endpoints, previously endpoint specific count, like total_patent_count. , handled R package. way total_hits comes back R package remains unchanged.","code":"# Response body now   {     \"error\": false,     \"count\": 1,     \"total_hits\": 1,     \"patent\": [...]   }    # Original response    {     \"patents\": [...],     \"count\": 1,     \"total_patent_count\": 1   } result <- search_pv('{\"patent_id\": \"11530080\"}')    print (result$query_results$total_hits) #> [1] 1"},{"path":[]},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"an-api-key-is-required","dir":"Articles","previous_headings":"Details of the API changes","what":"An API Key is required","title":"API Changes","text":"Perhaps important change, without API key queries rejected. Request API key using link: https://patentsview.org/apis/keyrequest one, ’ll need set environmental variable PATENTSVIEW_API_KEY value API key R package use. user’s API key needs sent requests","code":"api_key = Sys.getenv(\"PATENTSVIEW_API_KEY\") httr::add_headers(\"X-Api-Key\" = api_key)"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"endpoints","dir":"Articles","previous_headings":"Details of the API changes","what":"Endpoints","title":"API Changes","text":"Now 23 endpoints, original 7, returns smaller, specific data structure pertinent endpoint. example, previously inventor endpoint return assignee information, longer . exception patent endpoint. now can return assignees, inventors, cpc_current along patent specific fields. Note new endpoints nested patent/ one publication/ /api/v1/brf_sum_text/ /api/v1/claim/ /api/v1/detail_desc_text/ /api/v1/draw_desc_text/ /api/v1/ipc/ /api/v1/uspc_subclass/ /api/v1/patent/attorney/ /api/v1/patent/foreign_citation/ /api/v1/patent/otherreference/ (currently working) /api/v1/patent/rel_app_text/ /api/v1/patent/us_application_citation/ /api/v1/patent/us_patent_citation/ /api/v1/publication/rel_app_text/ /api/v1/publications/ /api/v1/wipo/ /api/v1/assignee/ /api/v1/inventor/ /api/v1/location/ /api/v1/patent/ /api/v1/uspc_mainclass/ /api/v1/cpc_class/ /api/v1/cpc_subclass/ /api/v1/cpc_group/ nber_subcategory endpoint seems gone now.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"things-to-note","dir":"Articles","previous_headings":"Details of the API changes > Endpoints","what":"Things to note","title":"API Changes","text":"Four new endpoints, brf_sum_text, claims, draw_desc_text detail_desc_text, marked ‘beta’ Swagger UI page data fully populated. See page see data currently populated. API documentation says 4 endpoint GET , though respond POSTs1. Currently endpoints return attributes listed API’s OpenAPI object. throw 500 errors requested2 (see test-api-bugs.R) two rel_app_text endpoints, one patent/ one publication/ return different entities, rel_app_texts (patent) rel_app_text_publications (publication) endpoints now return HATEOAS links fields went away, like rawinventor_first_name rawinventor_last_name, new names, significantly, patent_number now patent_id. Requesting patent_number result error thrown. Note also CPC related fields new names, see next section.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"hateoas-links","dir":"Articles","previous_headings":"Details of the API changes","what":"HATEOAS Links","title":"API Changes","text":"returned fields HATEOAS (Hypermedia Engine Application State) links retrieve information field. Slightly funky cpc_current’s cpc_group, returned patent endpoint. slash CPC turned colon. peculiarity two new convenience URLs (new endpoints accept single URL parameter) shouldn’t noticeable R package, unless trying infer USPC CPC values returned URLs, without actually calling back data. ’ll call patent endpoint get CPC fields particular patent, returned fields, like cpc_group, HATEOAS links: Note going links browser result 403 Unauthorized, API key sent. new method R package retrieve data HATEOAS links, just pass returned link R package retrieve data . can also pass arbitrary link hits API. can particularly useful want see response link found API’s documentation. Note calling cpc_group endpoint instead using HATEOAS link, ’d use slash instead colon. Slight weirdness/sleight hand returned field name looses _id requested field","code":"query <- '{\"patent_id\": \"11530080\"}'   fields <- c('patent_id', get_fields('patent', groups = 'cpc_current'))   fields #>  [1] \"patent_id\"                   \"cpc_current.cpc_class\"       #>  [3] \"cpc_current.cpc_class_id\"    \"cpc_current.cpc_group\"       #>  [5] \"cpc_current.cpc_group_id\"    \"cpc_current.cpc_section\"     #>  [7] \"cpc_current.cpc_sequence\"    \"cpc_current.cpc_subclass\"    #>  [9] \"cpc_current.cpc_subclass_id\" \"cpc_current.cpc_type\"    result <- search_pv(query, fields=fields)    # As noted above, the CPC related fields aren't the same as they were in the   # original version of the API.  Also note that not all requested fields were   # returned and that _id-less, HATEOAS fields were returned.   unnested <- unnest_pv_data(result$data)   z <- lapply(names(unnested$cpc_current), function(x) {      print(paste0(x,': ', unnested$cpc_current[[x]][[1]]))   }) #> [1] \"patent_id: 11530080\" #> [1] \"cpc_sequence: 0\" #> [1] \"cpc_class: https://search.patentsview.org/api/v1/cpc_class/B65/\" #> [1] \"cpc_class_id: B65\" #> [1] \"cpc_subclass: https://search.patentsview.org/api/v1/cpc_subclass/B65D/\" #> [1] \"cpc_subclass_id: B65D\" #> [1] \"cpc_group: https://search.patentsview.org/api/v1/cpc_group/B65D71:0033/\" #> [1] \"cpc_group_id: B65D71/0033\" library(patentsview)  pv_data <- retrieve_linked_data(\"https://search.patentsview.org/api/v1/cpc_group/G01S7:4865/\") pv_data #> $data #> #### A list with a single data frame on cpc_groups level: #>  #> List of 1 #>  $ cpc_groups:'data.frame':  1 obs. of  4 variables: #>   ..$ cpc_class      : chr \"https://search.patentsview.org/api/v1/cpc_class/G\".. #>   ..$ cpc_subclass   : chr \"https://search.patentsview.org/api/v1/cpc_subclas\".. #>   ..$ cpc_group_id   : chr \"G01S7/4865\" #>   ..$ cpc_group_title: chr \"Details of systems according to groups G01S13/00,\".. #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 1, count = 1  # Here we'll use an example URL from the documentation # Note that going to that link in a browser will result in a 403 Unauthorized, as no API key is sent. retrieve_linked_data('https://search.patentsview.org/api/v1/patent/?q={\"patent_id\":\"7861317\"}') #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1 obs. of  3 variables: #>   ..$ patent_id   : chr \"7861317\" #>   ..$ patent_title: chr \"Nose cover\" #>   ..$ patent_date : chr \"2011-01-04\" #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 1, count = 1 search_pv('{\"cpc_group_id\": \"A01B1/00\"}', endpoint = 'cpc_group') #> $data #> #### A list with a single data frame on cpc_groups level: #>  #> List of 1 #>  $ cpc_groups:'data.frame':  1 obs. of  4 variables: #>   ..$ cpc_class      : chr \"https://search.patentsview.org/api/v1/cpc_class/A\".. #>   ..$ cpc_subclass   : chr \"https://search.patentsview.org/api/v1/cpc_subclas\".. #>   ..$ cpc_group_id   : chr \"A01B1/00\" #>   ..$ cpc_group_title: chr \"Hand tools\" #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 1, count = 1 # We'll make a call to the patent endpoint to get inventor and assignee HATEOAS links   res <- search_pv('{\"patent_id\":\"10000000\"}',     fields = c(\"inventors.inventor_id\", \"assignees.assignee_id\")   )    # but note that the fields came back without the _id   print(res$data$patents$assignees[[1]]$assignee) # not $assignee_id as requested #> [1] \"https://search.patentsview.org/api/v1/assignee/aeef7c1f-e757-467f-8e07-289dc8c6ed95/\"    print(res$data$patents$inventors[[1]]$inventor) # not $inventor_id as requested #> [1] \"https://search.patentsview.org/api/v1/inventor/fl:jo_ln:marron-5/\""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"api-throttling","dir":"Articles","previous_headings":"Details of the API changes","what":"API Throttling","title":"API Changes","text":"API now allow 45 requests per minute, making requests anger API. send back error code header indicating many seconds wait sending queries. R package take care . sleep required number seconds resubmitting query, seamlessly script.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"a-note-on-paging","dir":"Articles","previous_headings":"Details of the API changes","what":"A Note on Paging","title":"API Changes","text":"API team changed paging works important subtlety R package handles . screams python library python users don’t need worry throttling! ’s comment search-pv.R tries explain danger. See paging discussion PR","code":"# Here we ignore the user's sort and instead have the API sort by the primary   # key for the requested endpoint.  This simplifies the paging's after parameter.   # If we call the API with more than a primary sort, the after parameter would   # have to be an array of all the sort fields' last values.   # After we've retrieved all the data we'll sort in R using the sort the user requested    # Doing this also protects users from needing to know the peculiarities   # of the API's paging.  Example: if a user requests a sort of   # [{\"patent_date\":\"asc\"}], on paging the after parameter may skip   # to the next issue date before having retured all the data for the last   # patent_date in the previous request - depending on where the   # patent_dates change relative to the API's page breaks.   # (Say the last patent in a retrieved page is the first patent   # of a particular date, we wouldn't want the after parameter to   # to begin the next page of data after this date.)"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"string-and-full-text-operators","dir":"Articles","previous_headings":"Details of the API changes","what":"String and Full Text Operators","title":"API Changes","text":"Tip “Syntax” API’s documentation says: working text data fields, wherever possible, recommend using _text* operators _contains _begins operator. text operators treat fields full text data hence performant. “full text” fields identified API Endpoint specification value “text” data type. sure applies beta endpoints . Also sure make result set size differences3, total_hits, noting errors thrown API: hitting patent endpoint: hitting brf_sum_text endpoint:","code":"query1 <- '{\"_contains\":{\"patent_title\":\"dog\"}}' query2 <- '{\"_text_any\":{\"patent_title\":\"dog\"}}'  search_pv(query1) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10000747\" ... #>   ..$ patent_title: chr [1:1000] \"Endoglycosidase mutants for glycoprotein re\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,652, count = 1,000  search_pv(query2) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10028486\" ... #>   ..$ patent_title: chr [1:1000] \"Lightweight flexible dog shoes\" ... #>   ..$ patent_date : chr [1:1000] \"2018-07-24\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 2,075, count = 1,000 query1 <- '{\"_contains\":{\"summary_text\":\"paper cup holder\"}}' query2 <- '{\"_text_phrase\":{\"summary_text\":\"paper cup holder\"}}'  search_pv(query1, endpoint=\"brf_sum_text\") #> $data #> #### A list with a single data frame on brf_sum_texts level: #>  #> List of 1 #>  $ brf_sum_texts: list() #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 0, count = 0  search_pv(query2, endpoint=\"brf_sum_text\") #> $data #> #### A list with a single data frame on brf_sum_texts level: #>  #> List of 1 #>  $ brf_sum_texts:'data.frame':   1 obs. of  3 variables: #>   ..$ patent_id      : chr \"11530080\" #>   ..$ summary_text   : chr \"FIELD OF THE INVENTION\\n\\nThe invention relates t\".. #>   ..$ document_number: num 2.02e+10 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 1, count = 1"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/api-changes.html","id":"case-sensitivity-caveat","dir":"Articles","previous_headings":"Details of the API changes","what":"Case Sensitivity Caveat","title":"API Changes","text":"original version API seemed case insensitive. sure bug feature4 new version API ’s something aware . ’ll see queries , two forms equal now seem case sensitive.","code":"result <- search_pv('{\"assignee_organization\": \"Johnson & Johnson International\"}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 1  result <- search_pv('{\"assignee_organization\": \"johnson & Johnson International\"}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 0  result <- search_pv('{\"_eq\":{\"assignee_organization\": \"Johnson & Johnson International\"}}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 1  result <- search_pv('{\"_eq\":{\"assignee_organization\": \"johnson & Johnson International\"}}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 0"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/citation-networks.html","id":"count-the-distinct-patent_id-and-cited_patent_id","dir":"Articles","previous_headings":"","what":"Count the distinct patent_id and cited_patent_id","title":"Citation networks","text":"11 PCA patents. patents cite 1037 patents cited 1024 patents. Let’s visualize citations among PCA patents. ’ll create visualization using visNetwork package, requires us create data frame nodes data frame edges. looks like several patents cite patent number 6,499,026, perhaps indicating patent contains technology foundational field. However, hover nodes see several patents title. Clicking titles brings us full text Google Patents, confirms many PCA patents belong patent family.1 Let’s choose one patents family act family’s representative. reduce size subsequent network, hopefully retaining overall structure. 3 patents, probably possible visualize patents’ cited citing patents related one another. Let’s create list “relevant patents” (.e., 3 patents plus cited citing patents)2, get list cited patents (.e., patents cite). list cited patents allow us measure similar relevant patents one another. Now know patents 4772 relevant patents cite. allows us measure similarity 4772 patents seeing many cited references share common (method known bibliographic coupling). full_network contains similarity score (cosine_sim) patent pairs share least one cited reference common. means probably contains lot patent pairs one two cited references common, thus aren’t similar. Let’s try identify natural level cosine_sim filter subsequent network hairy.  appears smallish group patent pairs similar one another (cosine_sim > 0.8), makes tempting choose 0.8 cutoff point. However, patent pairs reference lists similar probably just patents patent family. Let’s choose 0.1 cutoff point instead, doesn’t appear many pairs point.3","code":"# with the API change we wouldn't have titles unless we call the patent endpoint # we'll use the patent number as the title for now  pat_title <- function(title, number) {   temp_title <- str_wrap(title)   i <- gsub(\"\\\\n\", \"<br>\", temp_title)   paste0('<a href=\"https://patents.google.com/patent/US', number, '\">', i, \"<\/a>\") }  edges <-   res_lst$us_patent_citations %>%   semi_join(x = ., y = ., by = c(\"citation_patent_id\" = \"patent_id\")) %>%   set_colnames(c(\"from\", \"to\"))  # We could call the patent endpoint to get the patent titles but we'll just set # the title to the patent number nodes <-   res_lst$us_patent_citations %>%   distinct(patent_id) %>%   mutate(     id = patent_id,     label = patent_id,     title = pat_title(patent_id, patent_id)   )  visNetwork(   nodes = nodes, edges = edges, height = \"400px\", width = \"100%\",   main = \"Citations among patent citation analysis (PCA) patents\" ) %>%   visEdges(arrows = list(to = list(enabled = TRUE))) %>%   visIgraphLayout() p3 <- c(\"7797336\", \"9075849\", \"6499026\") res_lst2 <- lapply(res_lst, function(x) x[x$patent_id %in% p3, ]) rel_pats <-   res_lst$us_patent_citations %>%   rbind(setNames(res_lst$us_patent_citations, names(.))) %>%   select(-patent_id) %>%   rename(patent_id = citation_patent_id) %>%   bind_rows(data.frame(patent_id = p3)) %>%   distinct() %>%   filter(!is.na(patent_id))  # Look up which patents the relevant patents cite.  We need to use the  # patent_citation endpoint now, though we can't get patent_title from it.  rel_pats_res <- search_pv(   query = list(patent_id = rel_pats$patent_id),   fields = c(\"citation_patent_id\", \"patent_id\"),   all_pages = TRUE, size = 1000, method = \"POST\", endpoint = \"patent/us_patent_citation\" )  rel_pats_lst <- unnest_pv_data(rel_pats_res$data, \"patent_id\") cited_pats <-   rel_pats_lst$us_patent_citations %>%   filter(!is.na(citation_patent_id))  full_network <-   cited_pats %>%   do({     .$ind <-       group_by(., patent_id) %>%       group_indices()     group_by(., patent_id) %>%       mutate(sqrt_num_cited = sqrt(n()))   }) %>%   inner_join(x = ., y = ., by = \"citation_patent_id\") %>%   filter(ind.x > ind.y) %>%   group_by(patent_id.x, patent_id.y) %>%   mutate(cosine_sim = n() / (sqrt_num_cited.x * sqrt_num_cited.y)) %>%   ungroup() %>%   select(matches(\"patent_id\\\\.|cosine_sim\")) %>%   distinct()  kable(head(full_network)) hist(   full_network$cosine_sim,   main = \"Similarity scores between patents relevant to PCA\",   xlab = \"Cosine similarity\", ylab = \"Number of patent pairs\" ) edges <-   full_network %>%   filter(cosine_sim >= .1) %>%   rename(from = patent_id.x, to = patent_id.y, value = cosine_sim) %>%   mutate(title = paste(\"Cosine similarity =\", as.character(round(value, 3))))  nodes <-   rel_pats_lst$us_patent_citations %>%   distinct(patent_id) %>%   rename(id = patent_id) %>%   mutate(     # the 3 patents of interest will be represented as blue nodes, all others     # will be yellow     color = ifelse(id %in% p3, \"#97C2FC\", \"#DDCC77\"),     label = id,     title = pat_title(id, id) # we don't get patent_title now (formerly first argument)   )  visNetwork(   nodes = nodes, edges = edges, height = \"700px\", width = \"100%\",   main = \"Network of patents relevant to PCA\" ) %>%   visEdges(color = list(color = \"#343434\")) %>%   visOptions(highlightNearest = list(enabled = TRUE, degree = 1)) %>%   visIgraphLayout()"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/converting-an-existing-script.html","id":"required-api-key","dir":"Articles","previous_headings":"","what":"Required API Key","title":"Converting an Existing Script","text":"First ’ll need request API key set environmental variable PATENTSVIEW_API_KEY value API key. Ex. set PATENTSVIEW_API_KEY=My_api_key Without valid API key, calls rejected API. ## New Throttling Limit Another new thing throttling limit. new version API allows individual API key make 45 calls per minute. call exceeds limit rejected return number seconds wait calls allowed . Fortunately, R package handles ! script chugging along API return throttling response, R package sleep required number seconds automatically resending query! thing may notice, besides warning message, script pause throttled picks right back .","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/converting-an-existing-script.html","id":"philosophical-change","dir":"Articles","previous_headings":"","what":"Philosophical Change","title":"Converting an Existing Script","text":"new version API’s endpoints less Swiss Army Knife-like , get nearly data field endpoint. Now substantially lighter responses generally focus data pertinent endpoint. words, can get USPC fields USPC endpoints patent endpoint. may mean ’ll make multiple calls different endpoints get data old version API used return single call. Take look top assignees application. blend together information separate calls used returned single call. may push dplyr skills limit.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/converting-an-existing-script.html","id":"changed-field-names-and-types","dir":"Articles","previous_headings":"","what":"Changed Field Names and Types","title":"Converting an Existing Script","text":"fields requested original script used query may available new version’s endpoints. nber attributes longer available nber_subcategories endpoint removed. Also, attributes new names, like name_last nested inventor object returned patent endpoint. Now fields parameter specified “inventor.name_last” formerly “inventor_last_name” using patent endpoint. also demonstrates nested fields need fully qualified query fields parameters. Also note field’s types changed, meaning ’ll need use different operators within query. Ex. assignee.organization now full text field, formerly string. Checkout API documentation Swagger UI page see returned fields types. information available fieldsdf data frame harder read.","code":"library(patentsview)  # Before you could do a  qry_funs$contains(assignee_organization=\"Rice University\") #> {\"_contains\":{\"assignee_organization\":\"Rice University\"}}  # now you would have to do  qry_funs$text_phrase(assignees.assignee_organization=\"Rice University\") #> {\"_text_phrase\":{\"assignees.assignee_organization\":\"Rice University\"}}"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/converting-an-existing-script.html","id":"singular-endpoints","dir":"Articles","previous_headings":"","what":"Singular Endpoints","title":"Converting an Existing Script","text":"endpoints now singular, ex: patent previously patents.","code":"get_endpoints() #>  [1] \"assignee\"                       \"brf_sum_text\"                   #>  [3] \"claim\"                          \"cpc_class\"                      #>  [5] \"cpc_group\"                      \"cpc_subclass\"                   #>  [7] \"detail_desc_text\"               \"draw_desc_text\"                 #>  [9] \"inventor\"                       \"ipc\"                            #> [11] \"location\"                       \"patent\"                         #> [13] \"patent/attorney\"                \"patent/foreign_citation\"        #> [15] \"patent/rel_app_text\"            \"patent/us_application_citation\" #> [17] \"patent/us_patent_citation\"      \"publication\"                    #> [19] \"publication/rel_app_text\"       \"uspc_mainclass\"                 #> [21] \"uspc_subclass\"                  \"wipo\""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/converting-an-existing-script.html","id":"additions-to-the-r-package","dir":"Articles","previous_headings":"","what":"Additions to the R Package","title":"Converting an Existing Script","text":"endpoints now return HATEOAS links, make call back API retrieve additional data. new method retrieve_linked_data() just . lot .","code":"# There is a new in_range query function  range_query <- qry_funs$in_range(patent_date=c(\"1970-01-01\",\"1983-02-28\"))   # which will generate this, so you don't have to do it by hand range_query #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1970-01-01\"}},{\"_lte\":{\"patent_date\":\"1983-02-28\"}}]}  range_query <- qry_funs$in_range(patent_year=c(2010, 2021)) range_query #> {\"_and\":[{\"_gte\":{\"patent_year\":2010}},{\"_lte\":{\"patent_year\":2021}}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/converting-an-existing-script.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Converting an Existing Script","text":", attempt listing ’s changed . Request API key get going new version R package! two API versions coexist API team plans shutdown original version API February 2025.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/examples.html","id":"patent-endpoint","dir":"Articles","previous_headings":"","what":"Patent endpoint","title":"Examples","text":"patents cited 500 US patents? many distinct inventors represented highly-cited patents? assignee’s organizations start Microsoft? geographically Microsoft inventors coming past years?","code":"library(patentsview)  search_pv(query = qry_funs$gt(patent_num_times_cited_by_us_patents = 500)) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10004497\" ... #>   ..$ patent_title: chr [1:1000] \"Interface systems for use with surgical ins\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-26\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 13,199, count = 1,000 search_pv(   query = qry_funs$gt(patent_num_times_cited_by_us_patents = 500),   fields = c(\"patent_id\", \"inventors.inventor_id\") ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id: chr [1:1000] \"10004497\" ... #>   ..$ inventors:List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 13,199, count = 1,000 query <- qry_funs$begins(assignee_organization = \"Microsoft\")  pv_out <- search_pv(query, endpoint = \"assignee\") pv_out$data$assignees$assignee_organization #>  [1] \"Microsoft Technology Beaming, LLC\"                #>  [2] \"MICROSOFT INTERNATIONAL HOLDINGS B.V.\"            #>  [3] \"Microsoft Mobile Oy\"                              #>  [4] \"Microsoft Technology, LLC.\"                       #>  [5] \"Microsoft Systems Inc.\"                           #>  [6] \"Microsoft Technology Licensing, LLC\"              #>  [7] \"Microsoft Corporation\"                            #>  [8] \"Microsoft Patent Licensing, LLC\"                  #>  [9] \"Microsoft Corporation—One Microsoft Way\"          #> [10] \"Microsoft Licencing Corporation, LLC\"             #> [11] \"Microsoft Mobile Internet AB\"                     #> [12] \"Microsoft Licensing Technology, LLC\"              #> [13] \"Microsoft Technology Learning, LLC\"               #> [14] \"Microsoft Israel Research and Development (2002)\" #> [15] \"Microsoft Orthopedics Holdings Inc.\" # Write the query query <- with_qfuns(   and(     gte(patent_date = \"2022-07-26\"), # Dates are in yyyy-mm-dd format     begins(assignees.assignee_organization = \"Microsoft\")   ) )  # Create a field list by getting the inventors fields- the primary key is needed # for the unnest_pv_data inv_fields <- get_fields(endpoint = \"patent\", groups=\"inventors\") inv_fields <- c(inv_fields, get_ok_pk(endpoint = \"patent\"))  # Pull the data pv_out <- search_pv(query, fields = inv_fields, all_pages = TRUE, size = 1000)  # Unnest the inventor list column unnest_pv_data(pv_out$data, \"patent_id\") #> List of 2 #>  $ inventors:'data.frame':   14533 obs. of  8 variables: #>   ..$ patent_id          : chr [1:14533] \"11397055\" ... #>   ..$ inventor           : chr [1:14533] \"https://search.patentsview.org/api/\".. #>   ..$ inventor_name_first: chr [1:14533] \"Tzu-Yuan\" ... #>   ..$ inventor_name_last : chr [1:14533] \"Lin\" ... #>   ..$ inventor_city      : chr [1:14533] \"San Jose\" ... #>   ..$ inventor_state     : chr [1:14533] \"CA\" ... #>   ..$ inventor_country   : chr [1:14533] \"US\" ... #>   ..$ inventor_sequence  : int [1:14533] 1 2 ... #>  $ patents  :'data.frame':   3600 obs. of  1 variable: #>   ..$ patent_id: chr [1:3600] \"11397055\" ..."},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/examples.html","id":"inventor-endpoint","dir":"Articles","previous_headings":"","what":"Inventor Endpoint","title":"Examples","text":"inventor’s recent patent Chicago, IL listed location. new version API, behavior endpoint changed. See similar example legacy inventors endpoint page original behavior. also call new version patent endpoint find inventors listed Chicago, IL location applying patent. Note inventors particular patent returned, just ones whose location Chicago, IL. Also see Writing Queries Vignette readable ways write queries.","code":"pv_out <- search_pv(   query = '{\"_and\":[{\"_text_phrase\": {\"inventor_lastknown_city\":\"Chicago\"}},                     {\"_text_phrase\": {\"inventor_lastknown_state\":\"IL\"}}]}',   endpoint = \"inventor\" )  pv_out #> $data #> #### A list with a single data frame on inventors level: #>  #> List of 1 #>  $ inventors:'data.frame':   1000 obs. of  3 variables: #>   ..$ inventor_id        : chr [1:1000] \"001sh51t5ft5hbegqhzo1y4or\" ... #>   ..$ inventor_name_first: chr [1:1000] \"Michael M.\" ... #>   ..$ inventor_name_last : chr [1:1000] \"Stamler\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 13,447, count = 1,000 fields <- c(\"patent_id\", get_fields('patent', groups=\"inventors\")) fields #> [1] \"patent_id\"                     \"inventors.inventor_id\"         #> [3] \"inventors.inventor_city\"       \"inventors.inventor_country\"    #> [5] \"inventors.inventor_name_first\" \"inventors.inventor_name_last\"  #> [7] \"inventors.inventor_sequence\"   \"inventors.inventor_state\"  query <- '{\"_and\":[{\"_text_phrase\": {\"inventors.inventor_city\":\"Chicago\"}},                    {\"_text_phrase\": {\"inventors.inventor_state\":\"IL\"}}]}'  search_pv(query, fields=fields, endpoint=\"patent\") #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id: chr [1:1000] \"10000578\" ... #>   ..$ inventors:List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 46,544, count = 1,000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/examples.html","id":"assignee-endpoint","dir":"Articles","previous_headings":"","what":"Assignee Endpoint","title":"Examples","text":"assignees interest beer?","code":"search_pv(   query = qry_funs$contains(patent_title = \"beer\"),   endpoint = \"patent\" ) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 592 obs. of  3 variables: #>   ..$ patent_id   : chr [1:592] \"10000326\" ... #>   ..$ patent_title: chr [1:592] \"Plastic beer keg\" ... #>   ..$ patent_date : chr [1:592] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 592, count = 592"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"a-basic-example","dir":"Articles","previous_headings":"","what":"A basic example","title":"Getting started","text":"Let’s start basic example use package’s primary function, search_pv(): call search_pv() sends query patent endpoint (default). API 23 different endpoints, corresponding 23 different entity types (assignees, attorneys, brf_sum_texts, claims, cpc_classes, cpc_groups, cpc_subclasses, detail_desc_texts, draw_desc_texts, foreign_citations, inventors, ipcs, locations, otherreferences, patents, publications, rel_app_text_publications, rel_app_texts, us_application_citations, us_patent_citations, uspc_mainclasses, uspc_subclasses, wipo).1 choice endpoint determines entity query applied , well structure data returned (“23 endpoints 23 entities section”). now, let’s turn attention query parameter.","code":"library(patentsview)  search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}',   endpoint = \"patent\" ) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10000000\" ... #>   ..$ patent_title: chr [1:1000] \"Coherent LADAR using intra-pixel quadrature\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 5,362,291, count = 1,000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"writing-queries","dir":"Articles","previous_headings":"","what":"Writing queries","title":"Getting started","text":"PatentsView query syntax documented query language page note also change Options parameter new version API mentioned page.2 However, can difficult get query right ’re writing hand (.e., just writing query string like '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}', example shown ). patentsview package comes simple domain specific language (DSL) make writing queries breeze. recommend using functions DSL basic queries, especially ’re encountering errors don’t understand . get feel works, let’s rewrite query shown using one functions DSL, qry_funs$gte(): complex queries also possible: Check writing queries vignette details using DSL.","code":"qry_funs$gte(patent_date = \"2007-01-01\") #> {\"_gte\":{\"patent_date\":\"2007-01-01\"}} with_qfuns(   and(     gte(patent_date = \"2007-01-01\"),     text_phrase(patent_abstract = c(\"computer program\", \"dog leash\"))   ) ) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-01-01\"}},{\"_or\":[{\"_text_phrase\":{\"patent_abstract\":\"computer program\"}},{\"_text_phrase\":{\"patent_abstract\":\"dog leash\"}}]}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"fields","dir":"Articles","previous_headings":"","what":"Fields","title":"Getting started","text":"endpoint different set fields. new version API allows fields queried. first example, didn’t specify fields wanted retrieve given default set. can specify fields want using fields argument: list fields given endpoint, use get_fields(): Nested fields can fully qualified new API shorthand can used, group names can specified. group names used, group’s nested fields returned API. E.g., new version API R package accept fields=c(\"applicants\") See Swagger UI page API, fields returned listed endpoint 200 Response body sections. API’s endpoint documentation similar look feel. can also visit endpoint’s online documentation page see list fields (e.g., see inventor field list table). earlier versions API fields queryable now. field tables endpoints can found fieldsdf data frame, can load using data(\"fieldsdf\") View(patentsview::fieldsdf). important note: PatentsView uses disambiguated versions assignees, inventors, locations, instead raw data. example, let’s say search inventors whose first name “john.” PatentsView API going return inventors preferred first name (per disambiguation results) john, may necessarily raw first name. getting back inventors whose first name appears patent , say, “jonathan,” “johnn,” even “john jay.”, see PatentsView Inventor Disambiguation Technical Workshop website. original version API, rawinventor_first_name rawinventor_last_name available patents, inventors assignees endpoints. new version API fields longer available.","code":"# search_pv defaults the endpoint parameter to \"patents\" if not specified result = search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}',   fields = c(\"patent_id\", \"patent_title\") ) result #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id   : chr [1:1000] \"10000000\" ... #>   ..$ patent_title: chr [1:1000] \"Coherent LADAR using intra-pixel quadrature\".. #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 5,362,291, count = 1,000 retrvble_flds <- get_fields(endpoint = \"patent\") head(retrvble_flds) #> [1] \"applicants.applicant_designation\"  \"applicants.applicant_name_first\"   #> [3] \"applicants.applicant_name_last\"    \"applicants.applicant_organization\" #> [5] \"applicants.applicant_sequence\"     \"applicants.applicant_type\""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"paginated-responses","dir":"Articles","previous_headings":"","what":"Paginated responses","title":"Getting started","text":"default, search_pv() returns 1,000 records per page gives first page results. suggest starting something smaller, like size = 150 , ’re figuring details request, query want use fields want returned. items finalized, can use size argument download 1,000 records per page. can download pages output one call setting all_pages = TRUE. set size equal 1,000 loop pages output:","code":"search_pv(   query = qry_funs$eq(inventors.inventor_name_last = \"Chambers\"),   all_pages = TRUE, size = 1000 ) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 2459 obs. of  3 variables: #>   ..$ patent_id   : chr [1:2459] \"10000988\" ... #>   ..$ patent_title: chr [1:2459] \"Seal assemblies in subsea rotating control \".. #>   ..$ patent_date : chr [1:2459] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 2,459, count = 1,000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"entity-counts","dir":"Articles","previous_headings":"","what":"Entity counts","title":"Getting started","text":"last two calls search_pv() gave value total_hits, even though got lot data second call. entity counts returned API refer number distinct entities across downloadable pages output, just page returned.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"endpoints-for-23-entities","dir":"Articles","previous_headings":"","what":"23 endpoints for 23 entities","title":"Getting started","text":"recent API change, patent endpoint supplies basic patent data endpoints return specific data patents. choice endpoint determines two things: entity query applied . first call shown used patent endpoint, API searched patents least one inventor listed last name “Chambers.” second call used inventor endpoint show returns similar query. structure data frame returned. first call returned data frame patent level, meaning row corresponded different patent. Fields patent level (e.g., inventors.inventor_name_last) returned list columns named entity associated field (e.g., inventors entity).3 Meanwhile, second call gave us data frame inventor level (one row inventor) used inventor endpoint. time want use patent endpoint. Note can still effectively filter fields patent-level using patent endpoint (e.g., can filter assignee name CPC category). patents relatively low-level entities. higher level entities like assignees, filter field assignee-level (e.g., inventor name), API return data assignee least one inventor whose name matches search, probably want.","code":"query <- qry_funs$eq(inventors.inventor_name_last = \"Chambers\")  # Here we'll request patent_id and the inventor fields from the patent endpoint inv_fields <- get_fields(endpoint = \"patent\", groups =\"inventors\") inv_fields #> [1] \"inventors.inventor_id\"         \"inventors.inventor_city\"       #> [3] \"inventors.inventor_country\"    \"inventors.inventor_name_first\" #> [5] \"inventors.inventor_name_last\"  \"inventors.inventor_sequence\"   #> [7] \"inventors.inventor_state\" fields <- c(inv_fields, \"patent_id\")  result <- search_pv(query, endpoint = \"patent\", fields = fields) result #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id: chr [1:1000] \"10000988\" ... #>   ..$ inventors:List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 2,459, count = 1,000  # Here's the first inventors result$data$patents$inventors[[1]] #>                                                               inventor #> 1   https://search.patentsview.org/api/v1/inventor/fl:si_ln:harrall-1/ #> 2   https://search.patentsview.org/api/v1/inventor/fl:da_ln:wagoner-1/ #> 3   https://search.patentsview.org/api/v1/inventor/fl:th_ln:bailey-10/ #> 4     https://search.patentsview.org/api/v1/inventor/fl:an_ln:barry-8/ #> 5 https://search.patentsview.org/api/v1/inventor/fl:ja_ln:chambers-11/ #>   inventor_name_first inventor_name_last inventor_city inventor_state #> 1            Simon J.            Harrall       Houston             TX #> 2            Danny W.            Wagoner       Cypress             TX #> 3           Thomas F.             Bailey       Houston             TX #> 4        Andrew A. W.              Barry Missouri City             TX #> 5            James W.           Chambers       Hackett             AR #>   inventor_country inventor_sequence #> 1               US                 4 #> 2               US                 1 #> 3               US                 0 #> 4               US                 3 #> 5               US                 2  # Now we will see what the inventor endpoint returns for a similar query. # We use get_fields() to get all the available for the inventor endpoint. query <- qry_funs$eq(inventor_name_last = \"Chambers\") fields <- get_fields(endpoint = \"inventor\")  search_pv(query, endpoint = \"inventor\", fields = fields) #> $data #> #### A list with a single data frame (with list column(s) inside) on inventors level: #>  #> List of 1 #>  $ inventors:'data.frame':   434 obs. of  16 variables: #>   ..$ inventor_id                 : chr [1:434] \"1vk0dcohf8r1vofo538cfxl2g\" ... #>   ..$ inventor_name_first         : chr [1:434] \"Gilbert V.\" ... #>   ..$ inventor_name_last          : chr [1:434] \"Chambers\" ... #>   ..$ inventor_gender_code        : chr [1:434] \"M\" ... #>   ..$ inventor_lastknown_city     : chr [1:434] \"Baytown\" ... #>   ..$ inventor_lastknown_state    : chr [1:434] \"TX\" ... #>   ..$ inventor_lastknown_country  : chr [1:434] \"US\" ... #>   ..$ inventor_lastknown_latitude : num [1:434] 29.7 ... #>   ..$ inventor_lastknown_longitude: num [1:434] -95 ... #>   ..$ inventor_lastknown_location : chr [1:434] \"https://search.patentsview.o\".. #>   ..$ inventor_num_patents        : int [1:434] 1 1 ... #>   ..$ inventor_num_assignees      : int [1:434] 1 2 ... #>   ..$ inventor_first_seen_date    : chr [1:434] \"1995-10-17\" ... #>   ..$ inventor_last_seen_date     : chr [1:434] \"1995-10-17\" ... #>   ..$ inventor_years_active       : num [1:434] 1 1 ... #>   ..$ inventor_years              :List of 434 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 434, count = 434"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"casting-fields","dir":"Articles","previous_headings":"","what":"Casting fields","title":"Getting started","text":"API now returns data fields appropriate data type (e.g., numeric). , however, fields returned strings rather integers lot date fields now. also two rule_47_flags, one returned patent endpoint, publication endpoint. former boolean latter string can cast boolean. Lastly, document numbers numeric though two instances strings can cast integers. can cast fields preferred R types using cast_pv_data():","code":"library(knitr)  # These fields are received as strings and would be cast to integers ints <- fieldsdf[fieldsdf$data_type == \"int\", c(\"endpoint\",\"field\")] ints <- ints[order(ints$field),] print(ints,  row.names = FALSE) #>                        endpoint                    field #>                        assignee            assignee_type #>                          patent  assignees.assignee_type #>                     publication  assignees.assignee_type #>  patent/us_application_citation citation_document_number #>        publication/rel_app_text          document_number  # These fields are received as strings and would be cast to dates date_fields <- fieldsdf[fieldsdf$data_type == \"date\", c(\"endpoint\",\"field\")] kable(date_fields, row.names = FALSE) res <- search_pv(   query = '{\"patent_id\":\"5116621\"}',    fields = c(\"patent_id\", \"patent_date\", \"patent_title\", \"patent_year\", \"assignees.assignee_type\") )  # unnest_pv_data shows that the assignee_type field is received as a string and patent_year # is received as an integer unnest_pv_data(res$data) #> List of 2 #>  $ assignees:'data.frame':   2 obs. of  2 variables: #>   ..$ patent_id    : chr [1:2] \"5116621\" ... #>   ..$ assignee_type: chr [1:2] \"3\" ... #>  $ patents  :'data.frame':   1 obs. of  4 variables: #>   ..$ patent_id   : chr \"5116621\" #>   ..$ patent_title: chr \"Anti-inflammatory analgesic patch\" #>   ..$ patent_date : chr \"1992-05-26\" #>   ..$ patent_year : int 1992  # cast_pv_data will convert the string patent_date to an R date and assignee_type to an integer recast <- cast_pv_data(res$data) unnest_pv_data(recast) #> List of 2 #>  $ assignees:'data.frame':   2 obs. of  2 variables: #>   ..$ patent_id    : chr [1:2] \"5116621\" ... #>   ..$ assignee_type: int [1:2] 3 3 #>  $ patents  :'data.frame':   1 obs. of  4 variables: #>   ..$ patent_id   : chr \"5116621\" #>   ..$ patent_title: chr \"Anti-inflammatory analgesic patch\" #>   ..$ patent_date : Date[1:1], format: \"1992-05-26\" #>   ..$ patent_year : int 1992"},{"path":[]},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"im-sure-my-query-is-well-formatted-and-correct-but-i-keep-getting-an-error--whats-the-deal","dir":"Articles","previous_headings":"FAQs","what":"I’m sure my query is well formatted and correct but I keep getting an error. What’s the deal?","title":"Getting started","text":"API query syntax guidelines cover API’s behavior. Specifically, several things documented API’s webpage. writing queries vignette details . can also try string version query API’s Swagger UI page. error messages can sometimes help determine problem. Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request.","code":"httr2::last_request()"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"does-the-api-have-any-rate-limitingthrottling-controls","dir":"Articles","previous_headings":"FAQs","what":"Does the API have any rate limiting/throttling controls?","title":"Getting started","text":"Yes, API currently allows 45 calls per minute API key. limit exceeded API return http status 429 response header Retry-set number seconds wait making subsequent requests. R package handle . need request API key set environmental variable PATENTSVIEW_API_KEY value key.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/getting-started.html","id":"how-do-i-access-the-data-frames-inside-the-list-columns-returned-by-search_pv","dir":"Articles","previous_headings":"FAQs","what":"How do I access the data frames inside the list columns returned by search_pv()?","title":"Getting started","text":"Let’s consider following data, assignees primary entity applications “government interest statements” secondary entities (also referred subentities): Government interests fields longer present res$data vector columns fields belong primary entity (e.g., res$data$patent_year) list columns fields belong secondary entity (e.g., res$data$assignees$assignee_organization). two good ways pull data frames nested inside list columns: Use tidyr::unnest. (probably easier choice two). Use patentsview::unnest_pv_data. unnest_pv_data() creates series data frames (one entity level) like tables relational database. provide data returned search_pv() field can act unique identifier primary entities: Now left series flat data frames instead single data frame data frames nested inside . flat data frames can joined together needed via primary key (patent_id).","code":"# Create field list - fields <- get_fields(\"patent\")  # Pull data res <- search_pv(   query = qry_funs$text_any(inventors.inventor_name_last = \"Smith\"),    endpoint = \"patent\",    fields = fields ) res$data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  36 variables: #>   ..$ patent_id                                                   : chr [1:10\".. #>   ..$ patent_title                                                : chr [1:10\".. #>   ..$ patent_type                                                 : chr [1:10\".. #>   ..$ patent_date                                                 : chr [1:10\".. #>   ..$ patent_year                                                 : int [1:100.. #>   ..$ patent_abstract                                             : chr [1:10\".. #>   ..$ patent_cpc_current_group_average_patent_processing_days     : int [1:100.. #>   ..$ patent_detail_desc_length                                   : int [1:100.. #>   ..$ patent_earliest_application_date                            : chr [1:10\".. #>   ..$ patent_num_foreign_documents_cited                          : int [1:100.. #>   ..$ patent_num_times_cited_by_us_patents                        : int [1:100.. #>   ..$ patent_num_total_documents_cited                            : int [1:100.. #>   ..$ patent_num_us_applications_cited                            : int [1:100.. #>   ..$ patent_num_us_patents_cited                                 : int [1:100.. #>   ..$ patent_processing_days                                      : int [1:100.. #>   ..$ patent_term_extension                                       : int [1:100.. #>   ..$ gov_interest_statement                                      : chr [1:10\".. #>   ..$ patent_uspc_current_mainclass_average_patent_processing_days: logi [1:10.. #>   ..$ application                                                 :List of 1000 #>   ..$ applicants                                                  :List of 1000 #>   ..$ assignees                                                   :List of 1000 #>   ..$ attorneys                                                   :List of 1000 #>   ..$ cpc_at_issue                                                :List of 1000 #>   ..$ cpc_current                                                 :List of 1000 #>   ..$ examiners                                                   :List of 1000 #>   ..$ figures                                                     :List of 1000 #>   ..$ gov_interest_organizations                                  :List of 1000 #>   ..$ granted_pregrant_crosswalk                                  :List of 1000 #>   ..$ inventors                                                   :List of 1000 #>   ..$ ipcr                                                        :List of 1000 #>   ..$ us_related_documents                                        :List of 1000 #>   ..$ us_term_of_grant                                            :List of 1000 #>   ..$ wipo                                                        :List of 1000 #>   ..$ foreign_priority                                            :List of 1000 #>   ..$ pct_data                                                    :List of 1000 #>   ..$ gov_interest_contract_award_numbers                         :List of 1000 library(tidyr)  # Get assignee data: res$data$patents %>%    unnest(assignees) %>%   head() #> # A tibble: 6 × 44 #>   patent_id patent_title paten…¹ paten…² paten…³ paten…⁴ paten…⁵ paten…⁶ paten…⁷ #>   <chr>     <chr>        <chr>   <chr>     <int> <chr>     <int>   <int> <chr>   #> 1 10000036  High kineti… utility 2018-0…    2018 Boron …    1286   11286 2015-0… #> 2 10000466  Substituted… utility 2018-0…    2018 The pr…     904  290583 2017-0… #> 3 10000693  Methods and… utility 2018-0…    2018 Method…    1229  156395 2014-0… #> 4 10000750  Method of i… utility 2018-0…    2018 Disclo…    1221   81511 2015-1… #> 5 10000975  Cutting ele… utility 2018-0…    2018 A cutt…    1263    6690 2014-0… #> 6 10000976  Cutting ele… utility 2018-0…    2018 A cutt…    1263   15136 2014-0… #> # … with 35 more variables: patent_num_foreign_documents_cited <int>, #> #   patent_num_times_cited_by_us_patents <int>, #> #   patent_num_total_documents_cited <int>, #> #   patent_num_us_applications_cited <int>, patent_num_us_patents_cited <int>, #> #   patent_processing_days <int>, patent_term_extension <int>, #> #   gov_interest_statement <chr>, #> #   patent_uspc_current_mainclass_average_patent_processing_days <lgl>, … unnest_pv_data(data = res$data, pk = \"patent_id\") #> List of 19 #>  $ application                        :'data.frame': 1000 obs. of  7 variables: #>   ..$ patent_id       : chr [1:1000] \"10000036\" ... #>   ..$ application_id  : chr [1:1000] \"14/753848\" ... #>   ..$ application_type: chr [1:1000] \"14\" ... #>   ..$ filing_date     : chr [1:1000] \"2015-06-29\" ... #>   ..$ series_code     : chr [1:1000] \"14\" ... #>   ..$ rule_47_flag    : logi [1:1000] FALSE ... #>   ..$ filing_type     : chr [1:1000] \"14\" ... #>  $ applicants                         :'data.frame': 1215 obs. of  8 variables: #>   ..$ patent_id             : chr [1:1215] \"10000036\" ... #>   ..$ applicant_name_first  : chr [1:1215] NA ... #>   ..$ applicant_name_last   : chr [1:1215] NA ... #>   ..$ applicant_organization: chr [1:1215] \"The United States of America repr\".. #>   ..$ applicant_sequence    : int [1:1215] 1 1 ... #>   ..$ applicant_designation : chr [1:1215] \"us-only\" ... #>   ..$ applicant_type        : chr [1:1215] \"applicant\" ... #>   ..$ location_id           : chr [1:1215] \"fe1dd7c7-16c7-11ed-9b5f-1234bde3c\".. #>  $ assignees                          :'data.frame': 975 obs. of  10 variables: #>   ..$ patent_id                     : chr [1:975] \"10000036\" ... #>   ..$ assignee                      : chr [1:975] \"https://search.patentsview\".. #>   ..$ assignee_type                 : chr [1:975] \"6\" ... #>   ..$ assignee_individual_name_first: chr [1:975] NA ... #>   ..$ assignee_individual_name_last : chr [1:975] NA ... #>   ..$ assignee_organization         : chr [1:975] \"The United States of Ameri\".. #>   ..$ assignee_city                 : chr [1:975] \"Washington\" ... #>   ..$ assignee_state                : chr [1:975] \"DC\" ... #>   ..$ assignee_country              : chr [1:975] \"US\" ... #>   ..$ assignee_sequence             : int [1:975] 0 0 ... #>  $ attorneys                          :'data.frame': 1131 obs. of  6 variables: #>   ..$ patent_id            : chr [1:1131] \"10000036\" ... #>   ..$ attorney_id          : chr [1:1131] \"3f82077f3559b6f685a391bfbcb2202e\" ... #>   ..$ attorney_sequence    : int [1:1131] 0 1 ... #>   ..$ attorney_name_first  : chr [1:1131] \"Jennifer L.\" ... #>   ..$ attorney_name_last   : chr [1:1131] \"Riley\" ... #>   ..$ attorney_organization: chr [1:1131] NA ... #>  $ cpc_at_issue                       :'data.frame': 7715 obs. of  8 variables: #>   ..$ patent_id      : chr [1:7715] \"10000036\" ... #>   ..$ cpc_sequence   : int [1:7715] 1 2 ... #>   ..$ cpc_class      : chr [1:7715] \"https://search.patentsview.org/api/v1/cp\".. #>   ..$ cpc_class_id   : chr [1:7715] \"B32\" ... #>   ..$ cpc_subclass   : chr [1:7715] \"https://search.patentsview.org/api/v1/cp\".. #>   ..$ cpc_subclass_id: chr [1:7715] \"B32B\" ... #>   ..$ cpc_group      : chr [1:7715] \"https://search.patentsview.org/api/v1/cp\".. #>   ..$ cpc_group_id   : chr [1:7715] \"B32B5/26\" ... #>  $ cpc_current                        :'data.frame': 9497 obs. of  8 variables: #>   ..$ patent_id      : chr [1:9497] \"10000036\" ... #>   ..$ cpc_sequence   : int [1:9497] 0 1 ... #>   ..$ cpc_class      : chr [1:9497] \"https://search.patentsview.org/api/v1/cp\".. #>   ..$ cpc_class_id   : chr [1:9497] \"B32\" ... #>   ..$ cpc_subclass   : chr [1:9497] \"https://search.patentsview.org/api/v1/cp\".. #>   ..$ cpc_subclass_id: chr [1:9497] \"B32B\" ... #>   ..$ cpc_group      : chr [1:9497] \"https://search.patentsview.org/api/v1/cp\".. #>   ..$ cpc_group_id   : chr [1:9497] \"B32B5/26\" ... #>  $ examiners                          :'data.frame': 1227 obs. of  6 variables: #>   ..$ patent_id          : chr [1:1227] \"10000036\" ... #>   ..$ examiner_id        : chr [1:1227] \"l5ntkof8nrlpiyj3rcmiiln2g\" ... #>   ..$ examiner_first_name: chr [1:1227] \"Daniel H\" ... #>   ..$ examiner_last_name : chr [1:1227] \"Lee\" ... #>   ..$ examiner_role      : chr [1:1227] \"primary\" ... #>   ..$ art_group          : chr [1:1227] \"1746\" ... #>  $ figures                            :'data.frame': 968 obs. of  3 variables: #>   ..$ patent_id  : chr [1:968] \"10000036\" ... #>   ..$ num_figures: int [1:968] 19 1 ... #>   ..$ num_sheets : int [1:968] 6 1 ... #>  $ gov_interest_organizations         :'data.frame': 43 obs. of  5 variables: #>   ..$ patent_id     : chr [1:43] \"10000036\" ... #>   ..$ fedagency_name: chr [1:43] \"National Aeronautics and Space Administrati\".. #>   ..$ level_one     : chr [1:43] \"National Aeronautics and Space Administrati\".. #>   ..$ level_two     : chr [1:43] NA ... #>   ..$ level_three   : chr [1:43] NA ... #>  $ granted_pregrant_crosswalk         :'data.frame': 1004 obs. of  3 variables: #>   ..$ patent_id         : chr [1:1004] \"10000036\" ... #>   ..$ document_number   : chr [1:1004] \"20170190143\" ... #>   ..$ application_number: chr [1:1004] \"14753848\" ... #>  $ inventors                          :'data.frame': 4153 obs. of  8 variables: #>   ..$ patent_id          : chr [1:4153] \"10000036\" ... #>   ..$ inventor           : chr [1:4153] \"https://search.patentsview.org/api/v\".. #>   ..$ inventor_name_first: chr [1:4153] \"Cheol\" ... #>   ..$ inventor_name_last : chr [1:4153] \"Park\" ... #>   ..$ inventor_city      : chr [1:4153] \"Yorktown\" ... #>   ..$ inventor_state     : chr [1:4153] \"VA\" ... #>   ..$ inventor_country   : chr [1:4153] \"US\" ... #>   ..$ inventor_sequence  : int [1:4153] 1 3 ... #>  $ ipcr                               :'data.frame': 5383 obs. of  11 variables: #>   ..$ patent_id                     : chr [1:5383] \"10000036\" ... #>   ..$ ipc_sequence                  : int [1:5383] 0 1 ... #>   ..$ ipc_action_date               : chr [1:5383] \"2018-06-19\" ... #>   ..$ ipc_section                   : chr [1:5383] \"B\" ... #>   ..$ ipc_class                     : chr [1:5383] \"32\" ... #>   ..$ ipc_subclass                  : chr [1:5383] \"B\" ... #>   ..$ ipc_main_group                : chr [1:5383] \"5\" ... #>   ..$ ipc_subgroup                  : chr [1:5383] \"26\" ... #>   ..$ ipc_symbol_position           : chr [1:5383] \"F\" ... #>   ..$ ipc_classification_data_source: chr [1:5383] \"H\" ... #>   ..$ ipc_classification_value      : chr [1:5383] \"I\" ... #>  $ us_related_documents               :'data.frame': 4349 obs. of  9 variables: #>   ..$ patent_id                 : chr [1:4349] \"10000036\" ... #>   ..$ related_doc_type          : chr [1:4349] \"division\" ... #>   ..$ related_doc_kind          : chr [1:4349] NA ... #>   ..$ related_doc_number        : chr [1:4349] \"13136216\" ... #>   ..$ published_country         : chr [1:4349] \"US\" ... #>   ..$ related_doc_published_date: chr [1:4349] \"2011-07-26\" ... #>   ..$ related_doc_status        : chr [1:4349] NA ... #>   ..$ related_doc_sequence      : int [1:4349] 0 1 ... #>   ..$ wipo_kind                 : chr [1:4349] NA ... #>  $ us_term_of_grant                   :'data.frame': 658 obs. of  5 variables: #>   ..$ patent_id      : chr [1:658] \"10000036\" ... #>   ..$ term_grant     : logi [1:658] NA ... #>   ..$ term_extension : chr [1:658] \"85\" ... #>   ..$ term_disclaimer: chr [1:658] NA ... #>   ..$ disclaimer_date: logi [1:658] NA ... #>  $ wipo                               :'data.frame': 1748 obs. of  3 variables: #>   ..$ patent_id    : chr [1:1748] \"10000036\" ... #>   ..$ wipo_field_id: chr [1:1748] \"29\" ... #>   ..$ wipo_sequence: int [1:1748] 0 1 ... #>  $ foreign_priority                   :'data.frame': 87 obs. of  6 variables: #>   ..$ patent_id              : chr [1:87] \"10000975\" ... #>   ..$ priority_claim_sequence: int [1:87] 0 0 ... #>   ..$ priority_claim_kind    : chr [1:87] \"national\" ... #>   ..$ foreign_application_id : chr [1:87] \"1301647.2\" ... #>   ..$ filing_date            : chr [1:87] \"2013-01-30\" ... #>   ..$ foreign_country_filed  : chr [1:87] \"GB\" ... #>  $ pct_data                           :'data.frame': 218 obs. of  7 variables: #>   ..$ patent_id           : chr [1:218] \"10000975\" ... #>   ..$ published_filed_date: chr [1:218] \"2014-01-28\" ... #>   ..$ pct_102_date        : logi [1:218] NA ... #>   ..$ pct_371_date        : chr [1:218] \"2015-07-28\" ... #>   ..$ application_kind    : chr [1:218] \"00\" ... #>   ..$ pct_doc_number      : chr [1:218] \"PCT/GB2014/050210\" ... #>   ..$ pct_doc_type        : chr [1:218] \"pct_application\" ... #>  $ gov_interest_contract_award_numbers:'data.frame': 36 obs. of  2 variables: #>   ..$ patent_id   : chr [1:36] \"10004797\" ... #>   ..$ award_number: chr [1:36] \"2007-33610-18035\" ... #>  $ patents                            :'data.frame': 1000 obs. of  18 variables: #>   ..$ patent_id                                                   : chr [1:10\".. #>   ..$ patent_title                                                : chr [1:10\".. #>   ..$ patent_type                                                 : chr [1:10\".. #>   ..$ patent_date                                                 : chr [1:10\".. #>   ..$ patent_year                                                 : int [1:100.. #>   ..$ patent_abstract                                             : chr [1:10\".. #>   ..$ patent_cpc_current_group_average_patent_processing_days     : int [1:100.. #>   ..$ patent_detail_desc_length                                   : int [1:100.. #>   ..$ patent_earliest_application_date                            : chr [1:10\".. #>   ..$ patent_num_foreign_documents_cited                          : int [1:100.. #>   ..$ patent_num_times_cited_by_us_patents                        : int [1:100.. #>   ..$ patent_num_total_documents_cited                            : int [1:100.. #>   ..$ patent_num_us_applications_cited                            : int [1:100.. #>   ..$ patent_num_us_patents_cited                                 : int [1:100.. #>   ..$ patent_processing_days                                      : int [1:100.. #>   ..$ patent_term_extension                                       : int [1:100.. #>   ..$ gov_interest_statement                                      : chr [1:10\".. #>   ..$ patent_uspc_current_mainclass_average_patent_processing_days: logi [1:10.."},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/patentsview-breaking-change.html","id":"user-impacting-api-changes","dir":"Articles","previous_headings":"","what":"User Impacting API changes:","title":"Breaking release of the Patentsview Package","text":"Users need request API key set environmental variable PATENTSVIEW_API_KEY value. Endpoint changes: nber_subcategories, one original seven endpoints, removed cpc_subsections now cpc_group remaining five original endpoints went plural singular, “patents” now “patent” example. Interestingly, returned data structures still plural part. now 23 endpoints, may need called retrieve fields currently (soon---) available original endpoints (now endpoint’s returns lighter, requiring additional calls made). Now endpoints return HATEOAS (Hypermedia Engine Application State) links retrieve data (URLs additional calls back API) fields now nested need fully qualified used query, e.g., search_pv('{\"cpc_current.cpc_group_id\":\"A01B1/00\"}') using patent endpoint. fields parameter, nested fields can fully qualified new API shorthand can used, group names can specified. group names used, group’s nested fields returned API. Ex. new version API R package accept fields=c(“assignees”) using patent endpoint nested assignees fields returned API. field’s names changed, significantly, patent_number now patent_id, fields removed entirely, e.g., rawinventor_first_name rawinventor_last_name. original version API queryable fields additional fields retrieved couldn’t part conditional query. notion apply new version API fields now queryable. may able simplify code found post processing returned data field interested queryable. Currently working properly, isn’t supposed difference operators used full text fields, original version API. See tip Syntax section . Note result sizes aren’t matching currently though, see testthat/test-api-bugs.R API team also renamed API, PatentsView’s Search API now PatentSearch API, announced . Note R package retain name, continue use library(patentsview)","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/patentsview-breaking-change.html","id":"highlights-of-the-r-package","dir":"Articles","previous_headings":"","what":"Highlights of the R package:","title":"Breaking release of the Patentsview Package","text":"Throttling now enforced API handled R package (sleep specified throttle response retry) new “Converting existing script” vignette ropensci post announced original version R package changed work new version API now new vignette. hex sticker created using GuangchuangYu’s hexSticker R package changed internally using httr httr2. affects users passed additional arguments (…) search_pv(). Previously passed config = httr::timeout(40) ’d now pass timeout = 40 (name-value pairs valid curl options, found curl::curl_options() see req_options) Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request. Also fun seeing raw API response. retrieve_linked_data() retrieve data HATEOAS link API sent back, retrying throttled qry_funs$in_range() generate range queries .","code":"httr2::last_request() httr2::last_response() httr2::last_response() |> httr2::resp_body_json() library(patentsview) qry_funs$in_range(patent_date = c(\"1976-01-01\", \"1983-02-28\")) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1983-02-28\"}}]}  qry_funs$in_range(patent_year = c(2010, 2021)) #> {\"_and\":[{\"_gte\":{\"patent_year\":2010}},{\"_lte\":{\"patent_year\":2021}}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/patentsview-breaking-change.html","id":"online-documentation","dir":"Articles","previous_headings":"","what":"Online Documentation","title":"Breaking release of the Patentsview Package","text":"API team thoughtfully provided Swagger UI page new version API https://search.patentsview.org/swagger-ui/. Think online version Postman already loaded API’s new endpoints returns. Swagger UI page documents fields returned endpoint successful call. (Response http code 200). can even send requests see actual API responses enter API key press endpoint’s “Try ” “Execute” buttons. Even error responses can informative, usually pointing went wrong. similar format, updated API documentation lists endpoint . Additionally, R package’s fieldsdf data frame updated, now listing new set endpoints retrievable/queryable fields. R package’s reference pages also updated.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/patentsview-breaking-change.html","id":"final-thoughts","dir":"Articles","previous_headings":"","what":"Final Thoughts","title":"Breaking release of the Patentsview Package","text":"shown updated Top Assignees vignette, occasions now multiple API calls needed retrieve data single API call original version API R package. Additionally, reworked ropensci post explains changes made since assignee latitude longitude longer available patent endpoint. Please open issues R package . Issues questions API can raised API’s forum.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/result-set-paging.html","id":"example-1","dir":"Articles","previous_headings":"","what":"Example 1","title":"Result Set Paging","text":"’ll retrieve 5000 utility patents paging.","code":"library(patentsview)  # Lets get 5000 utility patents, 1000 at a time (the API's maximum rows per request) requested_rows <- 1000 sort <- c(\"patent_id\" = \"asc\") query <- qry_funs$eq(\"patent_type\" = \"utility\") fields <- c(\"patent_id\", \"patent_date\", \"patent_title\")  # The \"after\" parameter is explained a bit lower.  It's an Elasticsearch thing, # which is the attrbute the new version of the API uses to page.  For now, just be  # thankful that the R package handles this for you when you set all_pages = TRUE after <- NULL  tmp <- lapply(seq_len(5), function(n) {   print(paste(\"page\", n, \"after is\", ifelse(is.null(after),\"NULL\",after)))   page_n <- search_pv(query, fields = fields, sort = sort,      all_pages = FALSE, size = requested_rows, after = after)    s <- names(sort)    index <- nrow(page_n$data[[1]])    after <<- page_n$data[[1]][[s]][[index]]    page_n$data }) #> [1] \"page 1 after is NULL\" #> [1] \"page 2 after is 10001014\" #> [1] \"page 3 after is 10002021\" #> [1] \"page 4 after is 10003025\" #> [1] \"page 5 after is 10004043\"  utility_patents <- as.data.frame(do.call(rbind, lapply(tmp, as.data.frame))) str(utility_patents) #> 'data.frame':    5000 obs. of  3 variables: #>  $ patents.patent_id   : chr  \"10000000\" \"10000001\" \"10000002\" \"10000003\" ... #>  $ patents.patent_title: chr  \"Coherent LADAR using intra-pixel quadrature detection\" \"Injection molding machine and mold thickness control method\" \"Method for manufacturing polymer film and co-extruded film\" \"Method for producing a container from a thermoplastic\" ... #>  $ patents.patent_date : chr  \"2018-06-19\" \"2018-06-19\" \"2018-06-19\" \"2018-06-19\" ..."},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/result-set-paging.html","id":"example-2","dir":"Articles","previous_headings":"","what":"Example 2","title":"Result Set Paging","text":"execute query two different ways, first R package paging, second misguided attempt paging . exercise reader, US patent office says 5677 patents issued January 1976 patentsview database says 5352. Open bug try figure numbers far . Now ’ll try paging might notice, ’ll run trouble. ran trouble since chose patent_date sort field isn’t unique result set patent_id Example 1. R package uses appropriate primary key (get_ok_pk(endpoint)) requesting paged data (all_pages = TRUE) endpoint. pages retrieved, R package sorts data user requested. (sorting methodology inspired Patentsview’s python wrapper)","code":"fields <- c(\"patent_id\", \"patent_date\", \"patent_title\") sort <- c(\"patent_date\" = \"asc\") query <- qry_funs$in_range(patent_date=c(\"1976-01-01\", \"1976-01-31\")) query #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1976-01-31\"}}]}  r_pkg <- search_pv(query, sort = sort, fields = fields, all_pages = TRUE)  # note the number of rows returned r_pkg$query_results$total_hits #> [1] 5352 after <- NULL combined_data <- NULL count <- 0 requested_rows <- 1000  # API's maximum rows per request fields <- c(\"patent_id\", \"patent_date\", \"patent_title\") sort <- c(\"patent_date\" = \"asc\") query <- qry_funs$in_range(patent_date=c(\"1976-01-01\", \"1976-01-31\")) query #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1976-01-31\"}}]}  # We'll continue to make requests until we get back an empty or partial # response from the API page <- 1  repeat {   print(paste(\"page\", page, \"after is\", ifelse(is.null(after), \"NULL\", after)))    subsequent <- search_pv(query, sort = sort, all_pages = FALSE,     fields = fields, size = requested_rows, after = after)    returned_rows <- subsequent$query_results$count   count <- count + returned_rows    page <- page  + 1    if(returned_rows > 0) {      combined_data <- rbind(combined_data, subsequent$data$patents)   }    # We're done if we got an empty or partial reply from the API   if(returned_rows < requested_rows) {      break   }    # Now to page we need to set the \"after\" attribute to where the   # current results ended.  Its value is the last row's [[sort field]].    # It would need to be an array of values if there are multiple sort fields   s <- names(sort)[[1]]   after <- subsequent$data[[1]][[s]][[returned_rows]]  } #> [1] \"page 1 after is NULL\" #> [1] \"page 2 after is 1976-01-06\" #> [1] \"page 3 after is 1976-01-13\" #> [1] \"page 4 after is 1976-01-20\" #> [1] \"page 5 after is 1976-01-27\"  print(paste(\"count is\", count)) #> [1] \"count is 4000\" print(nrow(combined_data)) #> [1] 4000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/result-set-paging.html","id":"reader-exercise","dir":"Articles","previous_headings":"","what":"Reader Exercise","title":"Result Set Paging","text":"Ok, ’ll get started user exercise. Trivia: handful exceptions, patents issued Tuesdays.","code":"uspto_counts <- c(1478, 1312, 1449, 1438)     issue_date <- as.Date(\"1976-01-06\")  # first Tuesday of January 1976     weekly_counts <- lapply(seq(from = 0, to = 21, by = 7), function(additional_days, base_issue_date) {      issue_date <- base_issue_date + additional_days      query <- qry_funs$eq(\"patent_date\" = as.character(issue_date))      query      issued_patents <- search_pv(query)      print(paste(\"issue date\", issue_date, issued_patents$query_results$total_hits,          \"issued patents\"))      issued_patents$query_results$total_hits    }, issue_date) #> [1] \"issue date 1976-01-06 1379 issued patents\" #> [1] \"issue date 1976-01-13 1257 issued patents\" #> [1] \"issue date 1976-01-20 1383 issued patents\" #> [1] \"issue date 1976-01-27 1332 issued patents\"     total <- do.call(sum, weekly_counts)    print(paste(\"patentsview total\", total)) #> [1] \"patentsview total 5351\"    print(paste(\"uspto total\", sum(uspto_counts))) #> [1] \"uspto total 5677\""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"why-care-about-patents","dir":"Articles","previous_headings":"","what":"Why care about patents?","title":"Accessing patent data with the patentsview package","text":"1. Patents play critical role incentivizing innovation, without wouldn’t much technology rely everyday iPhone, Google’s PageRank algorithm, butter substitute called Smart Balance common?  …probably wouldn’t patents. patent provides owner ability make money something invented, without worry someone else copying technology. Think Apple spend millions dollars developing iPhone Samsung just come along rip ? Probably . 2. Patents offer great opportunity data analysis two primary reasons : Patent data public. return exclusive right profit invention, individual/company publicly disclose details invention rest world. Examples details include patent’s title, abstract, technology classification, assigned organizations, etc. Patent data can answer questions people care . Companies (especially big ones like IBM Google) vested interest extracting insights patents, spend lot time/resources trying figure best manage intellectual property (IP) rights. ’re plagued questions like “sell underperforming patents ,” “technology areas open new innovations,” “’s going next big thing world buttery spreads,” etc. Patents offer way provide data-driven answers questions. Combined, two things make patents prime target data analysis. However, recently hard get data inside documents. One either collect manually using official United States Patent Trademark Office (USPTO) search engine, figure way download, parse, model huge XML data dumps. Enter PatentsView.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"patentsview-and-the-patentsview-package","dir":"Articles","previous_headings":"","what":"PatentsView and the patentsview package","title":"Accessing patent data with the patentsview package","text":"PatentsView one USPTO’s new initiatives intended increase usability value patent data. One feature project publicly accessible API makes easy programmatically interact data. reasons like API (PatentsView generally): API key now required (request one ) throttling imposed (handled new version R package) 45 requests per minute. project offers bulk downloads patent data website (flat file format), want closest data. API bulk download data contain disambiguated entities inventors, assignees, organizations, etc. words, API tell whether thinks John Smith patent X person John Smith patent Y.1 patentsview R package wrapper around PatentsView API. contains function acts client API (search_pv()) well several supporting functions. Full documentation package can found website.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Accessing patent data with the patentsview package","text":"can install stable version patentsview r-universe: GitHub:","code":"options(repos = c(   patentsview = \"https://mustberuss.r-universe.dev/\",   CRAN = \"https://cloud.r-project.org\" ))  install.packages(\"patentsview\") if (!require(devtools)) install.packages(\"devtools\")    devtools::install_github(\"mustberuss/patentsview@api-redesign\")"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Accessing patent data with the patentsview package","text":"package one main function, search_pv(), makes easy send requests API. two parameters search_pv() ’re going want think just every time call - query fields. tell API want filter patent data query, fields want retrieve fields.2","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"query","dir":"Articles","previous_headings":"Getting started","what":"query","title":"Accessing patent data with the patentsview package","text":"query use PatentsView query language, JSON-based syntax similar one used Lucene. can write query directly pass string search_pv(): …can use domain specific language (DSL) provided patentsview package help write query: qry_1 qry_2 result HTTP call API. queries search patents USPTO published 2014. three gotchas look writing query: Fields now queryable. API 23 endpoints (default endpoint “patent”), endpoint set fields can filter . Correct data type field. ’re filtering field query, make sure value filtering consistent field’s data type. example, patent_year type “integer,” pass 2014 string ’re going get error (patent_year = 2014 good, patent_year = \"2014\" good). can find field’s data type fieldsdf data frame. Comparison function works field’s data type. comparison function(s) use (e.g., greater-function shown , qry_funs$gt()) must consistent field’s data type. example, can’t use “contains” function fields type “integer” (qry_funs$contains(patent_year = 2014) throw error). See ?qry_funs details. short, use fieldsdf data frame write query fine. Check writing queries vignette details.","code":"library(patentsview)  qry_1 <- '{\"_gt\":{\"patent_year\":2014}}' search_pv(query = qry_1, fields = NULL) # This will retrieve a default set of fields #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10000000\" ... #>   ..$ patent_title: chr [1:1000] \"Coherent LADAR using intra-pixel quadrature\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,401,344, count = 1,000 qry_2 <- qry_funs$gt(patent_year = 2014) # All DSL functions are in the qry_funs list qry_2 # qry_2 is the same as qry_1 #> {\"_gt\":{\"patent_year\":2014}}  search_pv(query = qry_2) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10000000\" ... #>   ..$ patent_title: chr [1:1000] \"Coherent LADAR using intra-pixel quadrature\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,401,344, count = 1,000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"fields","dir":"Articles","previous_headings":"Getting started","what":"fields","title":"Accessing patent data with the patentsview package","text":"now using default value fields. results API giving us small set default fields. Let’s see retrieving fields: original verison API, requested patent_average_processing_time inventor_total_num_patents. fields longer available patent endpoint. fields can retrieve depends endpoint hitting. ’ve using “patent” endpoint thus far, retrievable: fieldsdf[fieldsdf$endpoint == \"patent\", \"field\"]. can also use get_fields() list retrievable fields given endpoint, optionally limited specific groups nested top level (“” groups) fields","code":"search_pv(   query = qry_funs$gt(patent_year = 2014),   fields = c(\"patent_abstract\", \"inventors.inventor_name_first\") ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_abstract: chr [1:1000] \"A frequency modulated (coherent) laser d\".. #>   ..$ inventors      :List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,401,344, count = 1,000 search_pv(   query = qry_funs$gt(patent_year = 2014),   fields = get_fields(endpoint = \"patent\", groups = c(\"\", \"inventors\")) ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  19 variables: #>   ..$ patent_id                                                   : chr [1:10\".. #>   ..$ patent_title                                                : chr [1:10\".. #>   ..$ patent_type                                                 : chr [1:10\".. #>   ..$ patent_date                                                 : chr [1:10\".. #>   ..$ patent_year                                                 : int [1:100.. #>   ..$ patent_abstract                                             : chr [1:10\".. #>   ..$ patent_cpc_current_group_average_patent_processing_days     : int [1:100.. #>   ..$ patent_detail_desc_length                                   : int [1:100.. #>   ..$ patent_earliest_application_date                            : chr [1:10\".. #>   ..$ patent_num_foreign_documents_cited                          : int [1:100.. #>   ..$ patent_num_times_cited_by_us_patents                        : int [1:100.. #>   ..$ patent_num_total_documents_cited                            : int [1:100.. #>   ..$ patent_num_us_applications_cited                            : int [1:100.. #>   ..$ patent_num_us_patents_cited                                 : int [1:100.. #>   ..$ patent_processing_days                                      : int [1:100.. #>   ..$ patent_term_extension                                       : int [1:100.. #>   ..$ gov_interest_statement                                      : chr [1:100.. #>   ..$ patent_uspc_current_mainclass_average_patent_processing_days: logi [1:10.. #>   ..$ inventors                                                   :List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,401,344, count = 1,000"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Accessing patent data with the patentsview package","text":"Let’s look quick example pulling analyzing patent data. ’ll look patents last ten years classified H04L63/00 CPC code. Patents area relate “network architectures network communication protocols separating internal external traffic.”3 CPC codes offer quick dirty way find patents interest, though getting sense hierarchy can tricky. Download data original blog’s query possible new version API, assignee_longitude assignee_latitude longer returned patent endpoint. ’ll use different endpoint slightly different query get latitudes longitudes plot. Now ’ll query assignee endpoint non-empty assignee_organization name, assignee_individual_name_first assignee_individual_name_last empty (query assignee entity, individual). sort assignee_num_patents descending ’ll get list prolific assignee_organizations See assignees coming (geographically)  Plot growth field’s topics time","code":"library(patentsview)  query <- with_qfuns( # with_qfuns is basically just: with(qry_funs, ...)   neq(\"assignee_organization\" = \"\") )  # Create a list of fields: # We request the fields we will use below rather than requesting them all and  # then filtering to get just the ones we want fields <- c(\"assignee_id\", \"assignee_organization\", \"assignee_num_patents\",    \"assignee_lastknown_latitude\", \"assignee_lastknown_longitude\")  # Send HTTP request to API's server: pv_res <- search_pv(endpoint = \"assignee\", query = query, fields = fields,     sort = c(\"assignee_num_patents\" = \"desc\"), all_pages = FALSE) library(leaflet) library(htmltools) library(dplyr) library(tidyr) library(stringr)  # My mom was an English teacher, so below we singularize/pluralize Patents # or maybe Patents:1 was ok?  Here, because of the sort, it will be unlikely # that there will be a single patent in our results.  data <-   pv_res$data$assignees %>%   mutate(popup = paste0(     \"<font color='Black'>\",     htmlEscape(assignee_organization), \"<br><br>Patent\",     ifelse(assignee_num_patents == 1, \":\", \"s:\"), # singular/plural     assignee_num_patents, \"<\/font>\"   )) %>%   filter_at(vars(assignee_lastknown_latitude, assignee_lastknown_longitude), any_vars(!is.na(.))) # seeing NA lats and longs  leaflet(data) %>%   addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%   addCircleMarkers(     lng = ~assignee_lastknown_longitude, lat = ~assignee_lastknown_latitude,     popup = ~popup, radius=2, color = \"yellow\"   ) library(ggplot2) library(RColorBrewer)  # Here we issue the original post's query, rewritten for the new version of the API # (note the field name change as well as it being nested inside the cpc_current object) # Oh, and we bumped the patent_year to give us data for the last ten years query <- with_qfuns( # with_qfuns is basically just: with(qry_funs, ...)   and(     begins(cpc_current.cpc_group_id = \"H04L63/02\"),     gte(patent_year = 2014)   ) )  # Create a list of fields: fields <- c(   c(\"patent_id\", \"patent_year\"),   get_fields(endpoint = \"patent\", groups = c(\"assignees\", \"cpc_current\")) )  pv_res <- search_pv(query = query, fields = fields, all_pages = TRUE)  # In the new version of the API, we don't get the CPC title back from the patent endpoint # we have to call, you guessed it, the cpc_group endpoint now qry <- qry_funs$begins(cpc_group_id = \"H04L63/02\") qry #> {\"_begins\":{\"cpc_group_id\":\"H04L63/02\"}}  cpc_info <- search_pv(query = qry, fields = get_fields(\"cpc_group\"), endpoint = \"cpc_group\")  # More API craziness, in the HATEOAS link from the patent endpoint, the separator is # inexplicably a colon.  In the data that comes back from the cpc_group endpoint, the # separator is, get this, a slash like it should be.  All that to say that joining # becomes a bit problematic or an exercise that makes dplyr wonder what we're up to.  data <-   pv_res$data$patents %>%   unnest(cpc_current) %>%   mutate(cpc_group = sub(\".*/([\\\\w:]+)/$\", \"\\\\1\", cpc_group, perl = TRUE)) %>% # unHATEOAS cpc_group, funky colon and all   filter(cpc_group != \"H04L63:02\") %>% # remove patents categorized into only top-level category of H04L63/02   mutate(cpc_group = sub(\":\", \"/\", cpc_group)) %>% # back to normality, ahead of a join   inner_join(cpc_info$data$cpc_groups, by = \"cpc_group_id\") %>%   ungroup() %>%   mutate(     title = case_when(       grepl(\"filtering\", .$cpc_group_title, ignore.case = T) ~         \"Filtering policies\",       .$cpc_group %in% c(\"H04L63/0209\", \"H04L63/0218\") ~         \"Architectural arrangements\",       grepl(\"Firewall traversal\", .$cpc_group_title, ignore.case = T) ~         \"Firewall traversal\",       TRUE ~         .$cpc_group_title     )   ) %>%   mutate(title = gsub(\".*(?=-)-\", \"\", title, perl = TRUE)) %>%   group_by(title, patent_year) %>%   count() %>%   ungroup()  max_year <- max(data$patent_year) y_limit <- max(data$n) + 100 - (max(data$n) %% 100) # even hundred past the max  ggplot(data = data) +   geom_smooth(aes(x = patent_year, y = n, colour = title), se = FALSE) +   scale_x_continuous(\"\\nGrant year\",     limits = c(2014, max_year),     breaks = 2014:max_year   ) +   scale_y_continuous(\"Patents\\n\", limits = c(0, y_limit)) +   scale_colour_manual(\"\", values = brewer.pal(5, \"Set2\")) +   theme_bw() + # theme inspired by https://hrbrmstr.github.io/hrbrthemes/   theme(panel.border = element_blank(), axis.ticks = element_blank()) +   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"learning-more","dir":"Articles","previous_headings":"","what":"Learning more","title":"Accessing patent data with the patentsview package","text":"analysis examples go little depth, check data applications vignettes package’s website. ’re just interested search_pv(), examples site well. contribute package report issue, check issues page GitHub.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/ropensci-blog-post.html","id":"acknowledgments-from-the-original-blog-post","dir":"Articles","previous_headings":"","what":"Acknowledgments from the Original Blog Post","title":"Accessing patent data with the patentsview package","text":"’d like thank package’s two reviewers, Paul Oldham Verena Haunschmid, taking time review package providing helpful feedback. ’d also like thank Maëlle Salmon shepherding package along rOpenSci review process, well Scott Chamberlain Stefanie Butland miscellaneous help.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/state-of-the-api.html","id":"on-the-plus-side","dir":"Articles","previous_headings":"","what":"On the Plus Side","title":"State of the API","text":"positive API changes: fields can queried now. 100,000 row result set size limit seems gone. Might part curse user might intended retrieve utility patents etc. new version API returns data types strings, e.g. application.rule_47_flag patent endpoint boolean. View(fieldsdf[grep('number|integer|boolean',fieldsdf$data_type),c(\"endpoint\",\"field\",\"data_type\")]) currently returns 90 rows still fields API returns strings cast-pv-data() casts appropriate data type1. fieldsdf$data_type set int bool fields. API team created Swagger UI page new version API. Joys Swagger UI","code":"library(patentsview)  # Count of non string, non date fields returned by the new version of the API nrow(fieldsdf[grep(\"number|integer|boolean\", fieldsdf$data_type), ]) ## [1] 90 print(fieldsdf[grep(\"bool$|int$\", fieldsdf$data_type), c(\"endpoint\", \"field\", \"data_type\")], row.names = FALSE) ##                        endpoint                    field data_type ##                        assignee            assignee_type       int ##                          patent  assignees.assignee_type       int ##  patent/us_application_citation citation_document_number       int ##                     publication  assignees.assignee_type       int ##                     publication             rule_47_flag      bool ##        publication/rel_app_text          document_number       int"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/state-of-the-api.html","id":"issues","dir":"Articles","previous_headings":"","what":"Issues","title":"State of the API","text":"original API’s sunset date currently February 12, 2025 though new version still issues new string case sensitivity, opened bug listed string vs full text operators, also opened bug listed . Note isn’t way distinguish strings full text fields OpenAPI object (limitation OpenAPI spec). may need change way fieldsdf generated need track operators can used, possibly parsing API’s endpoints page API Oddities requested fields ending _id come back without _id2 Ex patent endpoint requested inventors.inventor_id assignees.assignee_id returned inventors.inventor assignees.assignee, values respective HATEOAS links Two HATEOAS links use colon instead two URL parameters https://search.patentsview.org/api/v1/cpc_group/G01S7:4865/ https://search.patentsview.org/api/v1/uspc_subclass/403:57/ (endpoint currently throws 500) API key now required , intentionally, URLs aren’t clickable since API key sent, resulting 403 Forbidden response. Field inconsistencies two rule_47_flag fields, one returned patent endpoint one returned publication endpoint. former returned boolean, latter string cast-pv-data casts boolean.3 assignee_type, available three endpoints, returned string looks like ’re integer values4 document_number fields integers two returned strings cast-pv-data casts integers.5 Additional details endpoints’ returns plural form singular endpoint exceptions: (Note patent/rel_app_text returns rel_app_texts, following singular/plural pattern) exactly oddity, better place , ’s comparison old new attributes can sent API o: (options) parameter via search_pv() another -exactly--oddity, API’s sort patent_id, string field, gets funky mixing patent ids 10,000,000 (ones 10M come first). thing happens patent types, like reissue, ids different string lengths. See code block bottom understanding api vignette. Along lines, query currently returns 38,470,760 rows isn’t expected! (checked original version API .) {\"_and\":[{\"_gte\":{\"patent_id\":\"10\"}},{\"_lte\":{\"patent_id\":\"13\"}}]} oddities specific new version API, due source files make patentsview database. opened issues API bug PVS-1342 “Underlying data issues”, slighly diplomatic wording. One weirdest things approximately 8000 withdrawn patents patentsview database. source database bulk xml files US Patent Office releases weekly. problem sometimes patents withdrawn appearing bulk xml file kept patentsview database alongside non withdrawn patents. weird ? Patent Office’s withdrawn patent list, updated weekly. equally strange situation approximately 300 non-withdrawn patents , whatever reason, appear bulk xml file week issued. granted patents patentsview database. Plant patents reissued patents current CPC assignments appropriate. problem bulk Cooperative Patent Classification file granted patents, produced USPTO quarterly, contains assignments utility patents. didn’t check assuming USPTO’s bulk CPC file applications contains current CPCs utility patents. patentsview database cpc_at_issue fields patents cpc_current fields utility patents. E.g., thousands plant patents A01H 5/02 one current CPCs ppubs yet none patentsview database. similar problem USPCs. US Patent stopped assigning utility patent 2015, favor CPCs. still used, however, plant patents, yet US Patent office stopped producing bulk file USPCs 2018. Plant patents uspc_at_issue fields set patentsview database, API uspc_current field. lack current CPCs USPCs plant patents means classification searches aren’t preformed version corresponding classification system. ’s page showing often CPC changes. ’s page shows USPC change orders stopped 2013. classification searches plant patents, may want use ppubs system.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/state-of-the-api.html","id":"open-api-bugs","dir":"Articles","previous_headings":"","what":"Open API Bugs","title":"State of the API","text":"Weirdly, can view bugs ’ve submitted. Based digits reference number, ’m assuming open bugs. PVS-1109  otherreference endpoint rejects default Swagger UI parameters (throws 400 Bad Request Error either reference_sequence reference_text requested) returns data patent_id requested. See test_that(“otherreferences endpoint still broken”) test-api-bugs.R Also, OpenAPI object says returned object other_references another exception singular endpoint/plural return pattern7. PVS-1125 fields OpenAPI object can requested See test_that(“field fieldsdf can retrieved”) test-api-bugs.r PVS-1147  Results case dependent now using implied explicit equals See test_that(“case sensitivity string equals”) test-api-bugs.R PVS-1155 Documentation inconsistencies endpoint listed /api/v1/attorney/, /api/v1/patent/attorney GET/POST /api/v1/patent/attorney/{attorney_id}/ GET url parameter beta endpoints say GETs. Swagger UI page OpenAPI object say accept posts , work. PVS-1181 Improvement Suggestion isn’t data dictionary API like bulk download files. specific question difference patent_earliest_application_date application.filing_date returned new patent endpoint. questions values assignees.assignee_type field represent, integers field received integer rather string? PVS-1218 openapi.json errors “publication”,“us_parties.applicant_authority” type “keyword” “string” two rule_47_flag fields, one boolean (line 7019), string (line 8004) document_numbers integers publication/rel_app_text ’s string citation_document_number patent/us_application_citation PVS-1306 API accepts invalid fields API accepts invalid fields start looking like valid fields throw error. Ex f: [“patent_iddddddddddddd”, “patent_dateagogo”] q: {“patent_idd”:“10000000”} result: { “error”: false, “count”: 0, “total_hits”: 0, “patents”: [] } See test_that(“invalid fields accepted”) test-api-bugs.R PVS-1342 Underlying data issues ~300 issued patents missing database, ~8000 withdrawn patents present database, plant patents reissued patents don’t current CPC assigments applicable. didn’t check assuming bulk CPC file applications publication endpoint issue. (’s detail last API oddity) PVS-1377 sort field doesn’t accept unnested fields API throws errors fields specified sort, e.g. patent_title patent endpoint. 39 endpoint/field pairs currently fail. See test_that(“can’t sort fields”) test-api-bugs.R Add test cases? Unknown Reference Number sort field needs specified paging results. mentioned bug API’s forum. causes awkardness search_pv (add sort field primary key included fields. Awkard fields specified)","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/state-of-the-api.html","id":"state-of-the-r-package","dir":"Articles","previous_headings":"","what":"State of the R Package","title":"State of the API","text":"Two new methods added R package reworked ropensci post explains changes made since assignee latitude longitude longer available patent endpoint. new vignette, inspired API team’s jupyter notebook, created showing two things mentions API now R package allow nested attributes wildcarded, group’s name retrieve group’s nested fields. empty string can also passed group name get_fields() requests non-nested attributes endpoint. Ex. get_fields(\"patent\", group=c(\"\", \"inventors\") applying multiple conditions related-entity fields endpoints now singular, match API’s change. new endpoints nested patent/ one nested publication/, also matching API’s change covers, httr changed httr2 (see several mentions ). matters users passed additional arguments (…) search_pv(). Previously passed config = httr::timeout(40) ’d now pass timeout = 40 (name-value pairs valid curl options, found curl::curl_options()) Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request. Also fun, useful reporting bug, seeing raw API response. Package contributor specific changes Changed httr httr2 httr says ’s superseded httr2 ’s trying put us business handling 429 retries etc. See Wrapping APIs vignette github repo set deliver https://mustberuss.r-universe.dev/patentsview. new version R package can installed viainstall.packages('patentsview', repos = c('https://mustberuss.r-universe.dev')) new implementation paging PR discussion paging primary sort. added dependency data.table. also new vignette new implementation paging patent/otherreference endpoint isn’t currently working (reported bug ). isn’t included return get_endpoints() negative test case fail API responds something error. R package unit tests skips negative tests API bugs still exist (’ll fail bugs fixed). tests copied single file submitted API team bugs. tests exist test files unique (specific API bugs won’t needed ’re fixed). possible tech note new package ready mentions shown updated Top Assignees vignette, occasions now multiple API calls needed retrieve data single API call original version API R package. workflow (R-CMD-check.yaml) updated get rid deprecated warnings Added vignettes/build_some.R half render one vignettes development Added bootstrap: 5 _pkgdown.yml search box display (Maëlle’s PR) R package handles throttling, new version API now imposes data-raw/fieldsdf.R working ! hard-coding can removed bugs fixed. may need retain hard-coding, see comments data-raw/fieldsdf.R renamed test-arg-validation.R test-validate-args.R code coverage match Possible Package Improvements version number bumped 1.0.0 since breaking API changes (singular endpoints addition API key). validate-args.R version specific code may need modifying. draft release . Result set size seems unbounded now. warn query return 100,000 rows all_pages = TRUE? maybe add max_rows search_pv()? get_fields() search_pv() throw specialized error plural endpoint passed Add issue template warns users share API key Add contributing.md something explains build everything, something like Findings/Contributor 101 Navigation vignettes better, understanding--api isn’t link navigation yet, neither possible tech note new vignette new implementation paging sure monster comment search_pv.R trying explain new way paging. Possibly just say see new api paging vignette? Sign coveralls add code coverage badge? Currently requests set retried 19 times httr2::req_retry(max_tries = 20) reasonable number? 429 errors can occur user runs single program time, like half rendering devtools::test() running running anything locally action running repo push. Errors occur retries recursive, whether intended ! Can throttled test detect output stdout etc? used expect_message “API’s requests per minute limit reached.” Now “Waiting 45s retry backoff” appears doesn’t satisfy expect_message(). Currently ’s using system.time() assert 50 transactions took 60 seconds, implying throttlilng occurred.","code":"print(unique(fieldsdf[grep(\"/\", fieldsdf$endpoint), \"endpoint\"]), row.names = FALSE) ## [1] \"patent/attorney\"                \"patent/foreign_citation\"        ## [3] \"patent/otherreference\"          \"patent/rel_app_text\"            ## [5] \"patent/us_application_citation\" \"patent/us_patent_citation\"      ## [7] \"publication/rel_app_text\" httr2::last_request() httr2::last_response() httr2::last_response() |> httr2::resp_body_json()"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/state-of-the-api.html","id":"worth-monitoring","dir":"Articles","previous_headings":"","what":"Worth Monitoring","title":"State of the API","text":"bergant/rapiclient new maintainer ’s favor supporting OpenAPI v3 though thinks warrant new package. R version fieldsdf creator working ! uses rapiclient expecting read Swagger/OpenAPI v2 object (patentsview object OpenAPI v3). throws warning seems work otherwise.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/state-of-the-api.html","id":"findingscontributor-101","dir":"Articles","previous_headings":"","what":"Findings/Contributor 101","title":"State of the API","text":"Helpful info ’ve forked https://github.com/ropensci/patentsview API related Updated versions new API unannounced part, maybe three week release cycle, often Saturdays. head requests time time API’s OpenAPI object detect Last-Modified changes. changes, back data-raw/fieldsdf.csv, run data-raw/fieldsdf.R compare backed fieldsdf.csv new one see anything changed. change, ’ll local build run tests see happens push changes keep tests passing. Quarterly ’ll update https://patentsview.org/release-notes Report API suggestions/bugs etc Community -> Support using nav patentsview.org Now endpoints documented single page. query language also page. Originally separate page query language endpoint page. patentsview forum isn’t terribly active ’s worth keeping eye https://patentsview.org/forum Locally Build install local code devtools::install('.') rscript data-raw/fieldsdf.R run fieldsdf creator locally. parses Patentsview OpenAPI object produce fieldsdf.csv fieldsdf.rda Local Testing devtools::test() run tests tests/testthat/ devtools::test(filter=“utils”) just run just test-utils.R note add new test methods, must start skip_on_cran() builds fail r-universe (see Optional ) eventually CRAN. Half building vignettes locally - see vignettes/README.md need phantomjs path windows least see comments vignettes/build_some.R pkgdown locally pkgdown::build_articles() see local changes half-rendered vignettes may want run individual methods pkgdown::build_site() wrapper init_site() build_home() build_reference() build_articles() build_tutorials() build_news() build_redirects() build reference pages locally make changes method documentation, run see README.Rmd changes locally  Run code coverage locally whole package: devtools::test_coverage() devtools::test_coverage(function_exclusions = \"\\\\.onLoad\") individual file: devtools::test_coverage_active_file(file = \"R/print.R\") ’d need covr installed Remotely pkgdown remotely can set github pages repo display vignettes man pages, e.g. https://github.com/mustberuss/patentsview Remote Testing can put API key repo Repository secret tests run push changes. E.g., PATENTSVIEW_API_KEY set https://github.com/mustberuss/patentsview/settings/secrets/actions (though settings aren’t publicly viewable) push make sure following Tidyverse style guide. plugins keep stylish styler::style_pkg(\".\", dry = \"fail\") styler::style_file('path/file') necessary use plugin etc make sure examples still run devtools::run_examples(run_dontrun = TRUE) check spelling using devtools::spell_check(pkg = \".\", vignettes = TRUE, use_wordlist = TRUE) Locally unchecked inst/WORDLIST additional words allow (one word per line) see https://devtools.r-lib.org/reference/spell_check.html Optional can set r-universe creating special github repo, explained . E.g., https://github.com/mustberuss/mustberuss.r-universe.dev https://github.com/mustberuss/mustberuss.r-universe.dev/blob/master/packages.json See article newer repo naming convention Notes default, patentsview r-universe https://ropensci.r-universe.dev/patentsview Someone really smart write python library API! Questions: way set notifications r-universe build failures? miss skip_on_cran(), tests work repo (API key repo secret) build silently fail r-universe. Don’t ask know . don’t vignettes show r-universe? articles link grayed . Ah, build shows Build pkgdown site (ropensci ) skipped add row_limit something? ’d page way stop row_limit met. someone wanting 1000 rows necessarily rows, especially since isn’t 100,000 row limitation now. API’s now exposed search_pv() users paging. See new paging vignette","code":"devtools::document() pkgdown::build_reference() knitr::knit(\"README.Rmd\", \"README.md\") pkgdown::build_home()"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/understanding-the-api.html","id":"fields-shorthand","dir":"Articles","previous_headings":"","what":"Fields Shorthand","title":"Understanding the API","text":"notebook starts fairly fluffy things really get interesting really quickly. See “constructing query”, don’t remember seeing anywhere else: endpoints contain groups fields representing related entities connected one endpoint’s primary entity type; example, patent endpoint contains field “inventors”, contains information inventors associated given patent. fields related entities can requested API request’s fields parameter group using group name fields parameter, individually specifying required field “{entity_type}.{subfield}”. Mind blown, can, example, request nested application fields patent endpoint simply requesting “application” fields list. new version R package let users leverage “feature”. (Purists probably frown upon using , select * SQL. can helpful see exactly fields API can return, documentation lagging.) results used fields=get_fields(\"patent\", groups=c(\"application\")). difference case , ’s API deciding fields return get_fields() case, parsed API’s OpenAPI object building R package determine fields can requested. results different API’s actual return sync API’s OpenAPI object. see requests different results (used POSTs requests easier read since don’t need urlencoded):","code":"library(patentsview)  pat_res <- search_pv(qry_funs$eq(patent_id = \"10568228\"), fields=c(\"application\"), method=\"POST\") pat_res$data$patent$application #> [[1]] #>   application_id application_type filing_date series_code rule_47_flag #> 1      15/995745               15  2018-06-01          15        FALSE #>   filing_type #> 1          15 pat_res$request #> #### An HTTP request where: #>  #> Method: POST #> URL: https://search.patentsview.org/api/v1/patent/ app_fields <- get_fields(\"patent\", groups=c(\"application\")) app_fields #> [1] \"application.application_id\"   \"application.application_type\" #> [3] \"application.filing_date\"      \"application.filing_type\"      #> [5] \"application.rule_47_flag\"     \"application.series_code\"  pat_res <- search_pv(qry_funs$eq(patent_id = \"10568228\"), fields=app_fields, method=\"POST\") pat_res$data$patent$application #> [[1]] #>   application_id application_type filing_date series_code rule_47_flag #> 1      15/995745               15  2018-06-01          15        FALSE #>   filing_type #> 1          15  # the request here and the one above differ, but the results were the same! pat_res$request #> #### An HTTP request where: #>  #> Method: POST #> URL: https://search.patentsview.org/api/v1/patent/"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/understanding-the-api.html","id":"unexpected-results","dir":"Articles","previous_headings":"","what":"Unexpected Results","title":"Understanding the API","text":", wasn’t enough, non-obvious behavior appears second bullet point “Queries using related entity fields” header: applying multiple conditions related-entity fields, central entity record returned combination related entities satisfy conditions. example, use George Washington inventor. Humorously, modern inventors name! Abraham Lincoln also used inventor. Good ol’ Abe US president receive patent ’s early patentsview database modern Abraham Lincolns found inventors. demonstrate API’s -exactly-intuitive behavior, ’ll keep George inventor substitute Thomas Jefferson Abe, inventors going famous name, though aren’t nickels two dollar bills US. Now ’ll hit inventor endpoint similar query, jupyter notebook suggests. Now, actual_inventors’ inventor_ids hand, ’ll ask patent endpoint patents. results quite different first query returned. (patents names matching least one two famous forefathers. first query non-intuitively matched names first last name matches necessarily occur inventor.)","code":"library(dplyr)  patents_query <-    with_qfuns(     or(       and(         text_phrase(inventors.inventor_name_first = \"George\"),         text_phrase(inventors.inventor_name_last = \"Washington\")       ),       and(         text_phrase(inventors.inventor_name_first = \"Thomas\"),         text_phrase(inventors.inventor_name_last = \"Jefferson\")       )     )   )  patent_fields <-c(\"patent_id\", \"inventors.inventor_name_first\", \"inventors.inventor_name_last\") pat_res <- search_pv(patents_query, fields=patent_fields, endpoint=\"patent\") dl <- unnest_pv_data(pat_res$data)  # We got back all the inventors on the patents that met our search criteria.  We'll filter out # the inventors that didn't strictly meet our criteria (they came along for the ride with # the ones that met our criteria), we want the noted behavior to be clear.  display_inventors <-     dl$inventors %>%    filter(grepl(\"^(George|Thomas)\", inventor_name_first ) | grepl(\"^(Washington|Jefferson)\", inventor_name_last))  %>%    arrange(nchar(patent_id), patent_id)  # numeric sort on a string field  display_inventors #>    patent_id inventor_name_first inventor_name_last #> 1    4078607              Thomas          Jefferson #> 2    4104193              Thomas          Jefferson #> 3    5643452              George         Washington #> 4    5645778              George         Washington #> 5    5736046              George         Washington #> 6    5897817              George         Washington #> 7    5914971           George E.         Burke, Jr. #> 8    5914971           Rodney B.         Washington #> 9    6218441              George         Washington #> 10   6881337              George         Washington #> 11   6905071              Thomas           Amundsen #> 12   6905071              George              Kolis #> 13   6905071             Matthew          Jefferson #> 14   7144505              George         Washington #> 15   7598629           George E.         Burke, Jr. #> 16   7598629           Rodney B.         Washington #> 17   7971908              Thomas              Tilly #> 18   7971908           Thomas M.           DiMambro #> 19   7971908           Alfred A.          Jefferson #> 20   8347213           Thomas M.            Clifton #> 21   8347213          Bradley C.          Jefferson #> 22   8717367           Thomas M.            Clifton #> 23   8717367          Bradley C.          Jefferson #> 24  10180440          Stanley T.          Jefferson #> 25  10180440              Thomas                FAY #> 26  10374815           Thomas J.             Bonola #> 27  10374815             Lorri L          Jefferson #> 28  10568228      George Elliott         Washington #> 29  10664808                Joel         Washington #> 30  11032709           Thomas J.             Bonola #> 31  11032709             Lorri L          Jefferson inventors_query <-    with_qfuns(     or(       and(         text_phrase(inventor_name_first = \"George\"),         text_phrase(inventor_name_last = \"Washington\")       ),       and(         text_phrase(inventor_name_first = \"Thomas\"),         text_phrase(inventor_name_last = \"Jefferson\")       )     )   )  inventor_fields <- c(\"inventor_id\",\"inventor_name_first\",\"inventor_name_last\") inventor_res <- search_pv(inventors_query, fields=inventor_fields, endpoint=\"inventor\") dl2 <- unnest_pv_data(inventor_res$data)  actual_inventors <-    dl2$inventors %>%    arrange(inventor_name_last, inventor_name_first)  actual_inventors #>             inventor_id inventor_name_first inventor_name_last #> 1  fl:th_ln:jefferson-1              Thomas          Jefferson #> 2 fl:ge_ln:washington-4              George         Washington #> 3 fl:ge_ln:washington-5      George Elliott         Washington id_query <- qry_funs$eq(inventors.inventor_id=actual_inventors$inventor_id)  # We need to pass fields since we're sorting (sort field has to be passed as a field) # Without a sort we could rely on the default fields being returned if we liked  patent_fields <-c(\"patent_id\", \"inventors.inventor_name_first\", \"inventors.inventor_name_last\") pat_res <- search_pv(id_query, fields=patent_fields, sort=c(\"patent_id\" = \"asc\"))  dl <- unnest_pv_data(pat_res$data)  # Also, the API's sort on patent_id, a string field, puts 10568228 first at the time of  # this writing.  Would that be a bug or feature?  Below we'll apply our own sort dl$patents[[1]][[1]] #> [1] \"10568228\"  # we'll repeat the same filter we used on the first query's results display_inventors <-     dl$inventors %>%    filter(grepl(\"^(George|Thomas)\", inventor_name_first ) | grepl(\"^(Washington|Jefferson)\", inventor_name_last))  %>%    arrange(nchar(patent_id), patent_id)  # numeric sort on a string field   display_inventors #>    patent_id inventor_name_first inventor_name_last #> 1    4078607              Thomas          Jefferson #> 2    4104193              Thomas          Jefferson #> 3    5643452              George         Washington #> 4    5645778              George         Washington #> 5    5736046              George         Washington #> 6    5897817              George         Washington #> 7    6218441              George         Washington #> 8    6881337              George         Washington #> 9    7144505              George         Washington #> 10  10568228      George Elliott         Washington"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/understanding-the-api.html","id":"subtle-exceptions","dir":"Articles","previous_headings":"","what":"Subtle Exceptions","title":"Understanding the API","text":"’s directly mentioned, toward top notebook, publication/rel_app_text endpoint appears special_keys hash. entity rel_app_text_publications. ’s similar patent/rel_app_text endpoint whose entity rel_app_texts. Generally entity plural form singular endpoint, special_keys lists exceptions rule, code shows.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/understanding-the-api.html","id":"acknowledgment","dir":"Articles","previous_headings":"","what":"Acknowledgment","title":"Understanding the API","text":", credit goes Patentsview API team creating cited jupyter notebook. just portions R package form. repo didn’t stated license https://patentsview.org/contact says Users free use, share, adapt material purpose, subject standards Creative Commons Attribution 4.0 International License.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/writing-queries.html","id":"three-ways-to-write-the-same-query","dir":"Articles","previous_headings":"","what":"Three ways to write the same query","title":"Writing queries","text":"Let’s say want find patents published last 10 years word “dog” titles abstracts, whose assignees located either US Canada. three ways write query: Use string: Use list: Use patentsview domain specific language (DSL):","code":"query_v_1 <-   '{\"_and\":[           {\"_gte\":{\"patent_date\":\"2007-03-01\"}},           {\"_or\":[             {\"_contains\":{\"patent_title\":\"dog\"}},             {\"_text_all\":{\"patent_abstract\":\"dog\"}}           ]},           {\"_or\":[             {\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},             {\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}           ]}   ]}' query_v_2 <-    list(\"_and\" =         list(           list(\"_gte\" = list(patent_date = \"2007-03-01\")),           list(\"_or\" =                   list(                    list(\"_contains\" = list(patent_title = \"dog\")),                    list(\"_text_all\" = list(patent_abstract = \"dog\"))                    )                ),           list(\"_or\" =                   list(                    list(\"_text_phrase\" = list(inventors.inventor_country = \"US\")),                    list(\"_text_phrase\" = list(inventors.inventor_country = \"CA\"))                    )                )       )   ) library(patentsview)  query_v_3 <-    with_qfuns(     and(       gte(patent_date = \"2007-03-01\"),       or(         contains(patent_title = \"dog\"),         text_all(patent_abstract = \"dog\")       ),       or(         text_phrase(inventors.inventor_country = \"US\"),         text_phrase(inventors.inventor_country = \"CA\")       )     )   )"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/writing-queries.html","id":"why-use-the-dsl","dir":"Articles","previous_headings":"","what":"Why use the DSL?","title":"Writing queries","text":"can see three versions query shown equivalent: …ever want use method 3 methods 1 2? two main reasons:","code":"jsonlite::minify(query_v_1) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-03-01\"}},{\"_or\":[{\"_contains\":{\"patent_title\":\"dog\"}},{\"_text_all\":{\"patent_abstract\":\"dog\"}}]},{\"_or\":[{\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},{\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}]}]} jsonlite::toJSON(query_v_2, auto_unbox = TRUE) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-03-01\"}},{\"_or\":[{\"_contains\":{\"patent_title\":\"dog\"}},{\"_text_all\":{\"patent_abstract\":\"dog\"}}]},{\"_or\":[{\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},{\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}]}]} jsonlite::toJSON(query_v_3, auto_unbox = TRUE) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-03-01\"}},{\"_or\":[{\"_contains\":{\"patent_title\":\"dog\"}},{\"_text_all\":{\"patent_abstract\":\"dog\"}}]},{\"_or\":[{\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},{\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}]}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/writing-queries.html","id":"query-validation","dir":"Articles","previous_headings":"Why use the DSL?","what":"1. Query validation","title":"Writing queries","text":"search_pv() check query errors use methods 2 3. case method 1, rely API’s error messages guidance query invalid. search_pv() checks queries following: fields included query available endpoint used. example, make sure assignees.assignee_country can used query argument sent query patent endpoint. fields query compatible comparison operators used. example, confirm text_all operator used field whose type “full text” (patent_title ). supplied correct value type field (e.g., patent_date character, integer).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/writing-queries.html","id":"concise-easy-to-use-syntax-for-complex-queries","dir":"Articles","previous_headings":"Why use the DSL?","what":"2. Concise, easy to use syntax for complex queries","title":"Writing queries","text":"Methods 1 3 shorter method 2, making quicker. ’s also lot easier get JSON syntax correct using method 3 compared method 1, don’t write JSON using DSL…important API fairly picky query syntax, ’s trivial get correct. example, API throw error use box JSON absolutely necessary, even query still valid JSON (e.g., query = {\"_gte\":{\"patent_date\":[\"2007-03-01\"]}} throw error). Compared method 1, method 3 correctly “” together values put vector. example, query shown , vector two values given assignees.assignee_country (c(\"US\", \"CA\")). safely converted single “equals” statement third element query (eq(assignees.assignee_country = c(\"US\", \"CA\"))) two separate equals statements got ’d together.1","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/writing-queries.html","id":"basics-of-the-language","dir":"Articles","previous_headings":"","what":"Basics of the language","title":"Writing queries","text":"functions make DSL found qry_funs list (e.g., qry_funs$eq()). can evaluate code context list using function with_qfuns() (see ?with_qfuns() example demonstrates with_qfuns() can save typing). four types functions qry_funs: Comparison operator functions (eq, neq, gt, gte, lt, lte, begins, contains, text_all, text_any, text_phrase). functions used compare field value. example, using “less equal ” function (lte), can filter patents published date (e.g., query = qry_funs$lte(patent_date = \"2001-01-05\")). See “comparison operators” section API’s query language page description 11 comparison operators. One important thing keep mind certain comparison operators work certain data types. example, can’t use begins function patent_abstract patent_abstract data type “full text” begins works fields data type “string.” Array functions (). can use functions logically combine calls comparison operators. example, can require patent date less equal 2001-01-05 inventor’s last name “Ihaka” (query = with_qfuns((lte(patent_date = \"2001-01-05\"), eq(inventor_name_last = \"Ihaka\")))). function (). function negates comparison. example, search patents don’t word “hi” titles like : qry_funs$(qry_funs$text_phrase(patent_title = \"hi\")). Convenience function (in_range). function makes easy query date integer range.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/articles/writing-queries.html","id":"query-examples","dir":"Articles","previous_headings":"","what":"Query examples","title":"Writing queries","text":"Query assignee endpoint disambiguated assignees 10 fewer patents: remaining examples queries intended patent endpoint. Patents assigned “CPC class” G12 (physics instruments): Patents : inventor listed whose first name “kevin” abstract containing either phrase “dog bark” “cat meow” abstract doesn’t phrase “dog chain” : Patents : inventor listed whose last name “Smith” “cotton gin” title inventor listed whose last name “Turner” “COBOL” title","code":"qry_funs$lte(assignee_num_inventors = 10) #> {\"_lte\":{\"assignee_num_inventors\":10}} qry_funs$eq(cpc_current.cpc_class_id = \"G12\") #> {\"_eq\":{\"cpc_current.cpc_class_id\":\"G12\"}} with_qfuns(   and(     text_any(inventors.inventor_name_first = \"kevin\"),  # inventor names are now full text     text_phrase(patent_abstract = c(\"dog bark\", \"cat meow\")),     not(       text_phrase(patent_abstract = c(\"dog chain\"))     )   ) ) #> {\"_and\":[{\"_text_any\":{\"inventors.inventor_name_first\":\"kevin\"}},{\"_or\":[{\"_text_phrase\":{\"patent_abstract\":\"dog bark\"}},{\"_text_phrase\":{\"patent_abstract\":\"cat meow\"}}]},{\"_not\":{\"_text_phrase\":{\"patent_abstract\":\"dog chain\"}}}]} with_qfuns(   or(     and(       eq(inventors.inventor_name_last = \"Smith\"),       contains(patent_title = \"cotton gin\")     ),     and(       eq(inventors.inventor_name_last = \"Turner\"),       contains(patent_title = \"COBOL\")     )   ) ) #> {\"_or\":[{\"_and\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Smith\"}},{\"_contains\":{\"patent_title\":\"cotton gin\"}}]},{\"_and\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Turner\"}},{\"_contains\":{\"patent_title\":\"COBOL\"}}]}]} qry_funs$in_range(\"patent_date\" = c(\"2000-01-01\", \"2000-01-31\")) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2000-01-01\"}},{\"_lte\":{\"patent_date\":\"2000-01-31\"}}]}  qry_funs$in_range(\"patent_year\" = c(1980, 1983)) #> {\"_and\":[{\"_gte\":{\"patent_year\":1980}},{\"_lte\":{\"patent_year\":1983}}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Christopher Baker. Author, maintainer.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Baker C (2024). patentsview: R Client 'PatentsView' API. R package version 0.3.0, https://mustberuss.github.io/patentsview/index.html.","code":"@Manual{,   title = {patentsview: An R Client to the 'PatentsView' API},   author = {Christopher Baker},   year = {2024},   note = {R package version 0.3.0},   url = {https://mustberuss.github.io/patentsview/index.html}, }"},{"path":"https://mustberuss.github.io/patentsview/index.html/index.html","id":"patentsview-","dir":"","previous_headings":"","what":"An R Client to the PatentsView API","title":"An R Client to the PatentsView API","text":"R client PatentsView API, recently renamed PatentSearch API","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An R Client to the PatentsView API","text":"can get stable version original version API CRAN: development version GitHub (Currently broken): R package new version API r-universe: R package new version API GitHub:","code":"install.packages(\"patentsview\") if (!\"devtools\" %in% rownames(installed.packages())) {   install.packages(\"devtools\") }  devtools::install_github(\"ropensci/patentsview\") install.packages(\"patentsview\", repos = c(\"https://mustberuss.r-universe.dev\")) if (!\"devtools\" %in% rownames(installed.packages())) {   install.packages(\"devtools\") }  devtools::install_github(\"mustberuss/patentsview@api-redesign\")"},{"path":"https://mustberuss.github.io/patentsview/index.html/index.html","id":"important-api-change","dir":"","previous_headings":"","what":"Important API Change","title":"An R Client to the PatentsView API","text":"new version API requires API key, requests blocked. API key can obtained . updated R package look environmental variable PATENTSVIEW_API_KEY set value key. windows See page change. navigation get updated vignettes reference pages.","code":"set PATENTSVIEW_API_KEY=my_keys_value_without quotes"},{"path":"https://mustberuss.github.io/patentsview/index.html/index.html","id":"basic-usage","dir":"","previous_headings":"","what":"Basic usage","title":"An R Client to the PatentsView API","text":"PatentsView API provides interface disambiguated version USPTO. patentsview R package provides one main function, search_pv(), make easy interact API:","code":"library(patentsview)  search_pv(query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}') #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10000000\" ... #>   ..$ patent_title: chr [1:1000] \"Coherent LADAR using intra-pixel quadrature\".. #>   ..$ patent_date : chr [1:1000] \"2018-06-19\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 5,362,291"},{"path":"https://mustberuss.github.io/patentsview/index.html/index.html","id":"learning-more","dir":"","previous_headings":"","what":"Learning more","title":"An R Client to the PatentsView API","text":"Head package’s webpage info, including: getting started vignette first-time users. -depth tutorial writing queries list basic examples Two examples data applications (e.g., brief analysis top assignees field databases) package first introduced 2017 rOpenSci blog post used original version API. content, reworked use new version API, available . draft possible Tech Note new version API R package .","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/cast_pv_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast PatentsView data — cast_pv_data","title":"Cast PatentsView data — cast_pv_data","text":"cast data fields returned search_pv appropriate data types (e.g., date, numeric, etc.).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/cast_pv_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast PatentsView data — cast_pv_data","text":"","code":"cast_pv_data(data)"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/cast_pv_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast PatentsView data — cast_pv_data","text":"data data returned search_pv. first element three-element result object got back search_pv. list length 1, one data frame inside . See examples.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/cast_pv_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast PatentsView data — cast_pv_data","text":"type object passed cast_pv_data.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/cast_pv_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast PatentsView data — cast_pv_data","text":"","code":"if (FALSE) {  fields <- c(\"patent_date\", \"patent_title\", \"patent_year\") res <- search_pv(query = \"{\\\"patent_id\\\":\\\"5116621\\\"}\", fields = fields) cast_pv_data(data = res$data) }"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/fieldsdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Fields data frame — fieldsdf","title":"Fields data frame — fieldsdf","text":"data frame containing names retrievable fields endpoints. can find data API's online documentation endpoint well (e.g., patent endpoint field list table).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/fieldsdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fields data frame — fieldsdf","text":"","code":"fieldsdf"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/fieldsdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Fields data frame — fieldsdf","text":"data frame following columns: endpoint endpoint field record field complete name field, including parent group applicable data_type field's input data type group group field belongs common_name field name without parent group structure","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_endpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Get endpoints — get_endpoints","title":"Get endpoints — get_endpoints","text":"function reminds user possible PatentSearch API endpoints .  (Note API originally know PatentsView API.)","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_endpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get endpoints — get_endpoints","text":"","code":"get_endpoints()"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_endpoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get endpoints — get_endpoints","text":"character vector names endpoint.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"Get list of retrievable fields — get_fields","title":"Get list of retrievable fields — get_fields","text":"function returns vector fields can retrieve given API endpoint (.e., fields can pass fields argument search_pv). can limit fields cover certain entity group(s) well (recommended, given large number possible fields endpoint).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get list of retrievable fields — get_fields","text":"","code":"get_fields(endpoint, groups = NULL)"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get list of retrievable fields — get_fields","text":"endpoint API endpoint whose field list want get. See get_endpoints list 23 endpoints. groups character vector giving group(s) whose fields want returned. value NULL indicates want endpoint's fields (.e., filter field list based group membership). See Nested Fields listed online see groups can specify given endpoint (e.g., patents endpoint table), use fieldsdf table (e.g., unique(fieldsdf[fieldsdf$endpoint == \"patent\", \"group\"])). empty string can also specified return top level (non-nested) fields endpoint.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_fields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get list of retrievable fields — get_fields","text":"character vector field names.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_fields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get list of retrievable fields — get_fields","text":"","code":"# Get all top level (non-nested) fields for the patent endpoint: fields <- get_fields(endpoint = \"patent\", groups = c(\"\"))  # ...Then pass to search_pv: if (FALSE) {  search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}',   fields = fields ) } # Get all patent and assignee-level fields for the patent endpoint: fields <- get_fields(endpoint = \"patent\", groups = c(\"assignees\", \"\"))  if (FALSE) { # ...Then pass to search_pv: search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}',   fields = fields ) }"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_ok_pk.html","id":null,"dir":"Reference","previous_headings":"","what":"Get OK primary key — get_ok_pk","title":"Get OK primary key — get_ok_pk","text":"function suggests value use pk argument unnest_pv_data, based endpoint searched. return potential unique identifier given entity (.e., given endpoint). example, return \"patent_id\" endpoint = \"patent\".","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_ok_pk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get OK primary key — get_ok_pk","text":"","code":"get_ok_pk(endpoint)"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_ok_pk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get OK primary key — get_ok_pk","text":"endpoint endpoint like know potential primary key .","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_ok_pk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get OK primary key — get_ok_pk","text":"name primary key (pk) pass unnest_pv_data.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/get_ok_pk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get OK primary key — get_ok_pk","text":"","code":"get_ok_pk(endpoint = \"inventor\") # Returns \"inventor_id\" #> [1] \"inventor_id\" get_ok_pk(endpoint = \"cpc_group\") # Returns \"cpc_group_id\" #> [1] \"cpc_group_id\""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/patentsview-package.html","id":null,"dir":"Reference","previous_headings":"","what":"patentsview: An R Client to the 'PatentsView' API — patentsview-package","title":"patentsview: An R Client to the 'PatentsView' API — patentsview-package","text":"Provides functions simplify 'PatentsView' API (https://patentsview.org/apis/purpose) query language, send GET POST requests API's twelve endpoints, parse data comes back.","code":""},{"path":[]},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/patentsview-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"patentsview: An R Client to the 'PatentsView' API — patentsview-package","text":"Maintainer: Christopher Baker chriscrewbaker@gmail.com","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/qry_funs.html","id":null,"dir":"Reference","previous_headings":"","what":"List of query functions — qry_funs","title":"List of query functions — qry_funs","text":"list functions make easy write PatentsView queries. See details section list 15 functions, well writing queries vignette details.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/qry_funs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List of query functions — qry_funs","text":"","code":"qry_funs"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/qry_funs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"List of query functions — qry_funs","text":"object class list length 15.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/qry_funs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List of query functions — qry_funs","text":"object class pv_query. basically just simple list print method attached .","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/qry_funs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List of query functions — qry_funs","text":"1. Comparison operator functions 6 comparison operator functions work fields type integer, float, date, string: eq - Equal neq - equal gt - Greater gte - Greater equal lt - Less lte - Less equal 2 comparison operator functions work fields type string: begins - string begins value string contains - string contains value string 3 comparison operator functions work fields type fulltext: text_all - text contains words value string text_any - text contains words value string text_phrase - text contains exact phrase value string 2. Array functions 2 array functions: - members array must true - one member array must true 3. Negation function 1 negation function: - comparison true 4. Convenience function 1 convenience function: in_range - Builds <= x <= b query","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/qry_funs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List of query functions — qry_funs","text":"","code":"qry_funs$eq(patent_date = \"2001-01-01\") #> {\"_eq\":{\"patent_date\":\"2001-01-01\"}}  qry_funs$not(qry_funs$eq(patent_date = \"2001-01-01\")) #> {\"_not\":{\"_eq\":{\"patent_date\":\"2001-01-01\"}}}  qry_funs$in_range(patent_year = c(2010, 2021)) #> {\"_and\":[{\"_gte\":{\"patent_year\":2010}},{\"_lte\":{\"patent_year\":2021}}]}  qry_funs$in_range(patent_date = c(\"1976-01-01\", \"1983-02-28\")) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1983-02-28\"}}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/retrieve_linked_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve Linked Data — retrieve_linked_data","title":"Retrieve Linked Data — retrieve_linked_data","text":"endpoints now return HATEOAS style links get data. E.g., patent endpoint may return link : \"https://search.patentsview.org/api/v1/inventor/fl:th_ln:jefferson-1/\"","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/retrieve_linked_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve Linked Data — retrieve_linked_data","text":"","code":"retrieve_linked_data(   url,   encoded_url = FALSE,   api_key = Sys.getenv(\"PATENTSVIEW_API_KEY\"),   ... )"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/retrieve_linked_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve Linked Data — retrieve_linked_data","text":"url link returned API previous call, example documentation Request URL API's Swagger UI page. encoded_url boolean indicate whether url URL encoded, defaults FALSE. Set TRUE Request URLs Swagger UI. api_key API key, defaults Sys.getenv(\"PATENTSVIEW_API_KEY\"). Request key . ... Curl options passed along httr2's req_options function.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/retrieve_linked_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve Linked Data — retrieve_linked_data","text":"list following three elements: data list one element - named data frame containing data returned server. row data frame corresponds single value primary entity. example, search assignee endpoint, data frame assignee-level, row corresponds single assignee. Fields assignee-level returned list columns. query_results Entity counts across pages output (just page returned ). request Details GET HTTP request sent server.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/retrieve_linked_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve Linked Data — retrieve_linked_data","text":"","code":"if (FALSE) {  retrieve_linked_data(   \"https://search.patentsview.org/api/v1/cpc_group/G01S7:4811/\" )  retrieve_linked_data(   'https://search.patentsview.org/api/v1/patent/?q={\"_text_any\":{\"patent_title\":\"COBOL cotton gin\"}}&s=[{\"patent_id\": \"asc\" }]&o={\"size\":50}&f=[\"inventors.inventor_name_last\",\"patent_id\",\"patent_date\",\"patent_title\"]' )  retrieve_linked_data(   \"https://search.patentsview.org/api/v1/patent/?q=%7B%22patent_date%22%3A%221976-01-06%22%7D\",   encoded_url = TRUE ) }"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/search_pv.html","id":null,"dir":"Reference","previous_headings":"","what":"Search PatentsView — search_pv","title":"Search PatentsView — search_pv","text":"function makes HTTP request PatentsView API data matching user's query.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/search_pv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search PatentsView — search_pv","text":"","code":"search_pv(   query,   fields = NULL,   endpoint = \"patent\",   subent_cnts = FALSE,   mtchd_subent_only = lifecycle::deprecated(),   page = lifecycle::deprecated(),   per_page = lifecycle::deprecated(),   size = 1000,   after = NULL,   all_pages = FALSE,   sort = NULL,   method = \"GET\",   error_browser = NULL,   api_key = Sys.getenv(\"PATENTSVIEW_API_KEY\"),   ... )"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/search_pv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search PatentsView — search_pv","text":"query query API use filter records. query can come one following forms: character string valid JSON.  E.g., '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}' list converted JSON search_pv.  E.g., list(\"_gte\" = list(\"patent_date\" = \"2007-01-04\")) object class pv_query, create calling one functions found qry_funs list...See writing queries vignette details. E.g., qry_funs$gte(patent_date = \"2007-01-04\") fields character vector fields want returned . value NULL indicates API return default fields endpoint. Acceptable fields given endpoint can found API's online documentation (e.g., check field list patents endpoint) viewing fieldsdf data frame (View(fieldsdf)). can also use get_fields list fields available given endpoint. Nested fields can fully qualified, e.g., \"application.filing_date\" group name can used retrieve nested fields, E.g. \"application\". latter similar passing get_fields(\"patent\", group = \"application\") except API decides fields return. endpoint web service resource wish search. Use get_endpoints() list available endpoints. subent_cnts always FALSE new version API total counts unique subentities longer available. mtchd_subent_only always FALSE new version API non-matched subentities always returned. page new version API use page parameter paging, uses . per_page API now uses size size number records returned per page. value can high 1,000 (e.g., size = 1000). Exposes API's paging parameter users want implement custom paging. set all_pages = TRUE R package manipulates users automatically. all_pages want download possible pages output? all_pages = TRUE, value size ignored. sort named character vector name indicates field sort value indicates direction sorting (direction either \"asc\" \"desc\"). example, sort = c(\"patent_id\" =  \"asc\") sort = c(\"patent_id\" = \"asc\", \"patent_date\" =  \"desc\"). sort = NULL (default) means sort results. must include fields wish sort fields. method HTTP method want use send request. Possible values include \"GET\" \"POST\". Use POST method query long (say, 2,000 characters length). error_browser  api_key API key, defaults Sys.getenv(\"PATENTSVIEW_API_KEY\"). Request key . ... Curl options passed along httr2's req_options GETs POSTs.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/search_pv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search PatentsView — search_pv","text":"list following three elements: data list one element - named data frame containing data returned server. row data frame corresponds single value primary entity. example, search assignee endpoint, data frame assignee-level, row corresponds single assignee. Fields assignee-level returned list columns. query_results Entity counts across pages output (just page returned ). request Details HTTP request sent server. set all_pages = TRUE, get sample request. words, given multiple requests multiple calls made server (one page results).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/search_pv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search PatentsView — search_pv","text":"","code":"if (FALSE) {  search_pv(query = '{\"_gt\":{\"patent_year\":2010}}')  search_pv(   query = qry_funs$gt(patent_year = 2010),   fields = get_fields(\"patent\", c(\"\", \"assignees\")) )  search_pv(   query = qry_funs$gt(patent_year = 2010),   method = \"POST\",   fields = \"patent_id\",   sort = c(\"patent_id\" = \"asc\") )  search_pv(   query = qry_funs$eq(inventor_name_last = \"Crew\"),   endpoint = \"inventor\",   all_pages = TRUE )  search_pv(   query = qry_funs$contains(assignee_individual_name_last = \"Smith\"),   endpoint = \"assignee\" )  search_pv(   query = qry_funs$contains(inventors.inventor_name_last = \"Smith\"),   endpoint = \"patent\",   timeout = 40 )  search_pv(   query = qry_funs$eq(patent_id = \"11530080\"),   fields = \"application\" ) }"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/unnest_pv_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest PatentsView data — unnest_pv_data","title":"Unnest PatentsView data — unnest_pv_data","text":"function converts single data frame subentity-level list columns multiple data frames, one entity/subentity. multiple data frames can merged together using primary key variable specified user (see relational data chapter \"R Data Science\" -depth introduction joining tabular data).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/unnest_pv_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest PatentsView data — unnest_pv_data","text":"","code":"unnest_pv_data(data, pk = get_ok_pk(names(data)))"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/unnest_pv_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest PatentsView data — unnest_pv_data","text":"data data returned search_pv. first element three-element result object got back search_pv. list length 1, one data frame inside . See examples. pk column/field name link data frames together. unique identifier primary entity. example, used patent endpoint call search_pv, specify pk = \"patent_id\". identifier included fields vector called search_pv. can use get_ok_pk suggest potential primary key data.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/unnest_pv_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest PatentsView data — unnest_pv_data","text":"list multiple data frames, one entity/subentity. data frame pk column , can link tables together needed.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/unnest_pv_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest PatentsView data — unnest_pv_data","text":"","code":"if (FALSE) {  fields <- c(\"patent_id\", \"patent_title\", \"inventors.inventor_city\", \"inventors.inventor_country\") res <- search_pv(query = '{\"_gte\":{\"patent_year\":2015}}', fields = fields) unnest_pv_data(data = res$data, pk = \"patent_id\") }"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/with_qfuns.html","id":null,"dir":"Reference","previous_headings":"","what":"With qry_funs — with_qfuns","title":"With qry_funs — with_qfuns","text":"function evaluates whatever code pass environment qry_funs list. allows cut typing writing queries. want cut typing even , can try assigning qry_funs list global environment : list2env(qry_funs, envir = globalenv()).","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/with_qfuns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"With qry_funs — with_qfuns","text":"","code":"with_qfuns(code, envir = parent.frame())"},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/with_qfuns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"With qry_funs — with_qfuns","text":"code Code evaluate. See example. envir R look objects present code present qry_funs.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/with_qfuns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"With qry_funs — with_qfuns","text":"result code - .e., query.","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/reference/with_qfuns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"With qry_funs — with_qfuns","text":"","code":"qry_funs$and(   qry_funs$gte(patent_date = \"2007-01-01\"),   qry_funs$text_phrase(patent_abstract = c(\"computer program\")),   qry_funs$or(     qry_funs$eq(inventors.inventor_name_last = \"Ihaka\"),     qry_funs$eq(inventors.inventor_name_last = \"Chris\")   ) ) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-01-01\"}},{\"_text_phrase\":{\"patent_abstract\":\"computer program\"}},{\"_or\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Ihaka\"}},{\"_eq\":{\"inventors.inventor_name_last\":\"Chris\"}}]}]}  # ...With it, this becomes: with_qfuns(   and(     gte(patent_date = \"2007-01-01\"),     text_phrase(patent_abstract = c(\"computer program\")),     or(       eq(inventors.inventor_name_last = \"Ihaka\"),       eq(inventors.inventor_name_last = \"Chris\")     )   ) ) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-01-01\"}},{\"_text_phrase\":{\"patent_abstract\":\"computer program\"}},{\"_or\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Ihaka\"}},{\"_eq\":{\"inventors.inventor_name_last\":\"Chris\"}}]}]}"},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"patentsview-030-2021-09-03","dir":"Changelog","previous_headings":"","what":"patentsview 0.3.0 (2021-09-03)","title":"patentsview 0.3.0 (2021-09-03)","text":"CRAN release: 2021-09-25","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"misc-0-3-0","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.3.0 (2021-09-03)","text":"package now using new HTTPS endpoints (#17) list queryable fields updated with_qfuns() now find objects calling environment (@jcheng5, #20) Vignettes pre-computed (#23) issue fixed query strings weren’t properly URL-encoded (#24) Adhoc logic added handle API throttling","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"patentsview-022-2019-01-23","dir":"Changelog","previous_headings":"","what":"patentsview 0.2.2 (2019-01-23)","title":"patentsview 0.2.2 (2019-01-23)","text":"CRAN release: 2019-01-28","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"misc-0-2-2","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.2.2 (2019-01-23)","text":"Vignettes removed package CRAN builds don’t fail API ","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"patentsview-021-2018-03-05","dir":"Changelog","previous_headings":"","what":"patentsview 0.2.1 (2018-03-05)","title":"patentsview 0.2.1 (2018-03-05)","text":"CRAN release: 2018-03-14","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"misc-0-2-1","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.2.1 (2018-03-05)","text":"Examples hit API wrapped \\dontrun{} CRAN doesn’t request fixes package API ","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"patentsview-020-2018-02-08","dir":"Changelog","previous_headings":"","what":"patentsview 0.2.0 (2018-02-08)","title":"patentsview 0.2.0 (2018-02-08)","text":"CRAN release: 2018-02-09","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"patentsview 0.2.0 (2018-02-08)","text":"cast_pv_data() function added convert data types data returned search_pv() Additional fields added API (e.g., fields starting forprior_, examiner_)","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"misc-0-2-0","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.2.0 (2018-02-08)","text":"Additional error handler added locations endpoint (@mustberuss, #11) error_browser option deprecated","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"patentsview-010-2017-05-01","dir":"Changelog","previous_headings":"","what":"patentsview 0.1.0 (2017-05-01)","title":"patentsview 0.1.0 (2017-05-01)","text":"CRAN release: 2017-07-12","code":""},{"path":"https://mustberuss.github.io/patentsview/index.html/news/index.html","id":"new-functions-0-1-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"patentsview 0.1.0 (2017-05-01)","text":"search_pv added send requests PatentsView API qry_funs list added functions help users write queries get_fields get_endpoints added quickly get possible field names endpoints, respectively unnest_pv_data added unnest data frames returned data","code":""}]
