[{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"summary-of-pertinent-api-changes","dir":"Articles","previous_headings":"","what":"Summary of Pertinent API Changes","title":"API Changes","text":"Listed API changes matter users original version R package (used original version API). Toward bottom page additional API changes matter called API directly wanted write python library API. Probably importantly, current shutdown date original version API February 12, 2025, communicated August 2024 newsletter. API key now required. fields can queried now seemingly distinction using string full text operators now, new case sensitivity caveat though. Note now fields returned nested objects need fully qualified query parameter. Ex. search_pv(qry_funs$begins(cpc_current.cpc_group_id=\"A01B1/00\")) fields parameter, nested fields can fully qualified new API shorthand can used, group names can specified. group names used, group’s nested fields returned API. Ex. new version API R package accept fields=c(“assignees”) using patent endpoint nested assignees fields returned API. similar get_fields(\"patent\", groups=c(\"assignees\")) except ’s API deciding fields return (case, assignees fields). result set’s size seems unbounded now, can now retrieve 100,000 rows. ’d need careful setting all_pages = TRUE R package page entire result set retrieved million rows. Note previous version API total_hits capped 100,000 rows. Also note specify fields parameter. past API returned patent_id, patent_title patent_date now returned patent_id. Endpoint Changes nber_subcategories went away- endpoint original version API Endpoints now singular, ex. patent patents. returned entities still plural part. Now 27 endpoints, original 7   Comparison old new attributes can sent API o: (options) parameter via search_pv(). Note old parameters now deprecated.","code":"library(patentsview) search_pv('{\"patent_type\":\"utility\"}', all_pages = FALSE ) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10631087\" ... #>   ..$ patent_title: chr [1:1000] \"Method and device for voice operated contro\".. #>   ..$ patent_date : chr [1:1000] \"2020-04-21\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 8,123,346"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"additional-r-package-changes","dir":"Articles","previous_headings":"","what":"Additional R Package Changes","title":"API Changes","text":"changes also made R package, addition API changes outlined API Changes R package changed internally using httr httr2. affects users passed additional arguments (…) search_pv(). Previously passed config = httr::timeout(40) ’d now pass timeout = 40 (name-value pairs valid curl options, found curl::curl_options() see req_options) Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request. Also fun seeing raw API response. R package sets parameter changes sort sent API, viewing last_request() calling search_pv all_pages = TRUE might ’d expect. . HATEOAS links can retrieved using retrieve_linked_data() custom paging involving patent_id, value needs padded zeroes, see pad_patent_id() ropensci blog post announced original version R package reworked use new version R package API","code":"httr2::last_request() httr2::last_response() httr2::last_response() |> httr2::resp_body_json()"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"swagger-ui-page","dir":"Articles","previous_headings":"","what":"Swagger UI Page","title":"API Changes","text":"Patentsview API team provided Swagger UI page new version API https://search.patentsview.org/swagger-ui/. cool ? Think online version Postman already loaded API’s endpoints returns. field listed 200 response sections requested fields parameter field supposed queryable (usable query parameter). Swagger UI page can used make requests, API key enter authorization screen. Swagger UI definition https://search.patentsview.org/static/openapi.json can imported Postman give nicely loaded collection new version API. ’ll just need set global variable PVIEW_KEY set authorization’s value {{PVIEW_KEY}} API key.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"other-api-changes","dir":"Articles","previous_headings":"","what":"Other API Changes","title":"API Changes","text":"API changes matter want call API directly want write python library API etc. maybe ’re receiving end PR need know API’s changes. options parameters went away: matched_subentities_only, subent_cnts, per_page page (paging now uses instead page size instead per_page) Now API’s response always JSON. original version API ‘format’ parameter defaulted json set xml. original R package expose parameter script won’t know difference (unless calling API directly). Changes updated R package handles users: API now throttles requests. R package retries throttled requests. API’s paging completely different, users, all_pages=TRUE still works (however, note possibly unbounded result set size mentioned ). API change says POST requests need send JSON data (instead string representation JSON). Content-Type: application/json header added. subdomain API changed https://api.patentsview.org/ https://search.patentsview.org paths endpoints changed. order fields returned API changed Note now total_hits comes back endpoints, previously endpoint specific count, like total_patent_count. , handled R package. way total_hits comes back R package remains unchanged.","code":"# Response body now   {     \"error\": false,     \"count\": 1,     \"total_hits\": 1,     \"patent\": [...]   }    # Original response    {     \"patents\": [...],     \"count\": 1,     \"total_patent_count\": 1   } result <- search_pv('{\"patent_id\": \"11530080\"}')    print (result$query_results$total_hits) #> [1] 1"},{"path":[]},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"an-api-key-is-required","dir":"Articles","previous_headings":"Details of the API changes","what":"An API Key is required","title":"API Changes","text":"Perhaps important change, without API key queries rejected. Request API key using link: https://patentsview-support.atlassian.net/servicedesk/customer/portals one, ’ll need set environmental variable PATENTSVIEW_API_KEY value API key R package use. user’s API key needs sent requests","code":"api_key = Sys.getenv(\"PATENTSVIEW_API_KEY\") httr::add_headers(\"X-Api-Key\" = api_key)"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"endpoints","dir":"Articles","previous_headings":"Details of the API changes","what":"Endpoints","title":"API Changes","text":"Now 27 endpoints, original 7, returns smaller, specific data structure pertinent endpoint. example, previously inventor endpoint return assignee information, longer . exception patent endpoint. now can return assignees, inventors, cpc_current along patent specific fields. Note new endpoints nested patent/ one publication/ /api/v1/g_brf_sum_text/ /api/v1/g_claim/ /api/v1/g_detail_desc_text/ /api/v1/g_draw_desc_text/ /api/v1/pg_brf_sum_text/ /api/v1/pg_claim/ /api/v1/pg_detail_desc_text/ /api/v1/pg_draw_desc_text/ /api/v1/ipc/ /api/v1/uspc_subclass/ /api/v1/patent/attorney/ /api/v1/patent/foreign_citation/ /api/v1/patent/otherreference/ (currently working) /api/v1/patent/rel_app_text/ /api/v1/patent/us_application_citation/ /api/v1/patent/us_patent_citation/ /api/v1/publication/rel_app_text/ /api/v1/publications/ /api/v1/wipo/ /api/v1/assignee/ /api/v1/inventor/ /api/v1/location/ /api/v1/patent/ /api/v1/uspc_mainclass/ /api/v1/cpc_class/ /api/v1/cpc_subclass/ /api/v1/cpc_group/ nber_subcategory endpoint seems gone now.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"things-to-note","dir":"Articles","previous_headings":"Details of the API changes > Endpoints","what":"Things to note","title":"API Changes","text":"Currently endpoints return attributes listed API’s OpenAPI object. throw 500 errors requested1 (see test-api-bugs.R) two rel_app_text endpoints, one patent/ one publication/ return entities named rel_app_texts slightly different, patent_id former document_number latter. field related_text. endpoints now return HATEOAS links fields went away, like rawinventor_first_name rawinventor_last_name, new names, significantly, patent_number now patent_id. Requesting patent_number result error thrown. Note also CPC related fields new names, see next section. Swagger UI page 2024-10-06 API release, four endpoints listed “Patent Text” link showed far back data went https://search.patentsview.org/docs/docs/Search%20API/TextEndpointStatus Now eight endpoints. still four grant endpoints (g_ prepended names originally released) listed “Patent Text” now four pre-grant (pg_) endpoints listed “Publication Text”. looks like TextEndpointStatus page isn’t updated, ’ll check one pair . patent_date isn’t available g_brf_sum_text ’ll ask patent endpoint smallest patent_id g_brf_sum_text. , time writing, endpoints appear data going back 2023.","code":"qry <- qry_funs$ne(patent_id = \"\") sort <- c(\"patent_id\" = \"asc\") grant <- search_pv(qry, sort = sort, endpoint = \"g_brf_sum_text\", size = 1)  res <- search_pv(qry_funs$eq(patent_id = grant$data$g_brf_sum_texts$patent_id),    size = 1)  res$data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1 obs. of  3 variables: #>   ..$ patent_id   : chr \"11540434\" #>   ..$ patent_title: chr \"Curved cultivating disc with a straight cutting edge\".. #>   ..$ patent_date : chr \"2023-01-03\" qry <- qry_funs$gt(document_number = 0) sort <- c(\"document_number\" = \"asc\") pre_grant <- search_pv(qry, sort = sort, endpoint = \"pg_brf_sum_text\", size = 1)  pre_grant$data #> #### A list with a single data frame on pg_brf_sum_texts level: #>  #> List of 1 #>  $ pg_brf_sum_texts:'data.frame':    1 obs. of  2 variables: #>   ..$ document_number: num 20230000001 #>   ..$ summary_text   : chr \"TECHNICAL FIELD\\n\\nThe present disclosure relates\".."},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"hateoas-links","dir":"Articles","previous_headings":"Details of the API changes","what":"HATEOAS Links","title":"API Changes","text":"returned fields HATEOAS (Hypermedia Engine Application State) links retrieve information field. Slightly funky cpc_current’s cpc_group, returned patent endpoint. slash CPC turned colon. peculiarity two new convenience URLs (new endpoints accept single URL parameter) shouldn’t noticeable R package, unless trying infer USPC CPC values returned URLs, without actually calling back data. See retrieve_linked_data() ’ll call patent endpoint get CPC fields particular patent, returned fields, like cpc_group, HATEOAS links: Note going links browser result 403 Unauthorized, API key sent. Also note last two lines output, \"cpc_group_id: B65D71/0033\" (normal/expected) \"cpc_group: https://search.patentsview.org/api/v1/cpc_group/B65D71:0033/\" (slightly odd use colon). new method R package retrieve data HATEOAS links, just pass returned link R package retrieve data . Note calling cpc_group endpoint instead using HATEOAS link, ’d use slash instead colon. Slight weirdness/sleight--hand returned field name loses _id requested field","code":"query <- '{\"patent_id\": \"11530080\"}'   fields <- get_fields('patent', groups = 'cpc_current')   fields <- c(\"patent_id\", fields)   fields #>  [1] \"patent_id\"                   \"cpc_current.cpc_class\"       #>  [3] \"cpc_current.cpc_class_id\"    \"cpc_current.cpc_group\"       #>  [5] \"cpc_current.cpc_group_id\"    \"cpc_current.cpc_section\"     #>  [7] \"cpc_current.cpc_sequence\"    \"cpc_current.cpc_subclass\"    #>  [9] \"cpc_current.cpc_subclass_id\" \"cpc_current.cpc_type\"    result <- search_pv(query, fields=fields)    # As noted above, the CPC related fields aren't the same as they were in the   # original version of the API.  Also note that not all requested fields were   # returned and that _id-less, HATEOAS fields were returned.   unnested <- unnest_pv_data(result$data)   z <- lapply(names(unnested$cpc_current), function(x) {      print(paste0(x,': ', unnested$cpc_current[[x]][[1]]))   }) #> [1] \"patent_id: 11530080\" #> [1] \"cpc_sequence: 0\" #> [1] \"cpc_class: https://search.patentsview.org/api/v1/cpc_class/B65/\" #> [1] \"cpc_class_id: B65\" #> [1] \"cpc_subclass: https://search.patentsview.org/api/v1/cpc_subclass/B65D/\" #> [1] \"cpc_subclass_id: B65D\" #> [1] \"cpc_group: https://search.patentsview.org/api/v1/cpc_group/B65D71:0033/\" #> [1] \"cpc_group_id: B65D71/0033\" library(patentsview)  pv_data <- retrieve_linked_data(\"https://search.patentsview.org/api/v1/cpc_group/G01S7:4865/\") str(pv_data$data) #> List of 1 #>  $ cpc_groups:'data.frame':  1 obs. of  4 variables: #>   ..$ cpc_class      : chr \"https://search.patentsview.org/api/v1/cpc_class/G01/\" #>   ..$ cpc_subclass   : chr \"https://search.patentsview.org/api/v1/cpc_subclass/G01S/\" #>   ..$ cpc_group_id   : chr \"G01S7/4865\" #>   ..$ cpc_group_title: chr \"Details of systems according to groups G01S13/00, G01S15/00, G01S17/00-of systems according to group G01S17/00-\"| __truncated__ #>  - attr(*, \"class\")= chr [1:2] \"list\" \"pv_data_result\" result <- search_pv('{\"cpc_group_id\": \"A01B1/00\"}', endpoint = 'cpc_group') str(result$data) #> List of 1 #>  $ cpc_groups:'data.frame':  1 obs. of  4 variables: #>   ..$ cpc_class      : chr \"https://search.patentsview.org/api/v1/cpc_class/A01/\" #>   ..$ cpc_subclass   : chr \"https://search.patentsview.org/api/v1/cpc_subclass/A01B/\" #>   ..$ cpc_group_id   : chr \"A01B1/00\" #>   ..$ cpc_group_title: chr \"Hand tools\" #>  - attr(*, \"class\")= chr [1:2] \"list\" \"pv_data_result\" # We'll make a call to the patent endpoint to get inventor and assignee HATEOAS links   res <- search_pv('{\"patent_id\":\"10000000\"}',     fields = c(\"inventors.inventor_id\", \"assignees.assignee_id\")   )    # but note that the fields came back without the _id   print(res$data$patents$assignees[[1]]$assignee) # not $assignee_id as requested #> [1] \"https://search.patentsview.org/api/v1/assignee/b06175c5-768b-43af-bb65-1978370e6ce2/\"    print(res$data$patents$inventors[[1]]$inventor) # not $inventor_id as requested #> [1] \"https://search.patentsview.org/api/v1/inventor/fl:jo_ln:marron-5/\""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"api-throttling","dir":"Articles","previous_headings":"Details of the API changes","what":"API Throttling","title":"API Changes","text":"API now allow 45 requests per minute, making requests anger API. send back error code header indicating many seconds wait sending queries. R package take care . sleep required number seconds resubmitting query, seamlessly script.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"a-note-on-paging","dir":"Articles","previous_headings":"Details of the API changes","what":"A Note on Paging","title":"API Changes","text":"API team changed paging works important subtlety R package handles . screams python library python users don’t need worry throttling! ’s comment used search-pv.R tries explain danger. See new Result Set Paging vignette.","code":"# Here we ignore the user's sort and instead have the API sort by the primary   # key and sometimes primary and secondary keys for the requested endpoint.     # This simplifies the paging's after parameter.   # If we call the API with more than a primary sort, the after parameter would   # have to be a vector of all the sort fields' last values.   # After we've retrieved all the data we'll sort in R using the sort the user requested    # Doing this also protects users from needing to know the peculiarities   # of the API's paging.  Example: if a user requests a sort of   # [{\"patent_date\":\"asc\"}], on paging the after parameter may skip   # to the next issue date before having retured all the data for the last   # patent_date in the previous request - depending on where the   # patent_dates change relative to the API's page breaks.   # (Say the last patent in a retrieved page is the first patent   # of a particular date, we wouldn't want the after parameter to   # to begin the next page of data 'after' this date.)"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"string-and-full-text-operators","dir":"Articles","previous_headings":"Details of the API changes","what":"String and Full Text Operators","title":"API Changes","text":"Tip “Syntax” API’s documentation says: working text data fields, wherever possible, recommend using _text* operators _contains _begins operator. text operators treat fields full text data hence performant. “full text” fields identified API Endpoint specification value “text” data type. sure applies Patent Text Publication Text endpoints (listed top Swagger UI page) . Also sure make result set size differences2, total_hits, noting errors thrown API: hitting patent endpoint: hitting g_brf_sum_text endpoint:","code":"query1 <- '{\"_contains\":{\"patent_title\":\"dog\"}}' query2 <- '{\"_text_any\":{\"patent_title\":\"dog\"}}'  search_pv(query1) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10632101\" ... #>   ..$ patent_title: chr [1:1000] \"Methods and compositions for supporting end\".. #>   ..$ patent_date : chr [1:1000] \"2020-04-28\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,706  search_pv(query2) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"D792527\" ... #>   ..$ patent_title: chr [1:1000] \"Dog\" ... #>   ..$ patent_date : chr [1:1000] \"2017-07-18\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 2,115 query1 <- '{\"_contains\":{\"summary_text\":\"particular depth\"}}' query2 <- '{\"_text_phrase\":{\"summary_text\":\"particular depth\"}}'  search_pv(query1, endpoint=\"g_brf_sum_text\") #> $data #> #### A list with a single data frame on g_brf_sum_texts level: #>  #> List of 1 #>  $ g_brf_sum_texts: list() #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 0  search_pv(query2, endpoint=\"g_brf_sum_text\") #> $data #> #### A list with a single data frame on g_brf_sum_texts level: #>  #> List of 1 #>  $ g_brf_sum_texts:'data.frame': 68 obs. of  2 variables: #>   ..$ patent_id   : chr [1:68] \"12020165\" ... #>   ..$ summary_text: chr [1:68] \"TECHNICAL FIELD\\n\\nThe technical field genera\".. #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 68"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/api-changes.html","id":"case-sensitivity-caveat","dir":"Articles","previous_headings":"Details of the API changes","what":"Case Sensitivity Caveat","title":"API Changes","text":"original version API seemed case insensitive. sure bug feature3 new version API ’s something aware . ’ll see queries , two forms equal now seem case sensitive.","code":"result <- search_pv('{\"assignee_organization\": \"Johnson & Johnson International\"}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 1  result <- search_pv('{\"assignee_organization\": \"johnson & Johnson International\"}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 0  result <- search_pv('{\"_eq\":{\"assignee_organization\": \"Johnson & Johnson International\"}}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 1  result <- search_pv('{\"_eq\":{\"assignee_organization\": \"johnson & Johnson International\"}}', endpoint=\"assignee\") print (result$query_results$total_hits) #> [1] 0"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/citation-networks.html","id":"count-the-distinct-patent_id-and-cited_patent_id","dir":"Articles","previous_headings":"","what":"Count the distinct patent_id and cited_patent_id","title":"Citation networks","text":"11 PCA patents. patents cite 1066 patents cited 1056 patents. Let’s visualize citations among PCA patents. ’ll create visualization using visNetwork package, requires us create data frame nodes data frame edges.  looks like several patents cite patent number 6,499,026, perhaps indicating patent contains technology foundational field. However, hover nodes see several patents title. Clicking titles brings us full text Google Patents, confirms many PCA patents belong patent family.1 Let’s choose one patents family act family’s representative. reduce size subsequent network, hopefully retaining overall structure. 3 patents, probably possible visualize patents’ cited citing patents related one another. Let’s create list “relevant patents” (.e., 3 patents plus cited citing patents)2, get list cited patents (.e., patents cite). list cited patents allow us measure similar relevant patents one another. Now know patents 4855 relevant patents cite. allows us measure similarity 4855 patents seeing many cited references share common (method known bibliographic coupling). full_network contains similarity score (cosine_sim) patent pairs share least one cited reference common. means probably contains lot patent pairs one two cited references common, thus aren’t similar. Let’s try identify natural level cosine_sim filter subsequent network hairy.  appears smallish group patent pairs similar one another (cosine_sim > 0.8), makes tempting choose 0.8 cutoff point. However, patent pairs reference lists similar probably just patents patent family. Let’s choose 0.1 cutoff point instead, doesn’t appear many pairs point.3","code":"pat_title <- function(title, number) {   temp_title <- str_wrap(title)   i <- gsub(\"\\\\n\", \"<br>\", temp_title)   paste0('<a href=\"https://patents.google.com/patent/US', number, '\">', i, \"<\/a>\") }  edges <-   res_lst$us_patent_citations %>%     semi_join(x = ., y = ., by = c(\"citation_patent_id\" = \"patent_id\")) %>%     select(-citation_sequence) %>%  # discard citation_sequence that we don't need here     set_colnames(c(\"from\", \"to\"))  nodes <-   pat_lst$patents %>%     mutate(       id = patent_id,       label = patent_id,       title = pat_title(patent_title, patent_id)     )  visNetwork(   nodes = nodes, edges = edges, height = \"400px\", width = \"100%\",   main = \"Citations among patent citation analysis (PCA) patents\" ) %>%   visEdges(arrows = list(to = list(enabled = TRUE))) %>%   visIgraphLayout() p3 <- c(\"7797336\", \"9075849\", \"6499026\") res_lst2 <- lapply(res_lst, function(x) x[x$patent_id %in% p3, ]) rel_pats <-   res_lst$us_patent_citations %>%     rbind(setNames(res_lst$us_patent_citations, names(.))) %>%     select(-patent_id) %>%     rename(patent_id = citation_patent_id) %>%     bind_rows(data.frame(patent_id = p3)) %>%     distinct() %>%     filter(!is.na(patent_id))  # Look up which patents the relevant patents cite.  We need to use the # patent_citation endpoint now.  rel_pats_res <- search_pv(   query = list(patent_id = rel_pats$patent_id),   fields = c(\"citation_patent_id\", \"patent_id\"),   all_pages = TRUE, size = 1000, method = \"POST\", endpoint = \"patent/us_patent_citation\" )  rel_pats_lst <- unnest_pv_data(rel_pats_res$data, \"patent_id\") cited_pats <-   rel_pats_lst$us_patent_citations %>%   filter(!is.na(citation_patent_id))  full_network <-   cited_pats %>%     do({       .$ind <-         group_by(., patent_id) %>%         group_indices()       group_by(., patent_id) %>%         mutate(sqrt_num_cited = sqrt(n()))     }) %>%     inner_join(x = ., y = ., by = \"citation_patent_id\") %>%     filter(ind.x > ind.y) %>%     group_by(patent_id.x, patent_id.y) %>%     mutate(cosine_sim = n() / (sqrt_num_cited.x * sqrt_num_cited.y)) %>%     ungroup() %>%     select(matches(\"patent_id\\\\.|cosine_sim\")) %>%     distinct()  kable(head(full_network)) hist(   full_network$cosine_sim,   main = \"Similarity scores between patents relevant to PCA\",   xlab = \"Cosine similarity\", ylab = \"Number of patent pairs\" ) edges <-   full_network %>%     filter(cosine_sim >= .1) %>%     rename(from = patent_id.x, to = patent_id.y, value = cosine_sim) %>%     mutate(title = paste(\"Cosine similarity =\", as.character(round(value, 3))))  nodes <-   rel_pats_lst$us_patent_citations %>%     distinct(patent_id) %>%     rename(id = patent_id) %>%     mutate(       # the 3 patents of interest will be represented as blue nodes, all others       # will be yellow       color = ifelse(id %in% p3, \"#97C2FC\", \"#DDCC77\"),       label = id,       title = pat_title(id, id) # we don't get patent_title now (formerly first argument)     )  visNetwork(   nodes = nodes, edges = edges, height = \"700px\", width = \"100%\",   main = \"Network of patents relevant to PCA\" ) %>%   visEdges(color = list(color = \"#343434\")) %>%   visOptions(highlightNearest = list(enabled = TRUE, degree = 1)) %>%   visIgraphLayout()"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"required-api-key","dir":"Articles","previous_headings":"","what":"Required API Key","title":"Converting an Existing Script","text":"First ’ll need request API key set environmental variable PATENTSVIEW_API_KEY value API key. Ex. set PATENTSVIEW_API_KEY=My_api_key Without valid API key, calls rejected API.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"the-new-throttling-limit","dir":"Articles","previous_headings":"","what":"The New Throttling Limit","title":"Converting an Existing Script","text":"Another new thing throttling limit. new version API allows individual API key make 45 calls per minute. call exceeds limit rejected return number seconds wait calls allowed . Fortunately, R package handles ! script chugging along API return throttling response, R package sleep required number seconds automatically resending query! thing may notice, besides warning message, script pause throttled picks right back .","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"philosophical-change","dir":"Articles","previous_headings":"","what":"Philosophical Change","title":"Converting an Existing Script","text":"new version API’s endpoints less Swiss Army Knife-like , get nearly data field endpoint. Now substantially lighter responses generally focus data pertinent endpoint. words, can get USPC fields USPC endpoints patent endpoint. may mean ’ll make multiple calls different endpoints get data old version API used return single call. Take look top assignees application. blend together information separate calls used returned single call. may push dplyr skills limit.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"changed-field-names-and-types","dir":"Articles","previous_headings":"","what":"Changed Field Names and Types","title":"Converting an Existing Script","text":"fields requested original script used query may available new version’s endpoints. nber attributes longer available nber_subcategories endpoint removed. Also, attributes new names, like name_last nested inventor object returned patent endpoint. Now fields parameter specified “inventor.name_last” formerly “inventor_last_name” using patent endpoint. also demonstrates nested fields need fully qualified query parameter. Also note field’s types changed, meaning ’ll need use different operators within query. Ex. assignee.organization now full text field, formerly string. Checkout API documentation Swagger UI page see returned fields types. information available fieldsdf data frame harder read.","code":"library(patentsview)  # Before you could do a  qry_funs$contains(assignee_organization=\"Rice University\") #> {\"_contains\":{\"assignee_organization\":\"Rice University\"}}  # now you would have to do  qry_funs$text_phrase(assignees.assignee_organization=\"Rice University\") #> {\"_text_phrase\":{\"assignees.assignee_organization\":\"Rice University\"}}"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"singular-endpoints","dir":"Articles","previous_headings":"","what":"Singular Endpoints","title":"Converting an Existing Script","text":"endpoints now singular, ex: “patent” previously “patents”.","code":"get_endpoints() #>  [1] \"assignee\"                       \"cpc_class\"                      #>  [3] \"cpc_group\"                      \"cpc_subclass\"                   #>  [5] \"g_brf_sum_text\"                 \"g_claim\"                        #>  [7] \"g_detail_desc_text\"             \"g_draw_desc_text\"               #>  [9] \"inventor\"                       \"ipc\"                            #> [11] \"location\"                       \"patent\"                         #> [13] \"patent/attorney\"                \"patent/foreign_citation\"        #> [15] \"patent/other_reference\"         \"patent/rel_app_text\"            #> [17] \"patent/us_application_citation\" \"patent/us_patent_citation\"      #> [19] \"pg_brf_sum_text\"                \"pg_claim\"                       #> [21] \"pg_detail_desc_text\"            \"pg_draw_desc_text\"              #> [23] \"publication\"                    \"publication/rel_app_text\"       #> [25] \"uspc_mainclass\"                 \"uspc_subclass\"                  #> [27] \"wipo\""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"additions-to-the-r-package","dir":"Articles","previous_headings":"","what":"Additions to the R Package","title":"Converting an Existing Script","text":"endpoints now return HATEOAS links, make call back API retrieve additional data. new method retrieve_linked_data() just . lot .","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/converting-an-existing-script.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Converting an Existing Script","text":", attempt listing ’s changed . Request API key get going new version R package! two API versions coexist API team plans shutdown original version API February 2025.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/examples.html","id":"patent-endpoint","dir":"Articles","previous_headings":"","what":"Patent endpoint","title":"Examples","text":"patents cited 500 US patents? many distinct inventors represented highly-cited patents? geographically Microsoft inventors coming past years? assignees interest beer?","code":"library(patentsview)  search_pv(query = qry_funs$gt(patent_num_times_cited_by_us_patents = 500)) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10631857\" ... #>   ..$ patent_title: chr [1:1000] \"Loading unit for surgical instruments with \".. #>   ..$ patent_date : chr [1:1000] \"2020-04-28\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 13,575 search_pv(   query = qry_funs$gt(patent_num_times_cited_by_us_patents = 500),   fields = c(\"patent_id\", \"inventors.inventor_id\") ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id: chr [1:1000] \"10631857\" ... #>   ..$ inventors:List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 13,575 # Write the query query <- with_qfuns(   and(     gte(patent_date = \"2022-07-26\"), # Dates are in yyyy-mm-dd format     begins(assignees.assignee_organization = \"Microsoft\")   ) )  # Create a field list by getting the inventors fields- the primary key is needed # for unnest_pv_data() inv_fields <- get_fields(endpoint = \"patent\", groups=\"inventors\") inv_fields <- c(\"patent_id\", inv_fields) inv_fields #> [1] \"patent_id\"                     \"inventors.inventor_id\"         #> [3] \"inventors.inventor_city\"       \"inventors.inventor_country\"    #> [5] \"inventors.inventor_name_first\" \"inventors.inventor_name_last\"  #> [7] \"inventors.inventor_sequence\"   \"inventors.inventor_state\"  # Pull the data pv_out <- search_pv(query, fields = inv_fields, all_pages = TRUE, size = 1000)  # Unnest the inventor list column unnest_pv_data(pv_out$data, \"patent_id\") #> List of 2 #>  $ inventors:'data.frame':   16351 obs. of  8 variables: #>   ..$ patent_id          : chr [1:16351] \"11397055\" ... #>   ..$ inventor           : chr [1:16351] \"https://search.patentsview.org/api/\".. #>   ..$ inventor_name_first: chr [1:16351] \"Tzu-Yuan\" ... #>   ..$ inventor_name_last : chr [1:16351] \"Lin\" ... #>   ..$ inventor_city      : chr [1:16351] \"San Jose\" ... #>   ..$ inventor_state     : chr [1:16351] \"CA\" ... #>   ..$ inventor_country   : chr [1:16351] \"US\" ... #>   ..$ inventor_sequence  : int [1:16351] 1 2 ... #>  $ patents  :'data.frame':   4065 obs. of  1 variable: #>   ..$ patent_id: chr [1:4065] \"11397055\" ... query <- with_qfuns(   and(     contains(patent_title = \"beer\"),     eq(assignees.assignee_sequence = 0)   ) )  fields <- c(\"patent_id\", \"patent_title\", \"assignees.assignee_organization\") res <- search_pv(query = query, fields = fields, endpoint = \"patent\", size = 1) str(res$data) #> List of 1 #>  $ patents:'data.frame': 1 obs. of  3 variables: #>   ..$ patent_id   : chr \"10633239\" #>   ..$ patent_title: chr \"Communication system for monitoring beer kegs\" #>   ..$ assignees   :List of 1 #>   .. ..$ :'data.frame':  1 obs. of  1 variable: #>   .. .. ..$ assignee_organization: chr \"Shyft Advanced Industries\" #>  - attr(*, \"class\")= chr [1:2] \"list\" \"pv_data_result\""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/examples.html","id":"inventor-endpoint","dir":"Articles","previous_headings":"","what":"Inventor Endpoint","title":"Examples","text":"inventor’s recent patent Chicago, IL listed location. new version API, behavior endpoint changed. See similar example legacy inventors endpoint page original behavior. also call new version patent endpoint find inventors listed Chicago, IL location applying patent. Note inventors particular patent returned, just ones whose location Chicago, IL. Also see Writing Queries Vignette readable ways write queries.","code":"pv_out <- search_pv(   query = '{\"_and\":[{\"_text_phrase\": {\"inventor_lastknown_city\":\"Chicago\"}},                     {\"_text_phrase\": {\"inventor_lastknown_state\":\"IL\"}}]}',   endpoint = \"inventor\" )  pv_out #> $data #> #### A list with a single data frame on inventors level: #>  #> List of 1 #>  $ inventors:'data.frame':   1000 obs. of  3 variables: #>   ..$ inventor_id        : chr [1:1000] \"fl:cr_ln:goren-1\" ... #>   ..$ inventor_name_first: chr [1:1000] \"Craig\" ... #>   ..$ inventor_name_last : chr [1:1000] \"Goren\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 13,567 fields <- get_fields('patent', groups=\"inventors\") fields <- c(\"patent_id\", fields) fields #> [1] \"patent_id\"                     \"inventors.inventor_id\"         #> [3] \"inventors.inventor_city\"       \"inventors.inventor_country\"    #> [5] \"inventors.inventor_name_first\" \"inventors.inventor_name_last\"  #> [7] \"inventors.inventor_sequence\"   \"inventors.inventor_state\"  query <- '{\"_and\":[{\"_text_phrase\": {\"inventors.inventor_city\":\"Chicago\"}},                    {\"_text_phrase\": {\"inventors.inventor_state\":\"IL\"}}]}'  search_pv(query, fields=fields, endpoint=\"patent\") #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id: chr [1:1000] \"10631149\" ... #>   ..$ inventors:List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 47,033"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/examples.html","id":"assignee-endpoint","dir":"Articles","previous_headings":"","what":"Assignee Endpoint","title":"Examples","text":"assignee’s organizations start Microsoft?","code":"query <- qry_funs$begins(assignee_organization = \"Microsoft\") fields <- c(\"assignee_id\", \"assignee_organization\") pv_out <- search_pv(query, fields = fields, endpoint = \"assignee\") pv_out$data$assignees$assignee_organization #>  [1] \"Microsoft Mobile Internet AB\"                     #>  [2] \"MICROSOFT INTERNATIONAL HOLDINGS B.V.\"            #>  [3] \"Microsoft Technology, LLC.\"                       #>  [4] \"Microsoft Technology Beaming, LLC\"                #>  [5] \"Microsoft Mobile Oy\"                              #>  [6] \"Microsoft Technology Licensing, LLC\"              #>  [7] \"Microsoft Systems Inc.\"                           #>  [8] \"Microsoft Licencing Corporation, LLC\"             #>  [9] \"Microsoft Patent Licensing, LLC\"                  #> [10] \"Microsoft Corporation—One Microsoft Way\"          #> [11] \"Microsoft Orthopedics Holdings Inc.\"              #> [12] \"Microsoft Corporation\"                            #> [13] \"Microsoft Technology Learning, LLC\"               #> [14] \"Microsoft Israel Research and Development (2002)\" #> [15] \"Microsoft Licensing Technology, LLC\""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"a-basic-example","dir":"Articles","previous_headings":"","what":"A basic example","title":"Getting started","text":"Let’s start basic example use package’s primary function, search_pv(): call search_pv() sends query patent endpoint (default). API 27 endpoints, corresponding 27 different entity types. patent/rel_app_text publication/rel_app_text return rel_app_text entity, though slightly different. list entities API returns: assignees, attorneys, cpc_classes, cpc_groups, cpc_subclasses, foreign_citations, g_brf_sum_texts, g_claims, g_detail_desc_texts, g_draw_desc_texts, inventors, ipcs, locations, otherreferences, pg_brf_sum_texts, pg_claims, pg_detail_desc_texts, pg_draw_desc_texts, patents, publications, rel_app_texts, us_application_citations, us_patent_citations, uspc_mainclasses, uspc_subclasses, wipo.1 choice endpoint determines entity query applied , well structure data returned (“27 endpoints 27 entities section”). now, let’s turn attention query parameter.","code":"library(patentsview)  search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}',   endpoint = \"patent\" ) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10631087\" ... #>   ..$ patent_title: chr [1:1000] \"Method and device for voice operated contro\".. #>   ..$ patent_date : chr [1:1000] \"2020-04-21\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 5,452,372"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"writing-queries","dir":"Articles","previous_headings":"","what":"Writing queries","title":"Getting started","text":"PatentsView query syntax documented query language page note also change Options parameter new version API mentioned page.2 However, can difficult get query right ’re writing hand (.e., just writing query string like '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}', example shown ). patentsview package comes simple domain specific language (DSL) make writing queries breeze. recommend using functions DSL basic queries, especially ’re encountering errors don’t understand . get feel works, let’s rewrite query shown using one functions DSL, qry_funs$gte(): complex queries also possible: Check writing queries vignette details using DSL.","code":"qry_funs$gte(patent_date = \"2007-01-01\") #> {\"_gte\":{\"patent_date\":\"2007-01-01\"}} with_qfuns(   and(     gte(patent_date = \"2007-01-01\"),     text_phrase(patent_abstract = c(\"computer program\", \"dog leash\"))   ) ) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-01-01\"}},{\"_or\":[{\"_text_phrase\":{\"patent_abstract\":\"computer program\"}},{\"_text_phrase\":{\"patent_abstract\":\"dog leash\"}}]}]}"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"fields","dir":"Articles","previous_headings":"","what":"Fields","title":"Getting started","text":"endpoint different set fields. new version API allows fields queried. first example, didn’t specify fields wanted retrieve given default set. can specify fields want using fields argument: list fields given endpoint, use get_fields(): Nested fields can fully qualified new API shorthand can used, group names can specified. group names used, group’s nested fields returned API. E.g., new version API R package accept fields=c(\"applicants\") See Swagger UI page API, fields returned listed endpoint 200 Response body sections. API’s endpoint documentation similar look feel. can also visit endpoint’s online documentation page see list fields (e.g., see inventor field list table). earlier versions API fields queryable now. field tables endpoints can found fieldsdf data frame, can load using data(\"fieldsdf\") View(patentsview::fieldsdf). important note: PatentsView uses disambiguated versions assignees, inventors, locations, instead raw data. example, let’s say search inventors whose first name “john.” PatentsView API going return inventors preferred first name (per disambiguation results) john, may necessarily raw first name. getting back inventors whose first name appears patent , say, “jonathan,” “johnn,” even “john jay.”, see PatentsView Inventor Disambiguation Technical Workshop website. original version API, rawinventor_first_name rawinventor_last_name available patents, inventors assignees endpoints. new version API fields longer available.","code":"# search_pv defaults the endpoint parameter to \"patents\" if not specified result = search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}',   fields = c(\"patent_id\", \"patent_title\") ) result #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id   : chr [1:1000] \"10631087\" ... #>   ..$ patent_title: chr [1:1000] \"Method and device for voice operated contro\".. #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 5,452,372 retrvble_flds <- get_fields(endpoint = \"patent\") head(retrvble_flds) #> [1] \"applicants.applicant_designation\"  \"applicants.applicant_name_first\"   #> [3] \"applicants.applicant_name_last\"    \"applicants.applicant_organization\" #> [5] \"applicants.applicant_sequence\"     \"applicants.applicant_type\""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"paginated-responses","dir":"Articles","previous_headings":"","what":"Paginated responses","title":"Getting started","text":"default, search_pv() returns 1,000 records per page gives first page results. suggest starting something smaller, like size = 150 , ’re figuring details request, query want use fields want returned. items finalized, can use size argument download 1,000 records per page. can download pages output one call setting all_pages = TRUE. set size equal 1,000 loop pages output: See result set paging vignette information custom paging.","code":"fields <- c(\"patent_id\", \"inventors.inventor_name_last\", \"inventors.inventor_name_first\") search_pv(   query = qry_funs$eq(inventors.inventor_name_last = \"Chambers\"),   all_pages = TRUE, size = 1000, fields = fields ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 2487 obs. of  2 variables: #>   ..$ patent_id: chr [1:2487] \"3931611\" ... #>   ..$ inventors:List of 2487 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 2,487"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"entity-counts","dir":"Articles","previous_headings":"","what":"Entity counts","title":"Getting started","text":"last two calls search_pv() gave value total_hits, even though got lot data second call. entity counts returned API refer number distinct entities across downloadable pages output, just page returned.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"endpoints-for-27-entities","dir":"Articles","previous_headings":"","what":"27 endpoints for 27 entities","title":"Getting started","text":"recent API change, patent endpoint supplies basic patent data endpoints return specific data patents. choice endpoint determines two things: entity query applied . first call shown used patent endpoint, API searched patents least one inventor listed last name “Chambers.” second call used inventor endpoint show returns similar query. structure data frame returned. first call returned data frame patent level, meaning row corresponded different patent. Fields patent level (e.g., inventors.inventor_name_last) returned list columns named entity associated field (e.g., inventors entity).3 Meanwhile, second call gave us data frame inventor level (one row inventor) used inventor endpoint. time want use patent endpoint. Note can still effectively filter fields patent-level using patent endpoint (e.g., can filter assignee name CPC category). patents relatively low-level entities. higher level entities like assignees, filter field assignee-level (e.g., inventor name), API return data assignee least one inventor whose name matches search, probably want.","code":"get_endpoints() #>  [1] \"assignee\"                       \"cpc_class\"                      #>  [3] \"cpc_group\"                      \"cpc_subclass\"                   #>  [5] \"g_brf_sum_text\"                 \"g_claim\"                        #>  [7] \"g_detail_desc_text\"             \"g_draw_desc_text\"               #>  [9] \"inventor\"                       \"ipc\"                            #> [11] \"location\"                       \"patent\"                         #> [13] \"patent/attorney\"                \"patent/foreign_citation\"        #> [15] \"patent/other_reference\"         \"patent/rel_app_text\"            #> [17] \"patent/us_application_citation\" \"patent/us_patent_citation\"      #> [19] \"pg_brf_sum_text\"                \"pg_claim\"                       #> [21] \"pg_detail_desc_text\"            \"pg_draw_desc_text\"              #> [23] \"publication\"                    \"publication/rel_app_text\"       #> [25] \"uspc_mainclass\"                 \"uspc_subclass\"                  #> [27] \"wipo\"  query <- qry_funs$eq(inventors.inventor_name_last = \"Chambers\")  # Here we'll request patent_id and the inventor fields from the patent endpoint fields <- get_fields(endpoint = \"patent\", groups =\"inventors\") fields <- c(\"patent_id\", fields) fields #> [1] \"patent_id\"                     \"inventors.inventor_id\"         #> [3] \"inventors.inventor_city\"       \"inventors.inventor_country\"    #> [5] \"inventors.inventor_name_first\" \"inventors.inventor_name_last\"  #> [7] \"inventors.inventor_sequence\"   \"inventors.inventor_state\"  result <- search_pv(query, endpoint = \"patent\", fields = fields) result #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  2 variables: #>   ..$ patent_id: chr [1:1000] \"10631591\" ... #>   ..$ inventors:List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 2,487  # Here's the first inventors result$data$patents$inventors[[1]] #>                                                              inventor #> 1   https://search.patentsview.org/api/v1/inventor/fl:jo_ln:droege-1/ #> 2 https://search.patentsview.org/api/v1/inventor/fl:cl_ln:chambers-3/ #>   inventor_name_first inventor_name_last inventor_city inventor_state #> 1                John             Droege      Portland             OR #> 2             Clayton           Chambers      Portland             OR #>   inventor_country inventor_sequence #> 1               US                 1 #> 2               US                 0  # Now we will see what the inventor endpoint returns for a similar query. # We use get_fields() to get all the available for the inventor endpoint. query <- qry_funs$eq(inventor_name_last = \"Chambers\") fields <- get_fields(endpoint = \"inventor\")  search_pv(query, endpoint = \"inventor\", fields = fields) #> $data #> #### A list with a single data frame (with list column(s) inside) on inventors level: #>  #> List of 1 #>  $ inventors:'data.frame':   439 obs. of  16 variables: #>   ..$ inventor_id                 : chr [1:439] \"fl:er_ln:chambers-1\" ... #>   ..$ inventor_name_first         : chr [1:439] \"Erin E.\" ... #>   ..$ inventor_name_last          : chr [1:439] \"Chambers\" ... #>   ..$ inventor_gender_code        : chr [1:439] \"F\" ... #>   ..$ inventor_lastknown_city     : chr [1:439] \"Sutton\" ... #>   ..$ inventor_lastknown_state    : chr [1:439] \"MA\" ... #>   ..$ inventor_lastknown_country  : chr [1:439] \"US\" ... #>   ..$ inventor_lastknown_latitude : num [1:439] 42.1 ... #>   ..$ inventor_lastknown_longitude: num [1:439] -71.8 ... #>   ..$ inventor_lastknown_location : chr [1:439] \"https://search.patentsview.o\".. #>   ..$ inventor_num_patents        : int [1:439] 6 2 ... #>   ..$ inventor_num_assignees      : int [1:439] 1 1 ... #>   ..$ inventor_first_seen_date    : chr [1:439] \"2011-11-01\" ... #>   ..$ inventor_last_seen_date     : chr [1:439] \"2023-09-05\" ... #>   ..$ inventor_years_active       : num [1:439] 12 9 ... #>   ..$ inventor_years              :List of 439 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 439"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"casting-fields","dir":"Articles","previous_headings":"","what":"Casting fields","title":"Getting started","text":"API now returns data fields appropriate data type (e.g., numeric). , however, fields returned strings rather integers 33 date fields now. also two rule_47_flags, one returned patent endpoint, publication endpoint. former boolean latter string can cast boolean. Lastly, document numbers numeric though two instances strings can cast integers. can cast fields preferred R types using cast_pv_data():","code":"library(knitr)  # These fields are received as strings and would be cast to integers ints <- fieldsdf[fieldsdf$data_type == \"int\", c(\"endpoint\",\"field\")] ints <- ints[order(ints$field),] print(ints,  row.names = FALSE) #>                        endpoint                    field #>                        assignee            assignee_type #>                          patent  assignees.assignee_type #>                     publication  assignees.assignee_type #>  patent/us_application_citation citation_document_number  # These fields are received as strings and would be cast to dates date_fields <- fieldsdf[fieldsdf$data_type == \"date\", c(\"endpoint\",\"field\")] kable(date_fields, row.names = FALSE) res <- search_pv(   query = '{\"patent_id\":\"5116621\"}',    fields = c(\"patent_id\", \"patent_date\", \"patent_title\", \"patent_year\", \"assignees.assignee_type\") )  # unnest_pv_data shows that the assignee_type field is received as a string and patent_year # is received as an integer unnest_pv_data(res$data) #> List of 2 #>  $ assignees:'data.frame':   2 obs. of  2 variables: #>   ..$ patent_id    : chr [1:2] \"5116621\" ... #>   ..$ assignee_type: chr [1:2] \"3\" ... #>  $ patents  :'data.frame':   1 obs. of  4 variables: #>   ..$ patent_id   : chr \"5116621\" #>   ..$ patent_title: chr \"Anti-inflammatory analgesic patch\" #>   ..$ patent_date : chr \"1992-05-26\" #>   ..$ patent_year : int 1992  # cast_pv_data will convert the string patent_date to an R date and assignee_type to an integer recast <- cast_pv_data(res$data) #> Error in cast_pv_data(res$data): could not find function \"cast_pv_data\" unnest_pv_data(recast) #> Error in \"pv_data_result\" %in% class(data): object 'recast' not found"},{"path":[]},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"im-sure-my-query-is-well-formatted-and-correct-but-i-keep-getting-an-error--whats-the-deal","dir":"Articles","previous_headings":"FAQs","what":"I’m sure my query is well formatted and correct but I keep getting an error. What’s the deal?","title":"Getting started","text":"API query syntax guidelines cover API’s behavior. Specifically, several things documented API’s webpage. writing queries vignette details . can also try string version query API’s Swagger UI page. error messages can sometimes help determine problem. Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request.","code":"httr2::last_request()"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"does-the-api-have-any-rate-limitingthrottling-controls","dir":"Articles","previous_headings":"FAQs","what":"Does the API have any rate limiting/throttling controls?","title":"Getting started","text":"Yes, API currently allows 45 calls per minute API key. limit exceeded API return http status 429 response header Retry-set number seconds wait making subsequent requests. R package handle . need request API key set environmental variable PATENTSVIEW_API_KEY value key.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/getting-started.html","id":"how-do-i-access-the-data-frames-inside-the-list-columns-returned-by-search_pv","dir":"Articles","previous_headings":"FAQs","what":"How do I access the data frames inside the list columns returned by search_pv()?","title":"Getting started","text":"Let’s consider following data, patents primary entity “application”, “assignees”, “gov_interest_organizations” secondary entities (also referred subentities): res$data vector columns fields belong primary entity (e.g., res$data$patents$patent_id) list columns fields belong secondary entity (e.g., res$data$patents$gov_interest_organizations). two good ways pull data frames nested inside list columns: Use tidyr::unnest. (probably easier choice two). Use patentsview::unnest_pv_data. unnest_pv_data() creates series data frames (one entity level) like tables relational database. provide data returned search_pv() field can act unique identifier primary entities: Now left series flat data frames instead single data frame data frames nested inside . flat data frames can joined together needed via primary key (patent_id) endpoint.","code":"# Create field list - fields <- c(\"patent_id\", \"patent_date\", \"patent_title\",   \"assignees\", \"application\",  \"gov_interest_organizations\" )  # Pull data res <- search_pv(   query = qry_funs$text_any(inventors.inventor_name_last = \"Smith\"),    endpoint = \"patent\",    fields = fields ) res$data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  6 variables: #>   ..$ patent_id                 : chr [1:1000] \"10631478\" ... #>   ..$ patent_title              : chr [1:1000] \"Automated Christmas tree wate\".. #>   ..$ patent_date               : chr [1:1000] \"2020-04-28\" ... #>   ..$ application               :List of 1000 #>   ..$ assignees                 :List of 1000 #>   ..$ gov_interest_organizations:List of 1000 library(tidyr)  # Get assignee data: res$data$patents %>%    unnest(assignees) %>%   head() #> # A tibble: 6 × 14 #>   patent_id patent_title paten…¹ appli…² assig…³ assig…⁴ assig…⁵ assig…⁶ assig…⁷ #>   <chr>     <chr>        <chr>   <list>  <chr>   <chr>   <chr>   <chr>   <chr>   #> 1 10631478  Automated C… 2020-0… <df>    https:… 2       <NA>    <NA>    CHRIST… #> 2 10631557  Preservativ… 2020-0… <df>    https:… 2       <NA>    <NA>    PepsiC… #> 3 10631704  Dishwasher … 2020-0… <df>    https:… 2       <NA>    <NA>    WHIRLP… #> 4 10631705  Household a… 2020-0… <df>    https:… 2       <NA>    <NA>    WHIRLP… #> 5 10631855  Wound closu… 2020-0… <df>    https:… 2       <NA>    <NA>    Covidi… #> 6 10631872  Hemostatic … 2020-0… <df>    https:… 2       <NA>    <NA>    Boston… #> # … with 5 more variables: assignee_city <chr>, assignee_state <chr>, #> #   assignee_country <chr>, assignee_sequence <int>, #> #   gov_interest_organizations <list>, and abbreviated variable names #> #   ¹​patent_date, ²​application, ³​assignee, ⁴​assignee_type, #> #   ⁵​assignee_individual_name_first, ⁶​assignee_individual_name_last, #> #   ⁷​assignee_organization unnest_pv_data(data = res$data, pk = \"patent_id\") #> List of 4 #>  $ application               :'data.frame':  1000 obs. of  7 variables: #>   ..$ patent_id       : chr [1:1000] \"10631478\" ... #>   ..$ application_id  : chr [1:1000] \"15/625439\" ... #>   ..$ application_type: chr [1:1000] \"15\" ... #>   ..$ filing_date     : chr [1:1000] \"2017-06-16\" ... #>   ..$ series_code     : chr [1:1000] \"15\" ... #>   ..$ rule_47_flag    : logi [1:1000] FALSE ... #>   ..$ filing_type     : chr [1:1000] \"15\" ... #>  $ assignees                 :'data.frame':  978 obs. of  10 variables: #>   ..$ patent_id                     : chr [1:978] \"10631478\" ... #>   ..$ assignee                      : chr [1:978] \"https://search.patentsview\".. #>   ..$ assignee_type                 : chr [1:978] \"2\" ... #>   ..$ assignee_individual_name_first: chr [1:978] NA ... #>   ..$ assignee_individual_name_last : chr [1:978] NA ... #>   ..$ assignee_organization         : chr [1:978] \"CHRISTMAS TREE BUTLER, INC\".. #>   ..$ assignee_city                 : chr [1:978] \"Saratoga Springs\" ... #>   ..$ assignee_state                : chr [1:978] \"NY\" ... #>   ..$ assignee_country              : chr [1:978] \"US\" ... #>   ..$ assignee_sequence             : int [1:978] 0 0 ... #>  $ gov_interest_organizations:'data.frame':  48 obs. of  5 variables: #>   ..$ patent_id     : chr [1:48] \"10639298\" ... #>   ..$ fedagency_name: chr [1:48] \"National Institutes of Health\" ... #>   ..$ level_one     : chr [1:48] \"Department of Health and Human Services\" ... #>   ..$ level_two     : chr [1:48] \"National Institutes of Health\" ... #>   ..$ level_three   : chr [1:48] NA ... #>  $ patents                   :'data.frame':  1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"10631478\" ... #>   ..$ patent_title: chr [1:1000] \"Automated Christmas tree watering system\" ... #>   ..$ patent_date : chr [1:1000] \"2020-04-28\" ..."},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/patentsview-breaking-release.html","id":"user-impacting-api-changes","dir":"Articles","previous_headings":"","what":"User Impacting API changes:","title":"Breaking Release of the Patentsview Package","text":"Users need request API key set environmental variable PATENTSVIEW_API_KEY value. Endpoint changes: nber_subcategories, one original seven endpoints, removed cpc_subsections now cpc_group remaining five original endpoints went plural singular, “patents” now “patent” example. Interestingly, returned data structures still plural part. now 27 endpoints, may need called retrieve fields currently (soon---) available original endpoints (now endpoint’s returns lighter, requiring additional calls made). Now endpoints return HATEOAS (Hypermedia Engine Application State) links retrieve data (URLs additional calls back API) fields now nested need fully qualified used query, instance, search_pv('{\"cpc_current.cpc_group_id\":\"A01B1/00\"}') using patent endpoint. fields parameter, nested fields can fully qualified new API shorthand can used, group names can specified. group names used, group’s nested fields returned API. example, new version API R package accept fields=c(“assignees”) using patent endpoint nested assignees’ fields returned API. field’s names changed, significantly, patent_number now patent_id, fields removed entirely, instance, rawinventor_first_name rawinventor_last_name. original version API queryable fields additional fields retrieved couldn’t part conditional query. notion apply new version API fields now queryable. may able simplify code found post processing returned data field interested queryable. Currently working properly, isn’t supposed difference operators used full text fields, original version API. See tip Syntax section. Note result sizes aren’t matching currently though, see testthat/test-api-bugs.R testthat folder. Result set paging changed significantly. matter users implemented paging, R package continues handle result set paging search_pv’s all_pages = TRUE. new result set paging vignette explain way API now pages, using size parameters rather using per_page page. API team also renamed API, PatentsView’s Search API now PatentSearch API. Note R package retain name, continue use library(patentsview)","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/patentsview-breaking-release.html","id":"highlights-of-the-r-package","dir":"Articles","previous_headings":"","what":"Highlights of the R package:","title":"Breaking Release of the Patentsview Package","text":"Throttling now enforced API handled R package (sleep specified throttle response retry) new “Converting existing script” vignette rOpenSci post announced original version R package changed work new version API now new vignette. Understanding API, API team’s jupyter notebook, converted R writing custom result set paging R package changed internally using httr httr2. affects users passed additional arguments (…) search_pv(). Previously passed config = httr::timeout(40) ’d now pass timeout = 40 (name-value pairs valid curl options, found curl::curl_options() see req_options) Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request. Also fun seeing raw API response. retrieve_linked_data() retrieve data HATEOAS link API sent back, retrying throttled pad_patent_id(), needed custom paging using patent_id, see new Result Set Paging vignette","code":"httr2::last_request() httr2::last_response() httr2::last_response() |> httr2::resp_body_json()"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/patentsview-breaking-release.html","id":"online-documentation","dir":"Articles","previous_headings":"","what":"Online Documentation","title":"Breaking Release of the Patentsview Package","text":"API team thoughtfully provided Swagger UI page new version API https://search.patentsview.org/swagger-ui/. Think online version Postman already loaded API’s new endpoints returns. Swagger UI page documents fields returned endpoint successful call. (Response http code 200). can even send requests see actual API responses enter API key press endpoint’s “Try ” “Execute” buttons. Even error responses can informative, usually pointing went wrong. similar format, updated API documentation lists endpoint . Additionally, R package’s fieldsdf data frame updated, now listing new set endpoints fields can queried /returned. R package’s reference pages also updated.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/patentsview-breaking-release.html","id":"final-thoughts","dir":"Articles","previous_headings":"","what":"Final Thoughts","title":"Breaking Release of the Patentsview Package","text":"shown updated Top Assignees vignette, occasions now multiple API calls needed retrieve data single API call original version API R package. Additionally, reworked rOpenSci post explains changes made since assignee latitude longitude longer available patent endpoint. Issues questions API can raised API’s portal API’s forum. Issues R package can raised patentsview repo.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/result-set-paging.html","id":"example-1","dir":"Articles","previous_headings":"","what":"Example 1","title":"Result Set Paging","text":"Note: recent API release changed paging sorting patent_id. used pass unaltered last value received. Now need pad patent_id 8 characters order page result set. seems intentional change, seemingly needed patent_id paging, pad_patent_id() added R package. ’ll retrieve 5000 utility patents using custom paging.","code":"library(patentsview)  # Lets get 5000 utility patents, 1000 at a time (the API's maximum rows per request) requested_rows <- 1000 sort <- c(\"patent_id\" = \"asc\") query <- qry_funs$eq(\"patent_type\" = \"utility\") fields <- c(\"patent_id\", \"patent_date\", \"patent_title\")  # The \"after\" parameter is explained a bit lower.  It's an Elasticsearch thing, # and is the attrbute the new version of the API uses to page.  For now, just be  # thankful that the R package handles this for you when you set all_pages = TRUE after <- NULL results <- list()  for (n in seq_len(5)) {   after <- if(is.null(after)) after else pad_patent_id(after)   print(paste(\"page\", n, \"after is\", ifelse(is.null(after),\"NULL\",after)))    page_n <- search_pv(query, fields = fields, sort = sort,      all_pages = FALSE, size = requested_rows, after = after)    s <- names(sort)    last_index <- nrow(page_n$data[[1]])    after <- page_n$data[[1]][[s]][[last_index]] # the last value of the sort field    results[[n]] = page_n$data } #> [1] \"page 1 after is NULL\" #> [1] \"page 2 after is 03931271\" #> [1] \"page 3 after is 03932272\" #> [1] \"page 4 after is 03933272\" #> [1] \"page 5 after is 03934274\"  utility_sample <- as.data.frame(do.call(rbind, lapply(results, as.data.frame)))  str(utility_sample) #> 'data.frame':    5000 obs. of  3 variables: #>  $ patents.patent_id   : chr  \"3930271\" \"3930272\" \"3930273\" \"3930274\" ... #>  $ patents.patent_title: chr  \"Golf glove\" \"Crib leg lock\" \"Bed safety side rail arrangement\" \"Assembly for use in recreational activities\" ... #>  $ patents.patent_date : chr  \"1976-01-06\" \"1976-01-06\" \"1976-01-06\" \"1976-01-06\" ..."},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/result-set-paging.html","id":"example-2","dir":"Articles","previous_headings":"","what":"Example 2","title":"Result Set Paging","text":"execute query two different ways, first R package paging, second misguided attempt paging . Quick piece trivia: handful exceptions, US patents issued Tuesday. counts issue date January 1976 help illustrate ’re lead trouble. (Note single patent issued 1976-01-25 mistake patentsview database need sum match r_pkg$query_results$total_hits just displayed) Now ’ll try paging , might notice, ’ll run trouble using patent_date sort field ( thus ‘’ parameter ’ll send API). ran trouble since chose patent_date sort field isn’t unique row-wise result set patent_id Example 1. cases set ‘’ last patent_date page results, weren’t done retrieving date’s patents. (page breaks aren’t guaranteed align patent_date changes result set. See page boundary shown next example isn’t clear yet.) R package uses appropriate key(s) all_pages = TRUE. get_ok_pk(endpoint) changed also return secondary sort key needed. next example shows sometimes secondary sort required guarantee row uniqueness (vital paging via ‘’ parameter, API properly picks exactly previous page data left ).","code":"fields <- c(\"patent_id\", \"patent_date\", \"patent_title\") sort <- c(\"patent_date\" = \"asc\") query <- '{\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1976-01-31\"}}]}' r_pkg <- search_pv(query, sort = sort, fields = fields, all_pages = TRUE)  # note the number of rows returned r_pkg$query_results$total_hits #> [1] 5352 issue_dates = unique(r_pkg$data$patents$patent_date)    counts <- lapply(issue_dates, function(issue_date) {       query <- qry_funs$eq(patent_date = issue_date)       res <- search_pv(query)       weekday <-  weekdays(as.Date(issue_date))       print(paste(res$query_results$total_hits, issue_date, weekday))       res$query_results$total_hits    }) #> [1] \"1379 1976-01-06 Tuesday\" #> [1] \"1257 1976-01-13 Tuesday\" #> [1] \"1383 1976-01-20 Tuesday\" #> [1] \"1 1976-01-25 Sunday\" #> [1] \"1332 1976-01-27 Tuesday\"    sum(unlist(counts)) #> [1] 5352 after <- NULL combined_data <- NULL count <- 0 requested_rows <- 1000  # API's maximum rows per request  # these variables remain the same sort <- c(\"patent_date\" = \"asc\") query <- '{\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1976-01-31\"}}]}' fields <- c(\"patent_id\", \"patent_date\", \"patent_title\")  # We'll continue to make requests until we get back an empty or partial # response from the API page <- 1  repeat {   print(paste(\"page\", page, \"after is\", ifelse(is.null(after), \"NULL\", after)))    subsequent <- search_pv(query, sort = sort, all_pages = FALSE,     fields = fields, size = requested_rows, after = after)    # subsequent$data$patents is an empty list if we page too far   returned_rows <- ifelse(length(subsequent$data$patents) == 0, 0, nrow(subsequent$data$patents))    if(returned_rows > 0) {      combined_data <- rbind(combined_data, subsequent$data$patents)      count <- count + returned_rows       page <- page  + 1   }    # We're done if we got an empty or partial reply from the API   if(returned_rows < requested_rows) {      break   }    # Now to page we need to set the \"after\" attribute to where the   # current results ended.  Its value is the last row's [[sort field]].    # It would need to be an array of values if there are multiple sort fields   s <- names(sort)[[1]]   after <- subsequent$data[[1]][[s]][[returned_rows]]  } #> [1] \"page 1 after is NULL\" #> [1] \"page 2 after is 1976-01-06\" #> [1] \"page 3 after is 1976-01-13\" #> [1] \"page 4 after is 1976-01-20\" #> [1] \"page 5 after is 1976-01-27\"  print(paste(\"count is\", count)) #> [1] \"count is 4000\" print(nrow(combined_data)) #> [1] 4000"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/result-set-paging.html","id":"example-3","dir":"Articles","previous_headings":"","what":"Example 3","title":"Result Set Paging","text":"’ll demonstrate sometimes, order custom paging, secondary sort required. Normally R package handles users all_pages = TRUE. way API now handles paging, sort key(s) () used determine ‘’ parameter’s value(s), instructing API next page results begins. new endpoints can return one row data primary key. endpoints sequence parameter. Sorting thus paging primary key endpoints can lead trouble, like sorting patent_date second half Example 2. Ok, ’ll minimalist custom paging secondary sort using patent/us_patent_citation endpoint. code similar ’s citation network vignette, first learned primary sort always sufficient (requiring changes R package). ’s quick look data around page boundary try show needed secondary sort. ’s necessarily wanted secondary sort, gives us ability use second column’s value ‘’ parameter.","code":"library(dplyr)    sequence_eps <- fieldsdf[grepl(\"^[^.]*sequence\",fieldsdf$field), \"endpoint\"]   seq_pks <- lapply(sequence_eps, function(endpoint) {      c(endpoint, get_ok_pk(endpoint))   })    sequences_df <- as.data.frame(do.call(\"rbind\", seq_pks))   colnames(sequences_df) <- c(\"endpoint\", \"primary\", \"secondary\")   sequences_df #>                         endpoint         primary          secondary #> 1                        g_claim       patent_id     claim_sequence #> 2               g_draw_desc_text       patent_id draw_desc_sequence #> 3        patent/foreign_citation       patent_id  citation_sequence #> 4         patent/other_reference       patent_id reference_sequence #> 5 patent/us_application_citation       patent_id  citation_sequence #> 6      patent/us_patent_citation       patent_id  citation_sequence #> 7                       pg_claim document_number     claim_sequence #> 8              pg_draw_desc_text document_number draw_desc_sequence # Write a query to pull patents assigned to the CPC code of \"Y10S707/933\" query <- qry_funs$contains(cpc_current.cpc_group_id = \"Y10S707/933\") pv_out <- search_pv(query = query, fields = c(\"patent_id\")) patent_ids <- pv_out$data$patents$patent_id  # We have to go against the patent citiation endpoint now, these fields # are no longer available from the patent endpoint  citing_query <- qry_funs$eq(patent_id = patent_ids) cited_query <- qry_funs$eq(citation_patent_id = patent_ids)  # Create a list of fields to pull from the API fields <- c(   \"patent_id\",   \"citation_patent_id\",   \"citation_sequence\" )  sort <- c(\"patent_id\" = \"asc\", \"citation_sequence\" = \"asc\")  # Request the first page of results res <- search_pv(citing_query,   fields = fields, all_pages = FALSE,   sort =  sort,   endpoint = \"patent/us_patent_citation\", method = \"POST\", size = 1000 )  last_row <- nrow(res$data$us_patent_citations) last_patent_id <- res$data$us_patent_citations$patent_id[[last_row]] last_citation_sequence <- res$data$us_patent_citations$citation_sequence[[last_row]] after <- c(last_patent_id, last_citation_sequence) print(after) #> [1] \"10095778\" \"57\"  # make our own request to get the second page of results, knowing that's it (1066 total rows) remaining <- search_pv(citing_query,   fields = fields, all_pages = FALSE,   sort =  sort,   after = after,   endpoint = \"patent/us_patent_citation\", method = \"POST\", size = 1000 )  blend <- list(res$data[[1]], remaining$data[[1]]) blended <- list(do.call(\"rbind\", c(blend, make.row.names = FALSE))) names(blended) <- names(res$data) str(blended) #> List of 1 #>  $ us_patent_citations:'data.frame': 1066 obs. of  3 variables: #>   ..$ patent_id         : chr [1:1066] \"6339767\" \"6339767\" \"6339767\" \"6339767\" ... #>   ..$ citation_sequence : int [1:1066] 0 1 2 3 4 5 6 7 8 9 ... #>   ..$ citation_patent_id: chr [1:1066] \"4847604\" \"4622545\" \"4555775\" \"5283894\" ... # ending of the first page of results tail(res$data$us_patent_citations, n=3) #>      patent_id citation_sequence citation_patent_id #> 998   10095778                55            6311173 #> 999   10095778                56            6330547 #> 1000  10095778                57            6339767  #  ***********  data page boundary ***********    # start of the second page of results head(remaining$data$us_patent_citations, n=3) #>   patent_id citation_sequence citation_patent_id #> 1  10095778                58            6360210 #> 2  10095778                59            6363373 #> 3  10095778                60            6389418  # end of the second page of results tail(remaining$data$us_patent_citations, n=3) #>    patent_id citation_sequence citation_patent_id #> 64  10095778               121            8504560 #> 65  10095778               122            8818996 #> 66  10095778               123            9075849  # If the sort was only by patent_id, the second request would return # zero rows since there aren't patent_ids 'after' 10095778"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/result-set-paging.html","id":"takeaways","dir":"Articles","previous_headings":"","what":"Takeaways","title":"Result Set Paging","text":", all_pages = TRUE R package handles ! ’d need code like use case requires custom paging. custom paging takeaways : original version API R package used per_page page allow users page result sets. attributes replaced size new version API R package. sort field(s) need create row-wise uniqueness. minimum get_ok_pk(endpoint) fields need included sort fields though others can added. patent_id used sort field, corresponding ‘’ value needs padding, see pad_patent_id() used Example 1 single sort field, parameter’s value sort field’s last value recently retrieved page data (Example 1). multiple sort fields, parameter’s value vector sort fields’ last values (Example 3).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"why-care-about-patents","dir":"Articles","previous_headings":"","what":"Why care about patents?","title":"Accessing patent data with the patentsview package","text":"1. Patents play critical role incentivizing innovation, without wouldn’t much technology rely everyday iPhone, Google’s PageRank algorithm, butter substitute called Smart Balance common?  …probably wouldn’t patents. patent provides owner ability make money something invented, without worry someone else copying technology. Think Apple spend millions dollars developing iPhone Samsung just come along rip ? Probably . 2. Patents offer great opportunity data analysis two primary reasons : Patent data public. return exclusive right profit invention, individual/company publicly disclose details invention rest world. Examples details include patent’s title, abstract, technology classification, assigned organizations, etc. Patent data can answer questions people care . Companies (especially big ones like IBM Google) vested interest extracting insights patents, spend lot time/resources trying figure best manage intellectual property (IP) rights. ’re plagued questions like “sell underperforming patents ,” “technology areas open new innovations,” “’s going next big thing world buttery spreads,” etc. Patents offer way provide data-driven answers questions. Combined, two things make patents prime target data analysis. However, recently hard get data inside documents. One either collect manually using official United States Patent Trademark Office (USPTO) search engine, figure way download, parse, model huge XML data dumps. Enter PatentsView.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"patentsview-and-the-patentsview-package","dir":"Articles","previous_headings":"","what":"PatentsView and the patentsview package","title":"Accessing patent data with the patentsview package","text":"PatentsView one USPTO’s new initiatives intended increase usability value patent data. One feature project publicly accessible API makes easy programmatically interact data. reasons like API (PatentsView generally): API key now required (request one ) throttling imposed (handled new version R package) 45 requests per minute. project offers bulk downloads patent data website (flat file format), want closest data. API bulk download data contain disambiguated entities inventors, assignees, organizations, etc. words, API tell whether thinks John Smith patent X person John Smith patent Y.1 patentsview R package wrapper around PatentsView API. contains function acts client API (search_pv()) well several supporting functions. Full documentation package can found website.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Accessing patent data with the patentsview package","text":"can get stable version CRAN: latest build r-universe: GitHub:","code":"install.packages(\"patentsview\") options(repos = c(   patentsview = \"https://ropensci.r-universe.dev/patentsview\",   CRAN = \"https://cloud.r-project.org\" ))  install.packages(\"patentsview\") if (!require(devtools)) install.packages(\"devtools\")    devtools::install_github(\"ropensci/patentsview\")"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting started","title":"Accessing patent data with the patentsview package","text":"package one main function, search_pv(), makes easy send requests API. two parameters search_pv() ’re going want think just every time call - query fields. tell API want filter patent data query, fields want retrieve fields.2","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"query","dir":"Articles","previous_headings":"Getting started","what":"query","title":"Accessing patent data with the patentsview package","text":"query use PatentsView query language, JSON-based syntax similar one used Lucene. can write query directly pass string search_pv(): …can use domain specific language (DSL) provided patentsview package help write query: qry_1 qry_2 result HTTP call API. queries search patents USPTO published 2014. three gotchas look writing query: Fields now queryable. API 23 endpoints (default endpoint “patent”), endpoint set fields can filter . Correct data type field. ’re filtering field query, make sure value filtering consistent field’s data type. example, patent_year type “integer,” pass 2014 string ’re going get error (patent_year = 2014 good, patent_year = \"2014\" good). can find field’s data type fieldsdf data frame. Comparison function works field’s data type. comparison function(s) use (e.g., greater-function shown , qry_funs$gt()) must consistent field’s data type. example, can’t use “contains” function fields type “integer” (qry_funs$contains(patent_year = 2014) throw error). See ?qry_funs details. short, use fieldsdf data frame write query fine. Check writing queries vignette details.","code":"library(patentsview)  qry_1 <- '{\"_gt\":{\"patent_year\":2014}}' search_pv(query = qry_1, fields = NULL) # This will retrieve a default set of fields #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  1 variable: #>   ..$ patent_id: chr [1:1000] \"10631087\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,491,425 qry_2 <- qry_funs$gt(patent_year = 2014) # All DSL functions are in the qry_funs list qry_2 # qry_2 is the same as qry_1 #> {\"_gt\":{\"patent_year\":2014}}  search_pv(query = qry_2) #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  1 variable: #>   ..$ patent_id: chr [1:1000] \"10631087\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,491,425"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"fields","dir":"Articles","previous_headings":"Getting started","what":"fields","title":"Accessing patent data with the patentsview package","text":"now using default value fields. results API giving us small set default fields. Let’s see retrieving fields: original verison API, requested patent_average_processing_time inventor_total_num_patents. fields longer available patent endpoint. fields can retrieve depends endpoint hitting. ’ve using “patent” endpoint thus far, retrievable: fieldsdf[fieldsdf$endpoint == \"patent\", \"field\"]. can also use get_fields() list retrievable fields given endpoint, optionally limited specific groups nested top level fields","code":"search_pv(   query = qry_funs$gt(patent_year = 2014),   fields = c(\"patent_abstract\", \"inventors.inventor_name_first\") ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id      : chr [1:1000] \"10631087\" ... #>   ..$ patent_abstract: chr [1:1000] \"Methods and devices for processing and v\".. #>   ..$ inventors      :List of 1000 #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,491,425 search_pv(   query = qry_funs$gt(patent_year = 2014),   fields = get_fields(endpoint = \"patent\", groups = c(\"patents\", \"inventors\")) ) #> $data #> #### A list with a single data frame (with list column(s) inside) on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  20 variables: #>   ..$ patent_id                                                   : chr [1:10\".. #>   ..$ patent_title                                                : chr [1:10\".. #>   ..$ patent_type                                                 : chr [1:10\".. #>   ..$ patent_date                                                 : chr [1:10\".. #>   ..$ patent_year                                                 : int [1:100.. #>   ..$ patent_abstract                                             : chr [1:10\".. #>   ..$ patent_cpc_current_group_average_patent_processing_days     : int [1:100.. #>   ..$ patent_detail_desc_length                                   : int [1:100.. #>   ..$ patent_earliest_application_date                            : chr [1:10\".. #>   ..$ patent_num_foreign_documents_cited                          : int [1:100.. #>   ..$ patent_num_times_cited_by_us_patents                        : int [1:100.. #>   ..$ patent_num_total_documents_cited                            : int [1:100.. #>   ..$ patent_num_us_applications_cited                            : int [1:100.. #>   ..$ patent_num_us_patents_cited                                 : int [1:100.. #>   ..$ patent_processing_days                                      : int [1:100.. #>   ..$ patent_term_extension                                       : int [1:100.. #>   ..$ gov_interest_statement                                      : chr [1:100.. #>   ..$ patent_uspc_current_mainclass_average_patent_processing_days: logi [1:10.. #>   ..$ inventors                                                   :List of 1000 #>   ..$ wipo_kind                                                   : chr [1:10\".. #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 3,491,425"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"Accessing patent data with the patentsview package","text":"Let’s look quick example pulling analyzing patent data. ’ll look patents last ten years classified H04L63/00 CPC code. Patents area relate “network architectures network communication protocols separating internal external traffic.”3 CPC codes offer quick dirty way find patents interest, though getting sense hierarchy can tricky. Download data original blog’s query possible new version API, assignee_longitude assignee_latitude longer returned patent endpoint. ’ll use different endpoint slightly different query get latitudes longitudes plot. Now ’ll query assignee endpoint non-empty assignee_organization name, assignee_individual_name_first assignee_individual_name_last empty (query assignee entity, individual). sort assignee_num_patents descending ’ll get list prolific assignee_organizations See assignees coming (geographically)   Plot growth field’s topics time","code":"library(patentsview)  query <- with_qfuns( # with_qfuns is basically just: with(qry_funs, ...)   neq(\"assignee_organization\" = \"\") )  # Create a list of fields: # We request the fields we will use below rather than requesting them all and  # then filtering to get just the ones we want fields <- c(\"assignee_id\", \"assignee_organization\", \"assignee_num_patents\",    \"assignee_lastknown_latitude\", \"assignee_lastknown_longitude\")  # Send HTTP request to API's server: pv_res <- search_pv(endpoint = \"assignee\", query = query, fields = fields,     sort = c(\"assignee_num_patents\" = \"desc\"), all_pages = FALSE) library(leaflet) library(htmltools) library(dplyr) library(tidyr) library(stringr)  # My mom was an English teacher, so below we singularize/pluralize Patents # or maybe Patents:1 was ok?  Here, because of the sort, it will be unlikely # that there will be a single patent in our results.  data <-   pv_res$data$assignees %>%   mutate(popup = paste0(     \"<font color='Black'>\",     htmlEscape(assignee_organization), \"<br><br>Patent\",     ifelse(assignee_num_patents == 1, \":\", \"s:\"), # singular/plural     assignee_num_patents, \"<\/font>\"   )) %>%   filter_at(vars(assignee_lastknown_latitude, assignee_lastknown_longitude), any_vars(!is.na(.))) # seeing NA lats and longs  leaflet(data) %>%   addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%   addCircleMarkers(     lng = ~assignee_lastknown_longitude, lat = ~assignee_lastknown_latitude,     popup = ~popup, radius=2, color = \"yellow\"   ) library(ggplot2) library(RColorBrewer)  # Here we issue the original post's query, rewritten for the new version of the API # (note the field name change as well as it being nested inside the cpc_current object) # Oh, and we bumped the patent_year to give us data for the last ten years query <- with_qfuns( # with_qfuns is basically just: with(qry_funs, ...)   and(     begins(cpc_current.cpc_group_id = \"H04L63/02\"),     gte(patent_year = 2014)   ) )  # Create a list of fields: fields <- c(   c(\"patent_id\", \"patent_year\"),   get_fields(endpoint = \"patent\", groups = c(\"assignees\", \"cpc_current\")) )  pv_res <- search_pv(query = query, fields = fields, all_pages = TRUE)  # In the new version of the API, we don't get the CPC title back from the patent endpoint # we have to call, you guessed it, the cpc_group endpoint now qry <- qry_funs$begins(cpc_group_id = \"H04L63/02\") qry #> {\"_begins\":{\"cpc_group_id\":\"H04L63/02\"}}  cpc_info <- search_pv(query = qry, fields = get_fields(\"cpc_group\"), endpoint = \"cpc_group\")  # More API craziness, in the HATEOAS link from the patent endpoint, the separator is # inexplicably a colon.  In the data that comes back from the cpc_group endpoint, the # separator is, get this, a slash like it should be.  All that to say that joining # becomes a bit problematic or an exercise that makes dplyr wonder what we're up to.  data <-   pv_res$data$patents %>%   unnest(cpc_current) %>%   mutate(cpc_group = sub(\".*/([\\\\w:]+)/$\", \"\\\\1\", cpc_group, perl = TRUE)) %>% # unHATEOAS cpc_group, funky colon and all   filter(cpc_group != \"H04L63:02\") %>% # remove patents categorized into only top-level category of H04L63/02   mutate(cpc_group = sub(\":\", \"/\", cpc_group)) %>% # back to normality, ahead of a join   inner_join(cpc_info$data$cpc_groups, by = \"cpc_group_id\") %>%   ungroup() %>%   mutate(     title = case_when(       grepl(\"filtering\", .$cpc_group_title, ignore.case = T) ~         \"Filtering policies\",       .$cpc_group %in% c(\"H04L63/0209\", \"H04L63/0218\") ~         \"Architectural arrangements\",       grepl(\"Firewall traversal\", .$cpc_group_title, ignore.case = T) ~         \"Firewall traversal\",       TRUE ~         .$cpc_group_title     )   ) %>%   mutate(title = gsub(\".*(?=-)-\", \"\", title, perl = TRUE)) %>%   group_by(title, patent_year) %>%   count() %>%   ungroup()  max_year <- max(data$patent_year) y_limit <- max(data$n) + 100 - (max(data$n) %% 100) # even hundred past the max  ggplot(data = data) +   geom_smooth(aes(x = patent_year, y = n, colour = title), se = FALSE) +   scale_x_continuous(\"\\nGrant year\",     limits = c(2014, max_year),     breaks = 2014:max_year   ) +   scale_y_continuous(\"Patents\\n\", limits = c(0, y_limit)) +   scale_colour_manual(\"\", values = brewer.pal(5, \"Set2\")) +   theme_bw() + # theme inspired by https://hrbrmstr.github.io/hrbrthemes/   theme(panel.border = element_blank(), axis.ticks = element_blank()) +   theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"learning-more","dir":"Articles","previous_headings":"","what":"Learning more","title":"Accessing patent data with the patentsview package","text":"analysis examples go little depth, check data applications vignettes package’s website. ’re just interested search_pv(), examples site well. contribute package report issue, check issues page GitHub.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/ropensci-blog-post.html","id":"acknowledgments-from-the-original-blog-post","dir":"Articles","previous_headings":"","what":"Acknowledgments from the Original Blog Post","title":"Accessing patent data with the patentsview package","text":"’d like thank package’s two reviewers, Paul Oldham Verena Haunschmid, taking time review package providing helpful feedback. ’d also like thank Maëlle Salmon shepherding package along rOpenSci review process, well Scott Chamberlain Stefanie Butland miscellaneous help.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"on-the-plus-side","dir":"Articles","previous_headings":"","what":"On the Plus Side","title":"State of the API","text":"positive API changes: fields can queried now. 100,000 row result set size limit seems gone. Might part curse user might intended retrieve utility patents etc. new version API returns data types strings, e.g. application.rule_47_flag patent endpoint boolean. View(fieldsdf[grep('number|integer|boolean',fieldsdf$data_type),c(\"endpoint\",\"field\",\"data_type\")]) currently returns 90 rows still fields API returns strings cast-pv-data() casts appropriate data type1. fieldsdf$data_type set int bool fields. API team created Swagger UI page new version API. nice feature show Request URL GET request. Request URL can passed retrieve_linked_data see output R package, explained . POST request, show Curl command make request API. can helpful see exact return API, making possible tell results weren’t expected R package somehow misinterpreting . Joys Swagger UI","code":"library(patentsview)  # Count of non string, non date fields returned by the new version of the API nrow(fieldsdf[grep(\"number|integer|boolean\", fieldsdf$data_type), ]) ## [1] 90 print(fieldsdf[grep(\"bool$|int$\", fieldsdf$data_type), c(\"endpoint\", \"field\", \"data_type\")], row.names = FALSE) ##                        endpoint                    field data_type ##                        assignee            assignee_type       int ##                          patent  assignees.assignee_type       int ##  patent/us_application_citation citation_document_number       int ##                     publication  assignees.assignee_type       int ##                     publication             rule_47_flag      bool"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"issues","dir":"Articles","previous_headings":"","what":"Issues","title":"State of the API","text":"2024-11-06 API release seems intentionally changed paging patent_id, details original API’s sunset date currently February 12, 2025 though new version still issues new string case sensitivity, opened bug listed string vs full text operators, also opened bug listed . Note isn’t way distinguish strings full text fields OpenAPI object (limitation OpenAPI spec). may need change way fieldsdf generated need track operators can used, possibly parsing API’s endpoints page needing centralize information, fairly important things scattered across multiple pages: https://patentsview.org/classification ’s wipo endpoint’s data don’t think can found anywhere else: similar data cavaet Patent Text Publication Text endpoints may updated longer. Similarily, field shorthand notation little non-obvious behavior mentioned API team’s jupyter notebook mentioned . API Oddities requested fields ending _id come back without _id2 Ex patent endpoint requested inventors.inventor_id assignees.assignee_id returned inventors.inventor assignees.assignee, values respective HATEOAS links Two HATEOAS links use colon instead two URL parameters https://search.patentsview.org/api/v1/cpc_group/G01S7:4865/ https://search.patentsview.org/api/v1/uspc_subclass/403:57/ (endpoint currently throws 500) API key now required , intentionally, URLs aren’t clickable since API key sent, resulting 403 Forbidden response. Field inconsistencies two rule_47_flag fields, one returned patent endpoint one returned publication endpoint. former returned boolean, latter string cast-pv-data casts boolean.3 assignee_type, available three endpoints, returned string looks like ’re integer values4 document_number fields integers two returned strings cast-pv-data casts integers.5 Additional details g_claim returns exemplary values either “0” “1”. sure cast logicals. endpoints’ returns plural form singular endpoint two exceptions: Two endpoints, publication/rel_app_text patent/rel_app_text return entity named rel_app_texts though fields different. (former contains document_number later contains patent_id. field related_text.) exactly oddity, better place , ’s comparison old new attributes can sent API o: (options) parameter via search_pv() another -exactly--oddity, API’s sort patent_id, string field, gets funky mixing patent ids 10,000,000 (ones 10M come first). thing happens patent types, like reissue, ids different string lengths. See code block bottom understanding api vignette. Update: API now sorts ’d expect fairly high price. Now paging using patent_id, zero pad parameter 8 characters. Surprizingly, padded values never visible returned data. See Along lines, query currently returns 2,084,459 rows isn’t expected! (checked original version API .) {\"_and\":[{\"_gte\":{\"patent_id\":\"10\"}},{\"_lte\":{\"patent_id\":\"13\"}}]} oddities specific new version API, due source files make patentsview database. opened issues API bug PVS-1342 “Underlying data issues”, slighly diplomatic wording. ’s expectation ’d get results querying ppubs’ advanced search patentsview. Differences due disambiguation one thing, ’m expecting underlying data . One weirdest things approximately 8000 withdrawn patents patentsview database. source database bulk xml files US Patent Office releases weekly. problem sometimes patents withdrawn appearing bulk xml file kept patentsview database alongside non withdrawn patents. weird ? Patent Office’s withdrawn patent list, updated weekly. See test_that(“withdrawn patents still present database”) test-api-bugs.R equally strange situation approximately 300 non-withdrawn patents , whatever reason, appear bulk xml file week issued. granted patents patentsview database. See test_that(“missing patents still missing”) test-api-bugs.R Also, sure , aren’t design patents 1976-12-07 plant patents 1976-12-14 utility reissue patents starting 1976-01-066. See page Plant patents reissued patents current CPC assignments appropriate. problem bulk Cooperative Patent Classification file granted patents, produced USPTO quarterly, contains assignments utility patents. didn’t check assuming USPTO’s bulk CPC file applications contains current CPCs utility patents. patentsview database cpc_at_issue fields patents cpc_current fields utility patents. E.g., thousands plant patents A01H 5/02 one current CPCs ppubs yet none patentsview database. similar problem USPCs. US Patent stopped assigning utility patent 2015, favor CPCs. still used, however, plant patents, yet US Patent office stopped producing bulk file USPCs 2018. Plant patents uspc_at_issue fields set patentsview database, API uspc_current field. lack current CPCs USPCs plant patents means classification searches aren’t preformed version corresponding classification system. ’s page showing often CPC changes. ’s page shows USPC change orders stopped 2013. classification searches plant patents, may want use ppubs system.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"open-api-bugs","dir":"Articles","previous_headings":"","what":"Open API Bugs","title":"State of the API","text":"Weirdly, can view bugs ’ve submitted. Based digits reference number, ’m assuming open bugs. PVS-1109 fixed other_reference endpoint rejects default Swagger UI parameters (throws 400 Bad Request Error either reference_sequence reference_text requested) returns data patent_id requested. See test_that(“otherreferences endpoint still broken”) test-api-bugs.R Also, OpenAPI object says returned object other_references another exception singular endpoint/plural return pattern7. PVS-1125 fields OpenAPI object can requested See test_that(“field fieldsdf can retrieved”) test-api-bugs.R PVS-1147  Results case dependent now using implied explicit equals See test_that(“case sensitivity string equals”) test-api-bugs.R PVS-1155 fixed Documentation inconsistencies endpoint listed /api/v1/attorney/, /api/v1/patent/attorney GET/POST /api/v1/patent/attorney/{attorney_id}/ GET url parameter beta endpoints say GETs. Swagger UI page OpenAPI object say accept posts , work. PVS-1181 Improvement Suggestion isn’t data dictionary API like bulk download files. specific question difference patent_earliest_application_date application.filing_date returned new patent endpoint. questions values assignees.assignee_type field represent, integers field received integer rather string? Another question g_claims’ exemplary represent? values seem either “0” “1”. minimum, ’d like see glossary updated https://patentsview.org/glossary PVS-1218 openapi.json errors Fixed: “publication”,“us_parties.applicant_authority” type “keyword” “string” two rule_47_flag fields, one boolean (line 7019), string (line 8004) document_numbers integers citation_document_number patent/us_application_citation string. document_number publication/rel_app_text now correctly coming back integer. PVS-1306 fixed API accepts invalid fields API accepts invalid fields start looking like valid fields throw error. Ex f: [“patent_iddddddddddddd”, “patent_dateagogo”] q: {“patent_idd”:“10000000”} result: { “error”: false, “count”: 0, “total_hits”: 0, “patents”: [] } See test_that(“invalid fields accepted”) test-api-bugs.R PVS-1342 Underlying data issues ~300 issued patents missing database, ~8000 withdrawn patents present database, plant patents reissued patents don’t current CPC assigments applicable. didn’t check assuming bulk CPC file applications publication endpoint issue. (’s detail last API oddity) PVS-1377 sort field doesn’t accept unnested fields API throws errors fields specified sort, e.g. patent_title patent endpoint. 39 endpoint/field pairs currently fail. See test_that(“can’t sort fields”) test-api-bugs.R Unknown Reference Number sort field needs specified paging results. mentioned bug API’s forum. causes awkardness search_pv (add sort field primary key included fields. Awkard fields specified) PVS-1435Paging seems changed recent API release test_that(“‘’ parameter works properly”) test-search-pv.R broke, paging vignette. first requests total_hits 3003 1000 rows returned subsequent requests return 399 rows set ‘’ parameter unaltered value last patent_id received. ’s new reality: : parameter value patent_id, needs padded 8 characters. E.g. “6010555” needs submitted {\"\": \"06010555\"}, “RE36479” needs become {\"\": \"RE036479\"}. seems intentional change sorting patent_id doesn’t behave oddly 10,000,000 (leading 1 put anything 10M anything 10M). result, sorting/paging patent_id now requires padding. Oh, R package new method, pad_patent_id() need pad patent_ids. See Example 1 Result Set Paging vignette","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"state-of-the-r-package","dir":"Articles","previous_headings":"","what":"State of the R Package","title":"State of the API","text":"Three new methods added R package reworked ropensci post explains changes made since assignee latitude longitude longer available patent endpoint. new vignette, inspired API team’s jupyter notebook, created showing two things mentions API now R package allow nested attributes wildcarded, group’s name retrieve group’s nested fields. Oddly, unnested attributes requested way, e.g. unnested attributes patent endpoint need called , rather requesting “patents” field. applying multiple conditions related-entity fields endpoints now singular, match API’s change. new endpoints nested patent/ one nested publication/, also matching API’s change covers, httr changed httr2 (see several mentions ). matters users passed additional arguments (…) search_pv(). Previously passed config = httr::timeout(40) ’d now pass timeout = 40 (name-value pairs valid curl options, found curl::curl_options()) Now R package using httr2, users can make use last_request() method see sent API. useful trying fix invalid request. Note all_pages = TRUE R package changes sort parameter (details ) sets ‘’ options parameter request shown might ’d expect . Also fun, useful, reporting bug, seeing raw API response. Package contributor specific changes Changed httr httr2 httr says ’s superseded httr2 ’s trying put us business handling 429 retries etc. See Wrapping APIs vignette github repo set deliver https://mustberuss.r-universe.dev/patentsview. new version R package can installed viainstall.packages('patentsview', repos = c('https://mustberuss.r-universe.dev')) new implementation paging PR discussion paging primary sort. also new vignette API’s new mechanism page result set (per_page page parameters replaced size ). R package unit tests skips negative tests API bugs still exist (’ll fail bugs fixed). possible tech note new package ready mentions shown updated Top Assignees vignette, occasions now multiple API calls needed retrieve data single API call original version API R package. workflow (R-CMD-check.yaml) updated get rid deprecated warnings Added vignettes/build_some.R half render one vignettes development Added bootstrap: 5 _pkgdown.yml search box display (Maëlle’s PR) R package handles throttling, new version API now imposes data-raw/fieldsdf.R working ! hard-coding can removed bugs fixed. may need retain hard-coding, see comments data-raw/fieldsdf.R renamed test-arg-validation.R test-validate-args.R code coverage match Possible Package Improvements version number bumped 1.0.0 since breaking API changes (singular endpoints addition API key). validate-args.R version specific code may need modifying. draft release look something like : Result set size seems unbounded now. warn query return 100,000 rows all_pages = TRUE? maybe add max_rows search_pv()? get_fields() search_pv() throw specialized error plural endpoint passed Add issue template warns users share API key Add contributing.md something explains build everything, something like Findings/Contributor 101 Navigation vignettes better, possible tech note added nav? sure monster comment search_pv.R trying explain new way paging. Possibly just say see new api paging vignette? httr2 improvements Currently requests set retried 19 times httr2::req_retry(max_tries = 20) reasonable number? 429 errors can occur user runs single program time, like half rendering devtools::test() running running anything locally action running repo push. Errors occur retries recursive, whether intended ! Can throttled test detect output stdout etc? used expect_message “API’s requests per minute limit reached.” Now “Waiting 45s retry backoff” appears doesn’t satisfy expect_message(). Currently ’s using system.time() assert 50 transactions took 60 seconds, implying throttling occurred.","code":"# top level/unnested attributes at the patent endpoint    get_fields(\"patent\", groups = \"patents\") ##  [1] \"gov_interest_statement\"                                       ##  [2] \"patent_abstract\"                                              ##  [3] \"patent_cpc_current_group_average_patent_processing_days\"      ##  [4] \"patent_date\"                                                  ##  [5] \"patent_detail_desc_length\"                                    ##  [6] \"patent_earliest_application_date\"                             ##  [7] \"patent_id\"                                                    ##  [8] \"patent_num_foreign_documents_cited\"                           ##  [9] \"patent_num_times_cited_by_us_patents\"                         ## [10] \"patent_num_total_documents_cited\"                             ## [11] \"patent_num_us_applications_cited\"                             ## [12] \"patent_num_us_patents_cited\"                                  ## [13] \"patent_processing_days\"                                       ## [14] \"patent_term_extension\"                                        ## [15] \"patent_title\"                                                 ## [16] \"patent_type\"                                                  ## [17] \"patent_uspc_current_mainclass_average_patent_processing_days\" ## [18] \"patent_year\"                                                  ## [19] \"wipo_kind\" # all attributes at the patent endpoint using the new group shorthand    # the first 19 are the unnested attributes, the remaining ones are group names    get_fields(\"patent\") ##  [1] \"gov_interest_statement\"                                       ##  [2] \"patent_abstract\"                                              ##  [3] \"patent_cpc_current_group_average_patent_processing_days\"      ##  [4] \"patent_date\"                                                  ##  [5] \"patent_detail_desc_length\"                                    ##  [6] \"patent_earliest_application_date\"                             ##  [7] \"patent_id\"                                                    ##  [8] \"patent_num_foreign_documents_cited\"                           ##  [9] \"patent_num_times_cited_by_us_patents\"                         ## [10] \"patent_num_total_documents_cited\"                             ## [11] \"patent_num_us_applications_cited\"                             ## [12] \"patent_num_us_patents_cited\"                                  ## [13] \"patent_processing_days\"                                       ## [14] \"patent_term_extension\"                                        ## [15] \"patent_title\"                                                 ## [16] \"patent_type\"                                                  ## [17] \"patent_uspc_current_mainclass_average_patent_processing_days\" ## [18] \"patent_year\"                                                  ## [19] \"wipo_kind\"                                                    ## [20] \"applicants\"                                                   ## [21] \"application\"                                                  ## [22] \"assignees\"                                                    ## [23] \"attorneys\"                                                    ## [24] \"botanic\"                                                      ## [25] \"cpc_at_issue\"                                                 ## [26] \"cpc_current\"                                                  ## [27] \"examiners\"                                                    ## [28] \"figures\"                                                      ## [29] \"foreign_priority\"                                             ## [30] \"gov_interest_contract_award_numbers\"                          ## [31] \"gov_interest_organizations\"                                   ## [32] \"granted_pregrant_crosswalk\"                                   ## [33] \"inventors\"                                                    ## [34] \"ipcr\"                                                         ## [35] \"pct_data\"                                                     ## [36] \"us_related_documents\"                                         ## [37] \"us_term_of_grant\"                                             ## [38] \"uspc_at_issue\"                                                ## [39] \"wipo\" # all attributes at the patent endpoint, fully qualified.  With a modest query this can    # be too much to send via a GET request    fieldsdf[fieldsdf$endpoint == \"patent\", \"field\"] ##   [1] \"applicants.applicant_designation\"                             ##   [2] \"applicants.applicant_name_first\"                              ##   [3] \"applicants.applicant_name_last\"                               ##   [4] \"applicants.applicant_organization\"                            ##   [5] \"applicants.applicant_sequence\"                                ##   [6] \"applicants.applicant_type\"                                    ##   [7] \"applicants.location_id\"                                       ##   [8] \"application.application_id\"                                   ##   [9] \"application.application_type\"                                 ##  [10] \"application.filing_date\"                                      ##  [11] \"application.filing_type\"                                      ##  [12] \"application.rule_47_flag\"                                     ##  [13] \"application.series_code\"                                      ##  [14] \"assignees.assignee_id\"                                        ##  [15] \"assignees.assignee_city\"                                      ##  [16] \"assignees.assignee_country\"                                   ##  [17] \"assignees.assignee_individual_name_first\"                     ##  [18] \"assignees.assignee_individual_name_last\"                      ##  [19] \"assignees.assignee_organization\"                              ##  [20] \"assignees.assignee_sequence\"                                  ##  [21] \"assignees.assignee_state\"                                     ##  [22] \"assignees.assignee_type\"                                      ##  [23] \"attorneys.attorney_id\"                                        ##  [24] \"attorneys.attorney_name_first\"                                ##  [25] \"attorneys.attorney_name_last\"                                 ##  [26] \"attorneys.attorney_organization\"                              ##  [27] \"attorneys.attorney_sequence\"                                  ##  [28] \"botanic.latin_name\"                                           ##  [29] \"botanic.variety\"                                              ##  [30] \"cpc_at_issue.cpc_class\"                                       ##  [31] \"cpc_at_issue.cpc_class_id\"                                    ##  [32] \"cpc_at_issue.cpc_group\"                                       ##  [33] \"cpc_at_issue.cpc_group_id\"                                    ##  [34] \"cpc_at_issue.cpc_section\"                                     ##  [35] \"cpc_at_issue.cpc_sequence\"                                    ##  [36] \"cpc_at_issue.cpc_subclass\"                                    ##  [37] \"cpc_at_issue.cpc_subclass_id\"                                 ##  [38] \"cpc_at_issue.cpc_type\"                                        ##  [39] \"cpc_current.cpc_class\"                                        ##  [40] \"cpc_current.cpc_class_id\"                                     ##  [41] \"cpc_current.cpc_group\"                                        ##  [42] \"cpc_current.cpc_group_id\"                                     ##  [43] \"cpc_current.cpc_section\"                                      ##  [44] \"cpc_current.cpc_sequence\"                                     ##  [45] \"cpc_current.cpc_subclass\"                                     ##  [46] \"cpc_current.cpc_subclass_id\"                                  ##  [47] \"cpc_current.cpc_type\"                                         ##  [48] \"examiners.art_group\"                                          ##  [49] \"examiners.examiner_first_name\"                                ##  [50] \"examiners.examiner_id\"                                        ##  [51] \"examiners.examiner_last_name\"                                 ##  [52] \"examiners.examiner_role\"                                      ##  [53] \"figures.num_figures\"                                          ##  [54] \"figures.num_sheets\"                                           ##  [55] \"foreign_priority.filing_date\"                                 ##  [56] \"foreign_priority.foreign_application_id\"                      ##  [57] \"foreign_priority.foreign_country_filed\"                       ##  [58] \"foreign_priority.priority_claim_kind\"                         ##  [59] \"foreign_priority.priority_claim_sequence\"                     ##  [60] \"gov_interest_contract_award_numbers.award_number\"             ##  [61] \"gov_interest_organizations.fedagency_name\"                    ##  [62] \"gov_interest_organizations.level_one\"                         ##  [63] \"gov_interest_organizations.level_three\"                       ##  [64] \"gov_interest_organizations.level_two\"                         ##  [65] \"gov_interest_statement\"                                       ##  [66] \"granted_pregrant_crosswalk.application_number\"                ##  [67] \"granted_pregrant_crosswalk.document_number\"                   ##  [68] \"inventors.inventor_id\"                                        ##  [69] \"inventors.inventor_city\"                                      ##  [70] \"inventors.inventor_country\"                                   ##  [71] \"inventors.inventor_name_first\"                                ##  [72] \"inventors.inventor_name_last\"                                 ##  [73] \"inventors.inventor_sequence\"                                  ##  [74] \"inventors.inventor_state\"                                     ##  [75] \"ipcr.ipc_action_date\"                                         ##  [76] \"ipcr.ipc_class\"                                               ##  [77] \"ipcr.ipc_classification_data_source\"                          ##  [78] \"ipcr.ipc_classification_value\"                                ##  [79] \"ipcr.ipc_id\"                                                  ##  [80] \"ipcr.ipc_main_group\"                                          ##  [81] \"ipcr.ipc_section\"                                             ##  [82] \"ipcr.ipc_sequence\"                                            ##  [83] \"ipcr.ipc_subclass\"                                            ##  [84] \"ipcr.ipc_subgroup\"                                            ##  [85] \"ipcr.ipc_symbol_position\"                                     ##  [86] \"patent_abstract\"                                              ##  [87] \"patent_cpc_current_group_average_patent_processing_days\"      ##  [88] \"patent_date\"                                                  ##  [89] \"patent_detail_desc_length\"                                    ##  [90] \"patent_earliest_application_date\"                             ##  [91] \"patent_id\"                                                    ##  [92] \"patent_num_foreign_documents_cited\"                           ##  [93] \"patent_num_times_cited_by_us_patents\"                         ##  [94] \"patent_num_total_documents_cited\"                             ##  [95] \"patent_num_us_applications_cited\"                             ##  [96] \"patent_num_us_patents_cited\"                                  ##  [97] \"patent_processing_days\"                                       ##  [98] \"patent_term_extension\"                                        ##  [99] \"patent_title\"                                                 ## [100] \"patent_type\"                                                  ## [101] \"patent_uspc_current_mainclass_average_patent_processing_days\" ## [102] \"patent_year\"                                                  ## [103] \"pct_data.application_kind\"                                    ## [104] \"pct_data.pct_102_date\"                                        ## [105] \"pct_data.pct_371_date\"                                        ## [106] \"pct_data.pct_doc_number\"                                      ## [107] \"pct_data.pct_doc_type\"                                        ## [108] \"pct_data.published_filed_date\"                                ## [109] \"us_related_documents.published_country\"                       ## [110] \"us_related_documents.related_doc_kind\"                        ## [111] \"us_related_documents.related_doc_number\"                      ## [112] \"us_related_documents.related_doc_published_date\"              ## [113] \"us_related_documents.related_doc_sequence\"                    ## [114] \"us_related_documents.related_doc_status\"                      ## [115] \"us_related_documents.related_doc_type\"                        ## [116] \"us_related_documents.wipo_kind\"                               ## [117] \"us_term_of_grant.disclaimer_date\"                             ## [118] \"us_term_of_grant.term_disclaimer\"                             ## [119] \"us_term_of_grant.term_extension\"                              ## [120] \"us_term_of_grant.term_grant\"                                  ## [121] \"uspc_at_issue.uspc_mainclass\"                                 ## [122] \"uspc_at_issue.uspc_mainclass_id\"                              ## [123] \"uspc_at_issue.uspc_sequence\"                                  ## [124] \"uspc_at_issue.uspc_subclass\"                                  ## [125] \"uspc_at_issue.uspc_subclass_id\"                               ## [126] \"wipo.wipo_field\"                                              ## [127] \"wipo.wipo_field_id\"                                           ## [128] \"wipo.wipo_sequence\"                                           ## [129] \"wipo_kind\" print(unique(fieldsdf[grep(\"/\", fieldsdf$endpoint), \"endpoint\"]), row.names = FALSE) ## [1] \"patent/attorney\"                \"patent/foreign_citation\"        ## [3] \"patent/other_reference\"         \"patent/rel_app_text\"            ## [5] \"patent/us_application_citation\" \"patent/us_patent_citation\"      ## [7] \"publication/rel_app_text\" httr2::last_request() httr2::last_response() httr2::last_response() |> httr2::resp_body_json()"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"worth-monitoring","dir":"Articles","previous_headings":"","what":"Worth Monitoring","title":"State of the API","text":"bergant/rapiclient new maintainer ’s favor supporting OpenAPI v3 though thinks warrant new package. R version fieldsdf creator working ! uses rapiclient expecting read Swagger/OpenAPI v2 object (patentsview object OpenAPI v3). throws warning seems work otherwise.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"findingscontributor-101","dir":"Articles","previous_headings":"","what":"Findings/Contributor 101","title":"State of the API","text":"Helpful info ’ve forked https://github.com/ropensci/patentsview API related Updated versions new API unannounced part, maybe three four week release cycle, often Saturdays. head requests time time API’s OpenAPI object detect Last-Modified changes. changes, back data-raw/fieldsdf.csv, run data-raw/fieldsdf.R compare backed fieldsdf.csv new one see , anything, changed. (seems update openapi.json release, whether changed .) change, ’ll local build incorporate changed fieldsdf. Either way (openapi.json changed ), ’ll run tests see fail, especially noting test_that(“endpoints stable”) fails, indicting changes endpoints. ’ll push changes needed keep R package working tests passing, sometimes half rendering vignettes affected change. Quarterly ’ll update https://patentsview.org/release-notes Request API key, report API suggestions/bugs etc Community -> Support using nav patentsview.org. Now endpoints documented single page. query language also page. Originally separate page query language endpoint page. patentsview forum isn’t terribly active ’s worth keeping eye https://patentsview.org/forum Locally Build install local code devtools::install('.') can also full blown local build ’ll need clean afterwards (delete gz patentsview.Rcheck directory). runs things github action runs pushes ropensci/patentsview (including running tests skip_on_cran() TRUE) can useful catch missing skip_on_cran()’s undocumented parameters etc. Without ---manual ’ll try create pdf documentation, can fail pdflatex available. ’s probably good idea run without PATENTSVIEW_API_KEY environment. rscript data-raw/fieldsdf.R run fieldsdf creator locally. parses Patentsview OpenAPI object produce fieldsdf.csv fieldsdf.rda Local Testing devtools::test() run tests tests/testthat/ devtools::test(filter=“utils”) just run just test-utils.R note add new test methods, must start skip_on_cran() builds fail r-universe (see Optional ) eventually CRAN. Half building vignettes locally - see vignettes/README.md need phantomjs path windows least see comments vignettes/build_some.R pkgdown locally pkgdown::build_articles() see local changes half-rendered vignettes may want run individual methods pkgdown::build_site() wrapper init_site() build_home() build_reference() build_articles() build_tutorials() build_news() build_redirects() build reference pages locally make changes method documentation, rundevtools::document()pkgdown::build_reference() see README.Rmd changes locally Run code coverage locally whole package: devtools::test_coverage() devtools::test_coverage(function_exclusions = \"\\\\.onLoad\") individual file: devtools::test_coverage_active_file(file = \"R/print.R\") ’d need covr installed needed set environmental variable CHROMOTE_HEADLESS=newFrom > Note chromote 0.3.1, can opt using new headless mode setting Needed showed Rmd files #> Old Headless mode removed Chrome binary. Please use new Headless mode (https://developer.chrome.com/docs/chromium/new-headless) chrome-headless-shell standalone implementation old Headless mode (https://developer.chrome.com/blog/chrome-headless-shell). * Remotely pkgdown remotely can set github pages repo display vignettes man pages, e.g. https://github.com/mustberuss/patentsview Remote Testing can put API key repo Repository secret tests run push changes. E.g., PATENTSVIEW_API_KEY set https://github.com/mustberuss/patentsview/settings/secrets/actions (though settings aren’t publicly viewable) push make sure following Tidyverse style guide. plugins keep stylish styler::style_pkg(\".\", dry = \"fail\") styler::style_file('path/file') necessary use plugin etc make sure examples still run devtools::run_examples(run_dontrun = TRUE) check spelling using devtools::spell_check(pkg = \".\", vignettes = TRUE, use_wordlist = TRUE) Locally unchecked inst/WORDLIST additional words allow (one word per line) see https://devtools.r-lib.org/reference/spell_check.html Optional can set r-universe creating special github repo, explained . E.g., https://github.com/mustberuss/mustberuss.r-universe.dev https://github.com/mustberuss/mustberuss.r-universe.dev/blob/master/packages.json See article newer repo naming convention Notes ’s good idea review action logs, even successful builds. can warnings long lines etc. default, patentsview r-universe https://ropensci.r-universe.dev/patentsview Someone really smart write python library API! Questions: way set notifications r-universe build failures? miss skip_on_cran(), tests work repo (API key repo secret) build silently fail r-universe. Don’t ask know . don’t vignettes show r-universe? articles link grayed . Ah, build shows Build pkgdown site (ropensci ) skipped add row_limit something? ’d page way stop row_limit met. someone wanting 1000 rows necessarily rows, especially since isn’t 100,000 row limitation now. API’s now exposed search_pv() users paging. See new paging vignette","code":"system(\"R CMD build .\")    system(\"R CMD check patentsview_0.3.0.tar.gz --no-manual\") knitr::knit(\"README.Rmd\", \"README.md\") pkgdown::build_home()"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/state-of-the-api.html","id":"odd-demo","dir":"Articles","previous_headings":"","what":"Odd Demo","title":"State of the API","text":"demonstrate weird interaction API R package sort parmeter specified. Note first patent_date returned “2020-04-21” gets sent API &s=[]&o= Now ’ll send GET &s=&o see API return different, seemingly applying default sort? POSTs GETs behaved differently sort wasn’t specified. Currently API bug prevents seeing behavior POSTS.","code":"fields <- c(\"patent_id\", \"patent_date\", \"patent_title\")  search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}',   endpoint = \"patent\", fields = fields ) ## $data ## #### A list with a single data frame on patents level: ##  ## List of 1 ##  $ patents:'data.frame': 1000 obs. of  3 variables: ##   ..$ patent_id   : chr [1:1000] \"7155746\" ... ##   ..$ patent_title: chr [1:1000] \"Anti-wicking protective workwear and method\".. ##   ..$ patent_date : chr [1:1000] \"2007-01-02\" ... ##  ## $query_results ## #### Distinct entity counts across all downloadable pages of output: ##  ## total_hits = 5,547,663 url <- httr2::last_request()$url cat(utils::URLdecode(url)) ## https://search.patentsview.org/api/v1/patent/?q={\"_gte\":{\"patent_date\":\"2007-01-01\"}}&f=[\"patent_id\",\"patent_date\",\"patent_title\"]&s=&o={\"size\":1000} library(httr2)    url <- sub(\"&s=\\\\[\\\\]\", \"&s=\", url)   cat(utils::URLdecode(url)) ## https://search.patentsview.org/api/v1/patent/?q={\"_gte\":{\"patent_date\":\"2007-01-01\"}}&f=[\"patent_id\",\"patent_date\",\"patent_title\"]&s=&o={\"size\":1000} api_key <- Sys.getenv(\"PATENTSVIEW_API_KEY\")    req <- httr2::request(url) |>     httr2::req_method(\"GET\")    resp <- req |>     httr2::req_user_agent(\"https://github.com/ropensci/patentsview\") |>     httr2::req_retry(max_tries = 20) |> # automatic 429 Retry-After     httr2::req_headers(\"X-Api-Key\" = api_key, .redact = \"X-Api-Key\") |>     httr2::req_perform()    json <- httr2::last_response() |> httr2::resp_body_json()   json$patents[[1]] ## $patent_id ## [1] \"7155746\" ##  ## $patent_title ## [1] \"Anti-wicking protective workwear and methods of making and using same\" ##  ## $patent_date ## [1] \"2007-01-02\""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/understanding-the-api.html","id":"fields-shorthand","dir":"Articles","previous_headings":"","what":"Fields Shorthand","title":"Understanding the API","text":"notebook starts fairly fluffy things really get interesting really quickly. See “constructing query”, don’t remember seeing anywhere else: endpoints contain groups fields representing related entities connected one endpoint’s primary entity type; example, patent endpoint contains field “inventors”, contains information inventors associated given patent. fields related entities can requested API request’s fields parameter group using group name fields parameter, individually specifying required field “{entity_type}.{subfield}”. Mind blown, can, example, request nested application fields patent endpoint simply requesting “application” fields list. new version R package let users leverage feature, allowing group names specified fields parameter. motivation adopt API’s shorthand , modest query, explicitly requesting patent endpoint’s fields can much send via GET request (resulting URL can exceed 4K).","code":"library(patentsview)  query <- qry_funs$eq(patent_id = \"10568228\") shorthand_results <- search_pv(query, fields = c(\"application\"), method = \"POST\")  # Now that the R package uses httr2, we can use its last_request() # to see what was POSTed to the API cat(httr2::last_request()$body$data) #> {\"q\":{\"_eq\":{\"patent_id\":\"10568228\"}},\"f\":[\"application\"],\"s\":[],\"o\":{\"size\":1000}}  # Here we view the results shorthand_results$data$patent$application #> [[1]] #>   application_id application_type filing_date series_code rule_47_flag #> 1      15/995745               15  2018-06-01          15        FALSE #>   filing_type #> 1          15  # Now we'll try to explicitly request all the application fields and make a POST to the API explicit_fields <- get_fields(\"patent\", groups = \"application\") explicit_fields #> [1] \"application.application_id\"   \"application.application_type\" #> [3] \"application.filing_date\"      \"application.filing_type\"      #> [5] \"application.rule_47_flag\"     \"application.series_code\" explicit_results <- search_pv(query, fields = explicit_fields, method = \"POST\")  # but the R package figured out that the shorthand could be used instead # so what was POSTed to the API is the same! cat(httr2::last_request()$body$data) #> {\"q\":{\"_eq\":{\"patent_id\":\"10568228\"}},\"f\":[\"application\"],\"s\":[],\"o\":{\"size\":1000}}  # and, of course, the results from the API are the same explicit_results$data$patent$application #> [[1]] #>   application_id application_type filing_date series_code rule_47_flag #> 1      15/995745               15  2018-06-01          15        FALSE #>   filing_type #> 1          15  # (Observation reported to the API team: application_type, series_code and filing_type # all seem to have the same values and not just in this one example.)"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/understanding-the-api.html","id":"unexpected-results","dir":"Articles","previous_headings":"","what":"Unexpected Results","title":"Understanding the API","text":", wasn’t enough, non-obvious behavior appears second bullet point “Queries using related entity fields” header: applying multiple conditions related-entity fields, central entity record returned combination related entities satisfy conditions. example, use George Washington inventor. Humorously, modern inventors name! Abraham Lincoln also used inventor. Good ol’ Abe US president far receive patent ’s early patentsview database modern Abraham Lincolns found inventors. demonstrate API’s -exactly-intuitive behavior, ’ll keep George inventor substitute Thomas Jefferson Abe, inventors going famous name, though aren’t nickels two dollar bills US. rows act ’d expect, like patent 4078607’s Thomas Jefferson. others, two inventors combine meet search cititeria, like 6905071’s Thomas Amundsen Matthew Jefferson. might match didn’t intend. Now ’ll hit inventor endpoint similar query, jupyter notebook suggests. Now, actual_inventors’ inventor_ids hand, ’ll ask patent endpoint patents. results quite different first query returned. (patents names matching least one two famous forefather’s names. first query unintuitively matched names first last name matches necessarily occur inventor.)","code":"library(dplyr)  patents_query <-    with_qfuns(     or(       and(         text_phrase(inventors.inventor_name_first = \"George\"),         text_phrase(inventors.inventor_name_last = \"Washington\")       ),       and(         text_phrase(inventors.inventor_name_first = \"Thomas\"),         text_phrase(inventors.inventor_name_last = \"Jefferson\")       )     )   )  patent_fields <-c(\"patent_id\", \"inventors.inventor_name_first\", \"inventors.inventor_name_last\") pat_res <- search_pv(patents_query, fields=patent_fields, endpoint=\"patent\") dl <- unnest_pv_data(pat_res$data)  # We got back all the inventors on the patents that met our search criteria.  We'll filter out # the inventors that didn't strictly meet our criteria (they're coinventors that came along for  # the ride with the ones that met our criteria), we want the noted behavior to be clear.  display_inventors <-     dl$inventors %>%    filter(grepl(\"^(George|Thomas)\", inventor_name_first ) | grepl(\"^(Washington|Jefferson)\", inventor_name_last))  display_inventors #>    patent_id inventor_name_first inventor_name_last #> 1   10568228      George Elliott         Washington #> 2   10664808                Joel         Washington #> 3   11032709           Thomas J.             Bonola #> 4   11032709             Lorri L          Jefferson #> 5   10180440          Stanley T.          Jefferson #> 6   10180440              Thomas                FAY #> 7    4104193              Thomas          Jefferson #> 8    4078607              Thomas          Jefferson #> 9   10374815           Thomas J.             Bonola #> 10  10374815             Lorri L          Jefferson #> 11   5736046              George         Washington #> 12   5914971           George E.         Burke, Jr. #> 13   5914971           Rodney B.         Washington #> 14   5897817              George         Washington #> 15   5643452              George         Washington #> 16   5645778              George         Washington #> 17   6218441              George         Washington #> 18   7971908              Thomas              Tilly #> 19   7971908           Thomas M.           DiMambro #> 20   7971908           Alfred A.          Jefferson #> 21   7598629           George E.         Burke, Jr. #> 22   7598629           Rodney B.         Washington #> 23   8347213           Thomas M.            Clifton #> 24   8347213          Bradley C.          Jefferson #> 25   8717367           Thomas M.            Clifton #> 26   8717367          Bradley C.          Jefferson #> 27   7144505              George         Washington #> 28   6881337              George         Washington #> 29   6905071              Thomas           Amundsen #> 30   6905071              George              Kolis #> 31   6905071             Matthew          Jefferson inventors_query <-    with_qfuns(     or(       and(         text_phrase(inventor_name_first = \"George\"),         text_phrase(inventor_name_last = \"Washington\")       ),       and(         text_phrase(inventor_name_first = \"Thomas\"),         text_phrase(inventor_name_last = \"Jefferson\")       )     )   )  inventor_fields <- c(\"inventor_id\",\"inventor_name_first\",\"inventor_name_last\") inventor_res <- search_pv(inventors_query, fields=inventor_fields, endpoint=\"inventor\") actual_inventors <- unnest_pv_data(inventor_res$data)  actual_inventors[[1]] #>             inventor_id inventor_name_first inventor_name_last #> 1 fl:ge_ln:washington-4              George         Washington #> 2 fl:ge_ln:washington-5      George Elliott         Washington #> 3  fl:th_ln:jefferson-1              Thomas          Jefferson id_query <- qry_funs$eq(inventors.inventor_id=actual_inventors$inventors$inventor_id)  patent_fields <-c(\"patent_id\", \"inventors.inventor_name_first\", \"inventors.inventor_name_last\",   \"inventors.inventor_id\") pat_res <- search_pv(id_query, fields=patent_fields, sort=c(patent_id = \"asc\"))  dl <- unnest_pv_data(pat_res$data)  # we'll repeat the same name filter we used on the first query's results display_inventors <-     dl$inventors %>%    filter(grepl(\"^(George|Thomas)\", inventor_name_first ) | grepl(\"^(Washington|Jefferson)\", inventor_name_last)) %>%    mutate(inventor = sub(\".*/([^/]+)/$\", \"\\\\1\", inventor)) # extract id from HATEOAS link  # sample pre-mutate value, note that we requested inventor_id but the API sent back `inventor` dl$inventors$inventor[[1]] #> [1] \"https://search.patentsview.org/api/v1/inventor/fl:wa_ln:carter-1/\"  display_inventors #>    patent_id              inventor inventor_name_first inventor_name_last #> 1    4078607  fl:th_ln:jefferson-1              Thomas          Jefferson #> 2    4104193  fl:th_ln:jefferson-1              Thomas          Jefferson #> 3    5643452 fl:ge_ln:washington-4              George         Washington #> 4    5645778 fl:ge_ln:washington-4              George         Washington #> 5    5736046 fl:ge_ln:washington-4              George         Washington #> 6    5897817 fl:ge_ln:washington-4              George         Washington #> 7    6218441 fl:ge_ln:washington-4              George         Washington #> 8    6881337 fl:ge_ln:washington-4              George         Washington #> 9    7144505 fl:ge_ln:washington-4              George         Washington #> 10  10568228 fl:ge_ln:washington-5      George Elliott         Washington"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/understanding-the-api.html","id":"acknowledgment","dir":"Articles","previous_headings":"","what":"Acknowledgment","title":"Understanding the API","text":", credit goes Patentsview API team creating cited jupyter notebook. just portions R package form. repo doesn’t stated license checked, told: repo license looking GNU General Public License v3 (GPL3). license R don’t think ’ve violated anything. extra fun check Russ’ fork ’s python code retrieving Mr. Jefferson’s patents etc. reply asked ’d receptive PR.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/writing-queries.html","id":"three-ways-to-write-the-same-query","dir":"Articles","previous_headings":"","what":"Three ways to write the same query","title":"Writing queries","text":"Let’s say want find patents published last 10 years word “dog” titles abstracts, whose assignees located either US Canada. three ways write query: Use string: Use list: Use patentsview domain specific language (DSL):","code":"query_v_1 <-   '{\"_and\":[           {\"_gte\":{\"patent_date\":\"2007-03-01\"}},           {\"_or\":[             {\"_contains\":{\"patent_title\":\"dog\"}},             {\"_text_all\":{\"patent_abstract\":\"dog\"}}           ]},           {\"_or\":[             {\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},             {\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}           ]}   ]}' query_v_2 <-    list(\"_and\" =         list(           list(\"_gte\" = list(patent_date = \"2007-03-01\")),           list(\"_or\" =                   list(                    list(\"_contains\" = list(patent_title = \"dog\")),                    list(\"_text_all\" = list(patent_abstract = \"dog\"))                    )                ),           list(\"_or\" =                   list(                    list(\"_text_phrase\" = list(inventors.inventor_country = \"US\")),                    list(\"_text_phrase\" = list(inventors.inventor_country = \"CA\"))                    )                )       )   ) library(patentsview)  query_v_3 <-    with_qfuns(     and(       gte(patent_date = \"2007-03-01\"),       or(         contains(patent_title = \"dog\"),         text_all(patent_abstract = \"dog\")       ),       or(         text_phrase(inventors.inventor_country = \"US\"),         text_phrase(inventors.inventor_country = \"CA\")       )     )   )"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/writing-queries.html","id":"why-use-the-dsl","dir":"Articles","previous_headings":"","what":"Why use the DSL?","title":"Writing queries","text":"can see three versions query shown equivalent: …ever want use method 3 methods 1 2? two main reasons:","code":"jsonlite::minify(query_v_1) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-03-01\"}},{\"_or\":[{\"_contains\":{\"patent_title\":\"dog\"}},{\"_text_all\":{\"patent_abstract\":\"dog\"}}]},{\"_or\":[{\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},{\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}]}]} jsonlite::toJSON(query_v_2, auto_unbox = TRUE) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-03-01\"}},{\"_or\":[{\"_contains\":{\"patent_title\":\"dog\"}},{\"_text_all\":{\"patent_abstract\":\"dog\"}}]},{\"_or\":[{\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},{\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}]}]} jsonlite::toJSON(query_v_3, auto_unbox = TRUE) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-03-01\"}},{\"_or\":[{\"_contains\":{\"patent_title\":\"dog\"}},{\"_text_all\":{\"patent_abstract\":\"dog\"}}]},{\"_or\":[{\"_text_phrase\":{\"inventors.inventor_country\":\"US\"}},{\"_text_phrase\":{\"inventors.inventor_country\":\"CA\"}}]}]}"},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/writing-queries.html","id":"query-validation","dir":"Articles","previous_headings":"Why use the DSL?","what":"1. Query validation","title":"Writing queries","text":"search_pv() check query errors use methods 2 3. case method 1, rely API’s error messages guidance query invalid. search_pv() checks queries following: fields included query available endpoint used. example, make sure assignees.assignee_country can used query argument sent query patent endpoint. fields query compatible comparison operators used. example, confirm text_all operator used field whose type “full text” (patent_title ). supplied correct value type field (e.g., patent_date character, integer).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/writing-queries.html","id":"concise-easy-to-use-syntax-for-complex-queries","dir":"Articles","previous_headings":"Why use the DSL?","what":"2. Concise, easy to use syntax for complex queries","title":"Writing queries","text":"Methods 1 3 shorter method 2, making quicker. ’s also lot easier get JSON syntax correct using method 3 compared method 1, don’t write JSON using DSL…important API fairly picky query syntax, ’s trivial get correct. example, API throw error use box JSON absolutely necessary, even query still valid JSON (e.g., query = {\"_gte\":{\"patent_date\":[\"2007-03-01\"]}} throw error). Compared method 1, method 3 correctly “” together values put vector. example, query shown , vector two values given assignees.assignee_country (c(\"US\", \"CA\")). safely converted single “equals” statement third element query (eq(assignees.assignee_country = c(\"US\", \"CA\"))) two separate equals statements got ’d together.1","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/writing-queries.html","id":"basics-of-the-language","dir":"Articles","previous_headings":"","what":"Basics of the language","title":"Writing queries","text":"functions make DSL found qry_funs list (e.g., qry_funs$eq()). can evaluate code context list using function with_qfuns() (see ?with_qfuns() example demonstrates with_qfuns() can save typing). four types functions qry_funs: Comparison operator functions (eq, neq, gt, gte, lt, lte, begins, contains, text_all, text_any, text_phrase). functions used compare field value. example, using “less equal ” function (lte), can filter patents published date (e.g., query = qry_funs$lte(patent_date = \"2001-01-05\")). See “comparison operators” section API’s query language page description 11 comparison operators. One important thing keep mind certain comparison operators work certain data types. example, can’t use begins function patent_abstract patent_abstract data type “full text” begins works fields data type “string.” Array functions (). can use functions logically combine calls comparison operators. example, can require patent date less equal 2001-01-05 inventor’s last name “Ihaka” (query = with_qfuns((lte(patent_date = \"2001-01-05\"), eq(inventor_name_last = \"Ihaka\")))). function (). function negates comparison. example, search patents don’t word “hi” titles like : qry_funs$(qry_funs$text_phrase(patent_title = \"hi\")).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/articles/writing-queries.html","id":"query-examples","dir":"Articles","previous_headings":"","what":"Query examples","title":"Writing queries","text":"Query assignee endpoint disambiguated assignees 10 fewer patents: remaining examples queries intended patent endpoint. Patents assigned “CPC class” G12 (physics instruments): Patents : inventor listed whose first name “Kevin” abstract containing either phrase “dog bark” “cat meow” abstract doesn’t phrase “dog chain” : Patents : inventor listed whose last name “Smith” “cotton gin” title inventor listed whose last name “Turner” “COBOL” title","code":"qry_funs$lte(assignee_num_inventors = 10) #> {\"_lte\":{\"assignee_num_inventors\":10}} qry_funs$eq(cpc_current.cpc_class_id = \"G12\") #> {\"_eq\":{\"cpc_current.cpc_class_id\":\"G12\"}} with_qfuns(   and(     text_any(inventors.inventor_name_first = \"Kevin\"),  # inventor names are now full text     text_phrase(patent_abstract = c(\"dog bark\", \"cat meow\")),     not(       text_phrase(patent_abstract = c(\"dog chain\"))     )   ) ) #> {\"_and\":[{\"_text_any\":{\"inventors.inventor_name_first\":\"Kevin\"}},{\"_or\":[{\"_text_phrase\":{\"patent_abstract\":\"dog bark\"}},{\"_text_phrase\":{\"patent_abstract\":\"cat meow\"}}]},{\"_not\":{\"_text_phrase\":{\"patent_abstract\":\"dog chain\"}}}]} with_qfuns(   or(     and(       eq(inventors.inventor_name_last = \"Smith\"),       contains(patent_title = \"cotton gin\")     ),     and(       eq(inventors.inventor_name_last = \"Turner\"),       contains(patent_title = \"COBOL\")     )   ) ) #> {\"_or\":[{\"_and\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Smith\"}},{\"_contains\":{\"patent_title\":\"cotton gin\"}}]},{\"_and\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Turner\"}},{\"_contains\":{\"patent_title\":\"COBOL\"}}]}]}"},{"path":"https://docs.ropensci.org/patentsview/index.html/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Christopher Baker. Author, maintainer. Russ Allen. Author.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Baker C, Allen R (2025). patentsview: R Client 'PatentsView' API. R package version 0.3.0, https://docs.ropensci.org/patentsview/index.html.","code":"@Manual{,   title = {patentsview: An R Client to the 'PatentsView' API},   author = {Christopher Baker and Russ Allen},   year = {2025},   note = {R package version 0.3.0},   url = {https://docs.ropensci.org/patentsview/index.html}, }"},{"path":"https://docs.ropensci.org/patentsview/index.html/index.html","id":"patentsview","dir":"","previous_headings":"","what":"An R Client to the PatentsView API","title":"An R Client to the PatentsView API","text":"R client PatentsView API, recently renamed PatentSearch API","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"An R Client to the PatentsView API","text":"can get stable version original version API CRAN: development version GitHub (Currently broken): R package new version API r-universe: R package new version API GitHub:","code":"install.packages(\"patentsview\") if (!\"devtools\" %in% rownames(installed.packages())) {   install.packages(\"devtools\") }  devtools::install_github(\"ropensci/patentsview\") install.packages(\"patentsview\", repos = c(\"https://mustberuss.r-universe.dev\")) if (!\"devtools\" %in% rownames(installed.packages())) {   install.packages(\"devtools\") }  devtools::install_github(\"mustberuss/patentsview@api-redesign\")"},{"path":"https://docs.ropensci.org/patentsview/index.html/index.html","id":"important-api-change","dir":"","previous_headings":"","what":"Important API Change","title":"An R Client to the PatentsView API","text":"new version API requires API key, requests blocked. API key can obtained . updated R package look environmental variable PATENTSVIEW_API_KEY set value key. windows See page change. navigation get updated vignettes reference pages.","code":"set PATENTSVIEW_API_KEY=my_keys_value_without quotes"},{"path":"https://docs.ropensci.org/patentsview/index.html/index.html","id":"basic-usage","dir":"","previous_headings":"","what":"Basic usage","title":"An R Client to the PatentsView API","text":"PatentsView API provides interface disambiguated version USPTO. patentsview R package provides one main function, search_pv(), make easy interact API:","code":"library(patentsview)  search_pv(query = '{\"_gte\":{\"patent_date\":\"2007-01-01\"}}') #> $data #> #### A list with a single data frame on patents level: #>  #> List of 1 #>  $ patents:'data.frame': 1000 obs. of  3 variables: #>   ..$ patent_id   : chr [1:1000] \"7155746\" ... #>   ..$ patent_title: chr [1:1000] \"Anti-wicking protective workwear and method\".. #>   ..$ patent_date : chr [1:1000] \"2007-01-02\" ... #>  #> $query_results #> #### Distinct entity counts across all downloadable pages of output: #>  #> total_hits = 5,452,372"},{"path":"https://docs.ropensci.org/patentsview/index.html/index.html","id":"learning-more","dir":"","previous_headings":"","what":"Learning more","title":"An R Client to the PatentsView API","text":"Head package’s webpage info, including: getting started vignette first-time users. -depth tutorial writing queries list basic examples Two examples data applications (e.g., brief analysis top assignees field databases) package first introduced 2017 rOpenSci blog post used original version API. content, reworked use new version API, available . draft possible Tech Note new version API R package .","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/cast_pv_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Cast PatentsView data — cast_pv_data","title":"Cast PatentsView data — cast_pv_data","text":"cast data fields returned search_pv appropriate data types (e.g., date, numeric, etc.).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/cast_pv_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cast PatentsView data — cast_pv_data","text":"","code":"cast_pv_data(data)"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/cast_pv_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cast PatentsView data — cast_pv_data","text":"data data returned search_pv. first element three-element result object got back search_pv. list length 1, one data frame inside . See examples.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/cast_pv_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cast PatentsView data — cast_pv_data","text":"type object passed cast_pv_data.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/cast_pv_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cast PatentsView data — cast_pv_data","text":"","code":"if (FALSE) {  fields <- c(\"patent_date\", \"patent_title\", \"patent_year\") res <- search_pv(query = \"{\\\"patent_id\\\":\\\"5116621\\\"}\", fields = fields) cast_pv_data(data = res$data) }"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/fieldsdf.html","id":null,"dir":"Reference","previous_headings":"","what":"Fields data frame — fieldsdf","title":"Fields data frame — fieldsdf","text":"data frame containing names retrievable fields endpoints. can find data API's online documentation endpoint well (e.g., patent endpoint field list table).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/fieldsdf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fields data frame — fieldsdf","text":"","code":"fieldsdf"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/fieldsdf.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Fields data frame — fieldsdf","text":"data frame following columns: endpoint endpoint field record field complete name field, including parent group applicable data_type field's input data type group group field belongs common_name field name without parent group structure","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_endpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Get endpoints — get_endpoints","title":"Get endpoints — get_endpoints","text":"function reminds user possible PatentSearch API endpoints .  (Note API originally know PatentsView API.)","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_endpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get endpoints — get_endpoints","text":"","code":"get_endpoints()"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_endpoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get endpoints — get_endpoints","text":"character vector names endpoint.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_fields.html","id":null,"dir":"Reference","previous_headings":"","what":"Get list of retrievable fields — get_fields","title":"Get list of retrievable fields — get_fields","text":"function returns vector fields can retrieve given API endpoint (.e., fields can pass fields argument search_pv). can limit fields cover certain entity group(s) well (recommended, given large number possible fields endpoint).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_fields.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get list of retrievable fields — get_fields","text":"","code":"get_fields(endpoint, groups = NULL, include_pk = FALSE)"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_fields.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get list of retrievable fields — get_fields","text":"endpoint API endpoint whose field list want get. See get_endpoints list 27 endpoints. groups character vector giving group(s) whose fields want returned. value NULL indicates want endpoint's fields (.e., filter field list based group membership). See Nested Fields listed online see groups can specify given endpoint (e.g., patents endpoint table), use fieldsdf table (e.g., unique(fieldsdf[fieldsdf$endpoint == \"patent\", \"group\"])). empty string can also specified return top level (non-nested) fields endpoint. include_pk Boolean whether include endpoint's primary key, defaults FALSE.  primary key needed plan calling unnest_pv_data results search_pv","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_fields.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get list of retrievable fields — get_fields","text":"character vector field names.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_fields.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get list of retrievable fields — get_fields","text":"","code":"# Get all top level (non-nested) fields for the patent endpoint: fields <- get_fields(endpoint = \"patent\", groups = c(\"patents\"))  # ...Then pass to search_pv: if (FALSE) {  search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}',   fields = fields ) } # Get unnested patent and assignee-level fields for the patent endpoint: fields <- get_fields(endpoint = \"patent\", groups = c(\"assignees\", \"patents\"))  if (FALSE) { # ...Then pass to search_pv: search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}',   fields = fields ) } # Get the nested inventors fields and the primary key in order to call unnest_pv_data # on the returned data.  unnest_pv_data would throw an error if the primary key was # not present in the results. fields <- get_fields(endpoint = \"patent\", groups = c(\"inventors\"), include_pk = TRUE)  if (FALSE) { # ...Then pass to search_pv and unnest the results results <- search_pv(   query = '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}',   fields = fields ) unnest_pv_data(results$data) }"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_ok_pk.html","id":null,"dir":"Reference","previous_headings":"","what":"Get OK primary key — get_ok_pk","title":"Get OK primary key — get_ok_pk","text":"function suggests value use pk argument unnest_pv_data, based endpoint searched. return potential unique identifier given entity (.e., given endpoint). example, return \"patent_id\" endpoint_or_entity = \"patent\".  return value entity name \"patents\" passed via get_ok_pk(names(pv_return$data)) pv_return returned search_pv.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_ok_pk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get OK primary key — get_ok_pk","text":"","code":"get_ok_pk(endpoint_or_entity)"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_ok_pk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get OK primary key — get_ok_pk","text":"endpoint_or_entity endpoint entity name like know potential primary key .","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_ok_pk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get OK primary key — get_ok_pk","text":"name primary key (pk) pass unnest_pv_data.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/get_ok_pk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get OK primary key — get_ok_pk","text":"","code":"get_ok_pk(endpoint_or_entity = \"inventor\") # Returns \"inventor_id\" #> [1] \"inventor_id\" get_ok_pk(endpoint_or_entity = \"cpc_group\") # Returns \"cpc_group_id\" #> [1] \"cpc_group_id\""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/pad_patent_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Pad patent_id — pad_patent_id","title":"Pad patent_id — pad_patent_id","text":"function strategically pads patent_id zeroes 8 characters, needed custom paging uses sorts patent_id.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/pad_patent_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pad patent_id — pad_patent_id","text":"","code":"pad_patent_id(patent_id)"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/pad_patent_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pad patent_id — pad_patent_id","text":"patent_id patent_id needs padded.  can patent_id utility, design, plant reissue patent.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/pad_patent_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pad patent_id — pad_patent_id","text":"","code":"if (FALSE) { padded <- pad_patent_id(\"RE36479\")  padded2 <- pad_patent_id(\"3930306\") }"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/patentsview-package.html","id":null,"dir":"Reference","previous_headings":"","what":"patentsview: An R Client to the 'PatentsView' API — patentsview-package","title":"patentsview: An R Client to the 'PatentsView' API — patentsview-package","text":"Provides functions simplify 'PatentsView' API (https://patentsview.org/apis/purpose) query language, send GET POST requests API's twelve endpoints, parse data comes back.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/patentsview-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"patentsview: An R Client to the 'PatentsView' API — patentsview-package","text":"Maintainer: Christopher Baker chriscrewbaker@gmail.com Authors: Russ Allen rrjallen@yahoo.com","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/qry_funs.html","id":null,"dir":"Reference","previous_headings":"","what":"List of query functions — qry_funs","title":"List of query functions — qry_funs","text":"list functions make easy write PatentsView queries. See details section list 15 functions, well writing queries vignette details.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/qry_funs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"List of query functions — qry_funs","text":"","code":"qry_funs"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/qry_funs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"List of query functions — qry_funs","text":"object class list length 15.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/qry_funs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"List of query functions — qry_funs","text":"object class pv_query. basically just simple list print method attached .","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/qry_funs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"List of query functions — qry_funs","text":"1. Comparison operator functions 6 comparison operator functions work fields type integer, float, date, string: eq - Equal neq - equal gt - Greater gte - Greater equal lt - Less lte - Less equal 2 comparison operator functions work fields type string: begins - string begins value string contains - string contains value string 3 comparison operator functions work fields type fulltext: text_all - text contains words value string text_any - text contains words value string text_phrase - text contains exact phrase value string 2. Array functions 2 array functions: - members array must true - one member array must true 3. Negation function 1 negation function: - comparison true 4. Convenience function 1 convenience function: in_range - Builds <= x <= b query","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/qry_funs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"List of query functions — qry_funs","text":"","code":"qry_funs$eq(patent_date = \"2001-01-01\") #> {\"_eq\":{\"patent_date\":\"2001-01-01\"}}  qry_funs$not(qry_funs$eq(patent_date = \"2001-01-01\")) #> {\"_not\":{\"_eq\":{\"patent_date\":\"2001-01-01\"}}}  qry_funs$in_range(patent_year = c(2010, 2021)) #> {\"_and\":[{\"_gte\":{\"patent_year\":2010}},{\"_lte\":{\"patent_year\":2021}}]}  qry_funs$in_range(patent_date = c(\"1976-01-01\", \"1983-02-28\")) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"1976-01-01\"}},{\"_lte\":{\"patent_date\":\"1983-02-28\"}}]}"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/retrieve_linked_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Retrieve Linked Data — retrieve_linked_data","title":"Retrieve Linked Data — retrieve_linked_data","text":"endpoints now return HATEOAS style links get data. E.g., patent endpoint may return link : \"https://search.patentsview.org/api/v1/inventor/fl:th_ln:jefferson-1/\"","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/retrieve_linked_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Retrieve Linked Data — retrieve_linked_data","text":"","code":"retrieve_linked_data(url, api_key = Sys.getenv(\"PATENTSVIEW_API_KEY\"), ...)"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/retrieve_linked_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Retrieve Linked Data — retrieve_linked_data","text":"url link returned API previous call api_key API key, defaults Sys.getenv(\"PATENTSVIEW_API_KEY\"). Request key . ... Curl options passed along httr2's req_options function.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/retrieve_linked_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Retrieve Linked Data — retrieve_linked_data","text":"list following three elements: data list one element - named data frame containing data returned server. row data frame corresponds single value primary entity. example, search assignee endpoint, data frame assignee-level, row corresponds single assignee. Fields assignee-level returned list columns. query_results Entity counts across pages output (just page returned ). request Details GET HTTP request sent server.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/retrieve_linked_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Retrieve Linked Data — retrieve_linked_data","text":"","code":"if (FALSE) {  retrieve_linked_data(   \"https://search.patentsview.org/api/v1/cpc_group/G01S7:4811/\" ) }"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/search_pv.html","id":null,"dir":"Reference","previous_headings":"","what":"Search PatentsView — search_pv","title":"Search PatentsView — search_pv","text":"function makes HTTP request PatentsView API data matching user's query.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/search_pv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Search PatentsView — search_pv","text":"","code":"search_pv(   query,   fields = NULL,   endpoint = \"patent\",   subent_cnts = FALSE,   mtchd_subent_only = lifecycle::deprecated(),   page = lifecycle::deprecated(),   per_page = lifecycle::deprecated(),   size = 1000,   after = NULL,   all_pages = FALSE,   sort = NULL,   method = \"GET\",   error_browser = NULL,   api_key = Sys.getenv(\"PATENTSVIEW_API_KEY\"),   ... )"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/search_pv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Search PatentsView — search_pv","text":"query query API use filter records. query can come one following forms: character string valid JSON.  E.g., '{\"_gte\":{\"patent_date\":\"2007-01-04\"}}' list converted JSON search_pv.  E.g., list(\"_gte\" = list(\"patent_date\" = \"2007-01-04\")) object class pv_query, create calling one functions found qry_funs list...See writing queries vignette details. E.g., qry_funs$gte(patent_date = \"2007-01-04\") fields character vector fields want returned . value NULL indicates API return default fields endpoint. Acceptable fields given endpoint can found API's online documentation (e.g., check field list patents endpoint) viewing fieldsdf data frame (View(fieldsdf)). can also use get_fields list fields available given endpoint. Nested fields can fully qualified, e.g., \"application.filing_date\" group name can used retrieve nested fields, E.g. \"application\". latter similar passing get_fields(\"patent\", group = \"application\") except API decides fields return. endpoint web service resource wish search. Use get_endpoints() list available endpoints. subent_cnts always FALSE new version API total counts unique subentities longer available. mtchd_subent_only always FALSE new version API non-matched subentities always returned. page new version API use page parameter paging, uses . per_page API now uses size size number records returned per page. value can high 1,000 (e.g., size = 1000). list sort key values defaults NULL.  exposes API's paging parameter users want implement paging. set all_pages = TRUE R package manipulates users automatically. See result set paging all_pages want download possible pages output? all_pages = TRUE, value size ignored. sort named character vector name indicates field sort value indicates direction sorting (direction either \"asc\" \"desc\"). example, sort = c(\"patent_id\" =  \"asc\") sort = c(\"patent_id\" = \"asc\", \"patent_date\" =  \"desc\"). sort = NULL (default) means sort results. must include fields wish sort fields. method HTTP method want use send request. Possible values include \"GET\" \"POST\". Use POST method query long (say, 2,000 characters length). error_browser  api_key API key, defaults Sys.getenv(\"PATENTSVIEW_API_KEY\"). Request key . ... Curl options passed along httr2's req_options GETs POSTs.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/search_pv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Search PatentsView — search_pv","text":"list following three elements: data list one element - named data frame containing data returned server. row data frame corresponds single value primary entity. example, search assignee endpoint, data frame assignee-level, row corresponds single assignee. Fields assignee-level returned list columns. query_results Entity counts across pages output (just page returned ). request Details HTTP request sent server. set all_pages = TRUE, get sample request. words, given multiple requests multiple calls made server (one page results).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/search_pv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Search PatentsView — search_pv","text":"","code":"if (FALSE) {  search_pv(query = '{\"_gt\":{\"patent_year\":2010}}')  search_pv(   query = qry_funs$gt(patent_year = 2010),   fields = get_fields(\"patent\", c(\"patents\", \"assignees\")) )  search_pv(   query = qry_funs$gt(patent_year = 2010),   method = \"POST\",   fields = \"patent_id\",   sort = c(\"patent_id\" = \"asc\") )  search_pv(   query = qry_funs$eq(inventor_name_last = \"Crew\"),   endpoint = \"inventor\",   all_pages = TRUE )  search_pv(   query = qry_funs$contains(assignee_individual_name_last = \"Smith\"),   endpoint = \"assignee\" )  search_pv(   query = qry_funs$contains(inventors.inventor_name_last = \"Smith\"),   endpoint = \"patent\",   timeout = 40 )  search_pv(   query = qry_funs$eq(patent_id = \"11530080\"),   fields = \"application\" ) }"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/unnest_pv_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Unnest PatentsView data — unnest_pv_data","title":"Unnest PatentsView data — unnest_pv_data","text":"function converts single data frame subentity-level list columns multiple data frames, one entity/subentity. multiple data frames can merged together using primary key variable specified user (see relational data chapter \"R Data Science\" -depth introduction joining tabular data).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/unnest_pv_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unnest PatentsView data — unnest_pv_data","text":"","code":"unnest_pv_data(data, pk = NULL)"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/unnest_pv_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unnest PatentsView data — unnest_pv_data","text":"data data returned search_pv. first element three-element result object got back search_pv. list length 1, one data frame inside . See examples. pk column/field name link data frames together. unique identifier primary entity. example, used patent endpoint call search_pv, specify pk = \"patent_id\". identifier included fields vector called search_pv. can use get_ok_pk suggest potential primary key data.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/unnest_pv_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unnest PatentsView data — unnest_pv_data","text":"list multiple data frames, one entity/subentity. data frame pk column , can link tables together needed.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/unnest_pv_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unnest PatentsView data — unnest_pv_data","text":"","code":"if (FALSE) {  fields <- c(\"patent_id\", \"patent_title\", \"inventors.inventor_city\", \"inventors.inventor_country\") res <- search_pv(query = '{\"_gte\":{\"patent_year\":2015}}', fields = fields) unnest_pv_data(data = res$data, pk = \"patent_id\") }"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/with_qfuns.html","id":null,"dir":"Reference","previous_headings":"","what":"With qry_funs — with_qfuns","title":"With qry_funs — with_qfuns","text":"function evaluates whatever code pass environment qry_funs list. allows cut typing writing queries. want cut typing even , can try assigning qry_funs list global environment : list2env(qry_funs, envir = globalenv()).","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/with_qfuns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"With qry_funs — with_qfuns","text":"","code":"with_qfuns(code, envir = parent.frame())"},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/with_qfuns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"With qry_funs — with_qfuns","text":"code Code evaluate. See example. envir R look objects present code present qry_funs.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/with_qfuns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"With qry_funs — with_qfuns","text":"result code - .e., query.","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/reference/with_qfuns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"With qry_funs — with_qfuns","text":"","code":"qry_funs$and(   qry_funs$gte(patent_date = \"2007-01-01\"),   qry_funs$text_phrase(patent_abstract = c(\"computer program\")),   qry_funs$or(     qry_funs$eq(inventors.inventor_name_last = \"Ihaka\"),     qry_funs$eq(inventors.inventor_name_last = \"Chris\")   ) ) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-01-01\"}},{\"_text_phrase\":{\"patent_abstract\":\"computer program\"}},{\"_or\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Ihaka\"}},{\"_eq\":{\"inventors.inventor_name_last\":\"Chris\"}}]}]}  # ...With it, this becomes: with_qfuns(   and(     gte(patent_date = \"2007-01-01\"),     text_phrase(patent_abstract = c(\"computer program\")),     or(       eq(inventors.inventor_name_last = \"Ihaka\"),       eq(inventors.inventor_name_last = \"Chris\")     )   ) ) #> {\"_and\":[{\"_gte\":{\"patent_date\":\"2007-01-01\"}},{\"_text_phrase\":{\"patent_abstract\":\"computer program\"}},{\"_or\":[{\"_eq\":{\"inventors.inventor_name_last\":\"Ihaka\"}},{\"_eq\":{\"inventors.inventor_name_last\":\"Chris\"}}]}]}"},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"patentsview-030-2021-09-03","dir":"Changelog","previous_headings":"","what":"patentsview 0.3.0 (2021-09-03)","title":"patentsview 0.3.0 (2021-09-03)","text":"CRAN release: 2021-09-25","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"misc-0-3-0","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.3.0 (2021-09-03)","text":"package now using new HTTPS endpoints (#17) list queryable fields updated with_qfuns() now find objects calling environment (@jcheng5, #20) Vignettes pre-computed (#23) issue fixed query strings weren’t properly URL-encoded (#24) Adhoc logic added handle API throttling","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"patentsview-022-2019-01-23","dir":"Changelog","previous_headings":"","what":"patentsview 0.2.2 (2019-01-23)","title":"patentsview 0.2.2 (2019-01-23)","text":"CRAN release: 2019-01-28","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"misc-0-2-2","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.2.2 (2019-01-23)","text":"Vignettes removed package CRAN builds don’t fail API ","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"patentsview-021-2018-03-05","dir":"Changelog","previous_headings":"","what":"patentsview 0.2.1 (2018-03-05)","title":"patentsview 0.2.1 (2018-03-05)","text":"CRAN release: 2018-03-14","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"misc-0-2-1","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.2.1 (2018-03-05)","text":"Examples hit API wrapped \\dontrun{} CRAN doesn’t request fixes package API ","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"patentsview-020-2018-02-08","dir":"Changelog","previous_headings":"","what":"patentsview 0.2.0 (2018-02-08)","title":"patentsview 0.2.0 (2018-02-08)","text":"CRAN release: 2018-02-09","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"new-features-0-2-0","dir":"Changelog","previous_headings":"","what":"New features","title":"patentsview 0.2.0 (2018-02-08)","text":"cast_pv_data() function added convert data types data returned search_pv() Additional fields added API (e.g., fields starting forprior_, examiner_)","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"misc-0-2-0","dir":"Changelog","previous_headings":"","what":"Misc","title":"patentsview 0.2.0 (2018-02-08)","text":"Additional error handler added locations endpoint (@mustberuss, #11) error_browser option deprecated","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"patentsview-010-2017-05-01","dir":"Changelog","previous_headings":"","what":"patentsview 0.1.0 (2017-05-01)","title":"patentsview 0.1.0 (2017-05-01)","text":"CRAN release: 2017-07-12","code":""},{"path":"https://docs.ropensci.org/patentsview/index.html/news/index.html","id":"new-functions-0-1-0","dir":"Changelog","previous_headings":"","what":"New functions","title":"patentsview 0.1.0 (2017-05-01)","text":"search_pv added send requests PatentsView API qry_funs list added functions help users write queries get_fields get_endpoints added quickly get possible field names endpoints, respectively unnest_pv_data added unnest data frames returned data","code":""}]
