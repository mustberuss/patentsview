---
title: "Result Set Paging"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Result Set Paging}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  warning = FALSE,
  message = FALSE
)
```

  Paging changed in the new version of the Patentsview API.  This vignette tries to explain a
subtle gotcha that the R package handles for you and to show how to do your own paging.  Or
maybe it's trying to make the case for adding a max_rows parameter to search_pv()? :-)

  The R package lets you make a single request of up to 1000 rows or to retrieve all rows,
with nothing in between, unless you do your own paging.  This might be important if you
want to retrieve a few thousand utility patents without retrieving all 8 million of them.
Or maybe you want to iterate through search results page by page rather than retrieving
the entire data set and then iterating row by row.
If you do your own paging, you'll need to be careful when choosing your sort field, as
shown in Example 2.

## Example 1

**Note:** A recent API release seems to have broke paging.  Example 1 worked until recently
but now returns the results below.

Here we'll retrieve 5000 utility patents by paging.

```{r}
library(patentsview)

# Lets get 5000 utility patents, 1000 at a time (the API's maximum rows per request)
requested_rows <- 1000
sort <- c("patent_id" = "asc")
query <- qry_funs$eq("patent_type" = "utility")
fields <- c("patent_id", "patent_date", "patent_title")

# The "after" parameter is explained a bit lower.  It's an Elasticsearch thing,
# which is the attrbute the new version of the API uses to page.  For now, just be 
# thankful that the R package handles this for you when you set all_pages = TRUE
after <- NULL

tmp <- lapply(seq_len(5), function(n) {
  print(paste("page", n, "after is", ifelse(is.null(after),"NULL",after)))
  page_n <- search_pv(query, fields = fields, sort = sort, 
    all_pages = FALSE, size = requested_rows, after = after)
   s <- names(sort)
   index <- nrow(page_n$data[[1]])
   after <<- page_n$data[[1]][[s]][[index]]
   page_n$data
})

utility_patents <- as.data.frame(do.call(rbind, lapply(tmp, as.data.frame)))
str(utility_patents)

```
## Example 2

Here we will execute a query two different ways, the first having the R package do
the paging, the second will be our misguided attempt to do the paging ourselves.

As an exercise for the reader, the US patent office says there were 5677 patents 
[issued in January 1976](https://ppubs.uspto.gov/pubwebapp/external.html?q=@PD%3E=19760101%3C=19760131&db=USPAT&type=queryString)
while the patentsview database says there are 5352. Open as bug or try to figure out
why the numbers are so far off.
```{r}

fields <- c("patent_id", "patent_date", "patent_title")
sort <- c("patent_date" = "asc")
query <- qry_funs$in_range(patent_date=c("1976-01-01", "1976-01-31"))
query

r_pkg <- search_pv(query, sort = sort, fields = fields, all_pages = TRUE)

# note the number of rows returned
r_pkg$query_results$total_hits

```

Now we'll try to do our own paging but as you might notice, we'll run into trouble.

```{r}

after <- NULL
combined_data <- NULL
count <- 0
requested_rows <- 1000  # API's maximum rows per request
fields <- c("patent_id", "patent_date", "patent_title")
sort <- c("patent_date" = "asc")
query <- qry_funs$in_range(patent_date=c("1976-01-01", "1976-01-31"))
query

# We'll continue to make requests until we get back an empty or partial
# response from the API
page <- 1

repeat {
  print(paste("page", page, "after is", ifelse(is.null(after), "NULL", after)))

  subsequent <- search_pv(query, sort = sort, all_pages = FALSE,
    fields = fields, size = requested_rows, after = after)

  returned_rows <- subsequent$query_results$count
  count <- count + returned_rows 
  page <- page  + 1

  if(returned_rows > 0) {
     combined_data <- rbind(combined_data, subsequent$data$patents)
  }

  # We're done if we got an empty or partial reply from the API
  if(returned_rows < requested_rows) {
     break
  }

  # Now to page we need to set the "after" attribute to where the
  # current results ended.  Its value is the last row's [[sort field]]. 
  # It would need to be an array of values if there are multiple sort fields
  s <- names(sort)[[1]]
  after <- subsequent$data[[1]][[s]][[returned_rows]]

}

print(paste("count is", count))
print(nrow(combined_data))

```

Here we ran into trouble since we chose patent_date as the sort field which
isn't unique in our result set as patent_id is in Example 1.  The R package
uses an appropriate primary key (```get_ok_pk(endpoint)```) when requesting
paged data (```all_pages = TRUE```) from an endpoint.  After all the pages
have been retrieved, the R package sorts the data as the user requested.
(This sorting methodology is inspired by the [Patentsview's python wrapper](https://github.com/PatentsView/PatentsView-APIWrapper))

## Reader Exercise

Ok, we'll get you started on the user exercise. Trivia: with a handful of exceptions,
patents were issued on Tuesdays.

```{r}
   uspto_counts <- c(1478, 1312, 1449, 1438)

   issue_date <- as.Date("1976-01-06")  # first Tuesday of January 1976

   weekly_counts <- lapply(seq(from = 0, to = 21, by = 7), function(additional_days, base_issue_date) {
     issue_date <- base_issue_date + additional_days
     query <- qry_funs$eq("patent_date" = as.character(issue_date))
     query
     issued_patents <- search_pv(query)
     print(paste("issue date", issue_date, issued_patents$query_results$total_hits, 
        "issued patents"))
     issued_patents$query_results$total_hits
   }, issue_date)

   total <- do.call(sum, weekly_counts)
   print(paste("patentsview total", total))
   print(paste("uspto total", sum(uspto_counts)))

```