---
title: "Patentsview Follow Up Blog"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Patentsview Follow Up Blog}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


> Here we rework sections of the [ropensci post](https://ropensci.org/blog/2017/09/19/patentsview/) from the launch of the patentsview R package, in case a follow up post is needed.  Things are a wee bit different now with the new version of the API...

1. From the original post:  

> The API is free (no credential required) and currently doesn't impose rate limits/bandwidth throttling.

An API key is now required and throttling is imposed (handled by the new version of the R package) at 45 requests per minute.

2. The first two examples still work form the original blog, though now the maximum result set size is 10,000, down from 100,000 and "total_hits" is returned instead of an endpoint specific count, ex. total_patent_count.

```{r}
library(patentsview)
```

[query](#query)

```{r}
qry_1 <- '{"_gt":{"patent_year":2007}}'
search_pv(query = qry_1, fields = NULL) # This will retrieve a default set of fields
```

```{r}
qry_2 <- qry_funs$gt(patent_year = 2007) # All DSL functions are in the qry_funs list
qry_2 # qry_2 is the same as qry_1

search_pv(query = qry_2)
```

3. From the original blog post:  
> There are three gotchas to look out for when writing a query:  
>  
> 1. **Field is queryable.** The API has 7 endpoints (the default endpoint is “patents”), and each endpoint has its own set of fields that you can filter on. 


This needs updating, as now all fields are queryable and there are 13 endpoints (more coming?):

4. The original blog requested inventor_total_num_patents, which we don't get from the patents endpoint in the new version of the API. Now we'd have to call the inventors endpoint to get this field.

> search_pv(
>  query = qry_funs$gt(patent_year = 2007),
>  fields = c("patent_abstract", "patent_average_processing_time",
>             "inventor_first_name", "inventor_total_num_patents")



5. The original blog's "begins(cpc_subgroup_id = 'H04L63/02')" isn't currently possible,
the API throws 500 errors when trying to search via cpc fields.  The field may be full text now (some fields switch from string to full text and vise versa) and insanely, it would have to be written 
```{r}
qry_funs$text_phrase("cpc_current.cpc_subgroup" = "H04L63:02") 
```
where a colon is substituted for the slash.  HATEOAS links come back in some of the fields now like these cpc ones:

```
        {
          "sequence": 18,
          "section_id": "H",
          "cpc_subsection": "https://search.patentsview.org/api/v1/cpc_subsection/H04/",
          "cpc_group": "https://search.patentsview.org/api/v1/cpc_group/H04L/",
          "cpc_subgroup": "https://search.patentsview.org/api/v1/cpc_subgroup/H04L63:02/"
        },
```

Note the lack of an _id on the cpc fields, cpc_subgroup instead of cpc_subgroup_id, which will become important below.
These links are Get only with just a url parameter, there is no mechanism to pass the s:, f: or o: parameters (no need to pannic, the friendly/familiar endpoints from the initial version of the API are still present.)

Following the "cpc_subgroup" link returns: 
```
{
  "error": false,
  "count": 1,
  "total_hits": 1,
  "cpc_subgroups": [
    {
      "cpc_subgroup_id": "H04L63/02",
      "cpc_subgroup_title": "Network architectures or network communication protocols for network security -for separating internal from external traffic, e.g. firewalls"
    }
  ]
}
```
Apparently the API team didn't want to have two url parameters, so in the HATEOAS link the slash is changed to a colon, though the cpc_subgroup_id comes back with the slash in place.

There is a new method in the R package to retrive data from the HATEOAS links.
```{r}
retrieve_linked_data("https://search.patentsview.org/api/v1/cpc_subgroup/H04L63:02/")

```


6. The next part of the original blog needs changes, both groups have new names.

```{r}
# Create a list of fields:
fields <- c(
  c("patent_number", "patent_year"),
  get_fields(endpoint = "patents", groups = c("assignees_at_grant", "cpc_current"))
)

fields

```
As mentioned, searching by any of the cpc fields currently throws a 500 error.  

```{r}


# Write a query:
query <- with_qfuns( # with_qfuns is basically just: with(qry_funs, ...)
  and(
    text_any(cpc_current.cpc_subgroup_id = 'H04L63/02'),
    gte(patent_year = 2007)
  )
)

# Create a list of fields:
fields <- c(
  c("patent_number", "patent_year"),
  get_fields(endpoint = "patents", groups = c("assignees_at_grant", "cpc_current"))
)

# Here we won't actually send the request to the server, it would result in a 500
# Send HTTP request to API's server:
#pv_res <- search_pv(query = query, fields = fields, all_pages = TRUE)

# Instead, we'll query for 300 patent numbers returned from the original API
# that matched begins(cpc_subgroup_id = 'H04L63/02')  The sort was by patent_title,
# hoping that will give a random distribution of patent_years (does that matter?)

# When the API is fixed, we'll remove this and make the commented out query above.
# This just lets us move on to see what other changes we have to make to live
# under the new version of the API.

dat <- c("8955089","7778228","10069797","11184318","11076281","7624431","7649848","8111620","10212133","10944724","7873060","8503332","9774570","9882878","10581737","7120692","7600036","7788404","8341275","9071574"
,"9331992","10397188","6219706","10089480","10963575","10880295","9363290","7475138","7805513","8181258","7853687","9509700","6377577","7023853","9749328","9794262","9584482","9712491","7054944","10764299"
,"9154459","9225687","9467932","6233618","10225152","10666651","11115224","10318745","9077688","7937669","9197668","6484258","10798105","8582574","10091209","10581863","9686289","9628458","9912666","8126972"
,"7508767","6697806","7743158","9491625","10834136","9306943","9344296","10958662","10389722","8938794","9537755","10491633","9189644","9529989","9536070","9558334","8082579","10356619","8621570","9137231"
,"9949118","10623450","10681547","10805800","7698452","8688970","9240945","9514294","10049078","7251824","9525740","10798560","10050949","7653200","10911406","10567482","11115465","10171590","9560142","9344426"
,"8806040","10951421","10523445","9756135","10608990","11075999","8782393","9742806","7856508","10885165","7490350","10455449","8505077","10924513","10079839","10616244","10958769","8205240","10505894","10498583"
,"10171425","6550012","7451489","7454499","7454792","7499412","8079075","8447039","7743155","9098459","10594029","8644206","9167426","9398453","10079754","10616279","11005816","9843622","11122065","8205259"
,"8448247","10498752","10235627","8489534","9684867","10425317","8406119","9170902","9674067","7912856","9306913","9660963","7774402","8639846","10362106","11019143","10326734","10616249","6185606","9288236"
,"10389760","10110553","9426121","11032733","6606710","11048770","11190488","10110627","10333827","7904941","8316226","7369537","10911490","8363549","9112911","9935980","10644951","7209486","10469529","8667170"
,"10284504","8463938","10855644","11201847","5654985","10897459","7827313","8069469","8347353","8732796","9356836","9876822","9912701","7478420","7526800","10230531","10764065","6584508","9780995","9392015"
,"9654489","11036867","7533172","9825975","10205743","10645115","11171984","9578052","8464330","10044882","7480937","9094366","9413907","9781280","6785819","10652213","10826916","6349336","10740134","10701104"
,"7065042","10320688","8787875","8595479","9210131","10511573","7418504","7921211","7945654","8554899","8572247","8868705","9037713","9077694","9374346","9967240","6502135","6618761","6907473","7010604"
,"7133930","7933990","7996539","8516117","8874771","9479426","9860283","6985942","8769608","8050281","9542830","9450919","10999318","10630509","11057243","11018995","10785115","8695079","10938619","8230493"
,"11157598","8707406","10986555","10681064","10367703","10931468","9407662","9065846","10749886","9769187","10102019","10289858","8244745","8694523","9152774","10652254","8990259","9514246","10595360","10021108"
,"11012409","11005872","9497206","10986067","10911335","10623283","10992675","9813438","10277606","9942240","10375111","9031539","6738808","7069319","7418503","8041817","8402117","8645505","9571958","10305693"
)

query <- qry_funs$eq("patent_number" = dat)

pv_res <- search_pv(query=query, method="POST", fields = fields, all_pages = TRUE)

```
7. In the new version of the API we don't get latitude/longitude back from the patents endpoint.
We need to figure out the unique assignee ids and make a call to the assignees endpoint for this data.

A bit of weirdness from the new version of the API here, we asked for "assignee_id" as a field paramter but we get back a HATEOAS link named "assignee" where the assignee_id is the url parameter, the digits at the end, example: 18448 from https://search.patentsview.org/api/v1/assignee/18448/ (clicking on the link won't send an API key and will be rejected with a HTTP 403 Forbidden, there you've been warned.) 

```{r}
library(leaflet)
library(htmltools)
library(dplyr)
library(tidyr)
library(stringr)

assignees <-
   pv_res$data$patents %>%
   unnest(assignees_at_grant) %>%
   mutate(assignee_id = as.integer(str_extract(assignee, "(\\d+)(?=/$)"))) %>%
   select(assignee_id, patent_number) %>%
   group_by(assignee_id) %>%
   mutate(num_pats = n()) %>%
   ungroup() %>%
   select(-patent_number) 

# Now we can make the call back to the API for the latitude and longitude and 
# num_patents (total number of patents the assignee has- below we use the number of
# patents we retrieved- ones that met the cpc criteria)

assignee_query =  qry_funs$eq(assignee_id = assignees$assignee_id)

assignee_fields <- c(
  "assignee_id", "organization", "num_patents", "lastknown_latitude", "lastknown_longitude"
)

# we'll post to the API, the query is a pretty large string (an "or" of a lot of assignee_ids)
assignee_out <- search_pv(assignee_query , fields = assignee_fields, all_pages = TRUE, 
   endpoint = "assignees", method = "POST")

# now we'd want to join assignees and the output of the assignee call 
# making a data structure similar to the return (in a single call) 
# from the original version of the API
data <-
    assignees %>%
    inner_join(assignee_out$data$assignees) %>% 
    ungroup() %>%
    select(assignee_id, organization, num_pats, num_patents, # both num_pats and num_patents?
           lastknown_longitude, lastknown_latitude) %>%
    distinct() %>%  # needed?
    mutate(popup = paste0("<font color='Black'>",
                          htmlEscape(organization), "<br><br>Patents:",
                          num_pats, "</font>")) %>%
    filter(!is.na(assignee_id))

leaflet(data) %>%
  addProviderTiles(providers$CartoDB.DarkMatterNoLabels) %>%
  addCircleMarkers(lng = ~lastknown_longitude, lat = ~lastknown_latitude,
                   popup = ~popup, ~sqrt(num_pats), color = "yellow")


```

1. Plot the growth of the field’s topics over time

```{r}
library(ggplot2)
library(RColorBrewer)

# In the new version of the API, we don't get the title back from the patents endpoint
# we have to call, you guessed it, the cpc_subgroup endpoint now
qry <- qry_funs$begins(cpc_subgroup_id = 'H04L63/02')
qry

cpc_info <- search_pv(query=qry, fields = get_fields("cpc_subgroups"), endpoint = "cpc_subgroups")

# More API craziness, in the HATEAS link from the patents endpoint, the separator is 
# inexplicably a colon.  In the data that comes back from the cpc_subgroups endpoint, the 
# separator is, get this, a slash like it should be.  All that to say that joining 
# becomes a bit problematic or an exercise that makes dplyr wonder what we're up to.

data <-
  pv_res$data$patents %>%
    unnest(cpc_current) %>%
    mutate(cpc_subgroup = str_extract(cpc_subgroup, "([\\w:]+)(?=/$)")) %>% # unHATEOAS cpc_subgroup, funky colon and all
    filter(cpc_subgroup != "H04L63:02") %>% # remove patents categorized into only top-level category of H04L63/02
    mutate(cpc_subgroup = str_replace(cpc_subgroup, ":", "/"))  %>%  # back to normality, ahead of a join
    inner_join(cpc_info$data$cpc_subgroups, by=c("cpc_subgroup"="cpc_subgroup_id")) %>%  # highlighting name inconsistency
    ungroup() %>%
    mutate(
      title = case_when(
        grepl("filtering", .$cpc_subgroup_title, ignore.case = T) ~
          "Filtering policies",
        .$cpc_subgroup %in% c("H04L63/0209", "H04L63/0218") ~  
          "Architectural arrangements",
        grepl("Firewall traversal", .$cpc_subgroup_title, ignore.case = T) ~
          "Firewall traversal",
        TRUE ~
          .$cpc_subgroup_title
      )
    ) %>%
    mutate(title = gsub(".*(?=-)-", "", title, perl = TRUE)) %>%
    group_by(title, patent_year) %>%
    count() %>%
    ungroup()

# Here the line graph looks a bit anemic since our data set was only 300 patents
# Also, we're getting this Warning message:
# Removed 41 rows containing non-finite values (stat_smooth).
# the y scale was limits = c(0, 700))

ggplot(data = data) +
  geom_smooth(aes(x = patent_year, y = n, colour = title), se = FALSE) +
  scale_x_continuous("\nPublication year", limits = c(2007, 2016),
                     breaks = 2007:2016) +
  scale_y_continuous("Patents\n", limits = c(0, 25)) +
  scale_colour_manual("", values = brewer.pal(5, "Set2")) +
  theme_bw() + # theme inspired by https://hrbrmstr.github.io/hrbrthemes/
  theme(panel.border = element_blank(), axis.ticks = element_blank())

```

Somehow the ggplot winds up in the html properly.  In the top assignees vignette, the hchart only shows a little bit of IBM's patents.

Man, I'm thinking I'll make good money helping people convert their R scripts! 
