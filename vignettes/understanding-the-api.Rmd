---
title: "Understanding the API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understanding the API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



Oh, the interesting things you'll learn when you take the time to read the API documentation!
Here are gems gleaned from a [Jupyter notebook](https://github.com/PatentsView/PatentsView-Code-Snippets/blob/master/07_PatentSearch_API_demo/PV%20PatentSearch%20API%20tutorial.ipynb) in PatentsView's PatentsView-Code-Snippets
repo.

## Fields Shorthand
The notebook starts out fairly fluffy but things really get interesting really quickly.
See this under "constructing your query",  I don't remember seeing this anywhere else:

> Some endpoints contain groups of fields representing related entities connected to one of that
> endpoint's primary entity type; for example, the patent endpoint contains a field "inventors",
> which contains information on all inventors associated with any given patent. *The fields for
> related entities can be requested in the API request's fields parameter as a group by using the
> group name in the fields parameter*, or individually by specifying the required field as "{entity_type}.{subfield}".

Mind blown, so we can, for example, request all the nested application fields from the patent endpoint by simply requesting "application" in the fields list.  

The new version of the R package will let its users leverage this same "feature".  (Purists will probably frown upon using it, as they 
would with a select * in SQL.  It can be helpful to see exactly what fields the API can return, should the documentation
be lagging.)


``` r
library(patentsview)

pat_res <- search_pv(qry_funs$eq(patent_id = "10568228"), fields=c("application"), method="POST")
pat_res$data$patent$application
#> [[1]]
#>   application_id application_type filing_date series_code rule_47_flag
#> 1      15/995745               15  2018-06-01          15        FALSE
#>   filing_type
#> 1          15
pat_res$request
#> #### An HTTP request where:
#> 
#> Method: POST
#> URL: https://search.patentsview.org/api/v1/patent/
#> Body: {"q":{"_eq":{"patent_id":"10568228"}},"f":["application"],"o":{"size":1000}}
```

The results should be the same if we used ```fields=get_fields("patent", groups=c("application"))```.  The difference
is that in the case above, it's the API deciding what fields to return while in the get_fields() case, we parsed
the API's OpenAPI object when building the R package to determine what fields can be requested.  The query results 
could be different if the API's return is not in sync with the API's OpenAPI object.  Here we see that the
results are the same (we'll use POSTs as the requests are easier to read since they don't need to be urlencoded.):


``` r
app_fields <- get_fields("patent", groups=c("application"))
app_fields
#> [1] "application.application_id"   "application.application_type"
#> [3] "application.filing_date"      "application.filing_type"     
#> [5] "application.rule_47_flag"     "application.series_code"

pat_res <- search_pv(qry_funs$eq(patent_id = "10568228"), fields=app_fields, method="POST")
pat_res$data$patent$application
#> [[1]]
#>   application_id application_type filing_date series_code rule_47_flag
#> 1      15/995745               15  2018-06-01          15        FALSE
#>   filing_type
#> 1          15

# the request here and the one above differ, but the results were the same!
pat_res$request
#> #### An HTTP request where:
#> 
#> Method: POST
#> URL: https://search.patentsview.org/api/v1/patent/
#> Body: {"q":{"_eq":{"patent_id":"10568228"}},"f":["application.application_id","application.application_type","application.filing_date","application.filing_type","application.rule_47_flag","application.series_code"],"o":{"size":1000}}
```
## Unexpected Results

Then, as if that wasn't enough, some non-obvious behavior appears under the second bullet point
under the "Queries using related entity fields" header:

> When applying multiple conditions to related-entity fields, a central entity record will be 
> returned if any combination of its related entities satisfy those conditions.

In their example, they use George Washington as an inventor.  Humorously, there are modern
inventors with that name!  Abraham Lincoln is also used as an inventor.  Good ol' Abe is the only
US president to receive a [patent](https://ppubs.uspto.gov/pubwebapp/external.html?db=USPAT&type=ids&q=(0006469).pn.) but
it's too early to be in the patentsview database and there are no modern Abraham Lincolns to be found
as inventors.

To demonstrate the API's not-exactly-intuitive behavior, we'll keep George as an inventor but substitute 
Thomas Jefferson for Abe, as there are inventors going by that famous name, though they aren't on nickels or
two dollar bills in the US.


``` r
library(dplyr)

patents_query <- 
  with_qfuns(
    or(
      and(
        text_phrase(inventors.inventor_name_first = "George"),
        text_phrase(inventors.inventor_name_last = "Washington")
      ),
      and(
        text_phrase(inventors.inventor_name_first = "Thomas"),
        text_phrase(inventors.inventor_name_last = "Jefferson")
      )
    )
  )

patent_fields <-c("patent_id", "inventors.inventor_name_first", "inventors.inventor_name_last")
pat_res <- search_pv(patents_query, fields=patent_fields, endpoint="patent")
dl <- unnest_pv_data(pat_res$data)

# We got back all the inventors on the patents that met our search criteria.  We'll filter out
# the inventors that didn't strickly meet our criteria (they came along for the ride with
the ones that met our criteria), we want the noted behavior to be clear.

display_inventors <- 
   dl$inventors %>%
   filter(grepl("^(George|Thomas)", inventor_name_first ) | grepl("^(Washington|Jefferson)", inventor_name_last))  %>%
   arrange(nchar(patent_id), patent_id)  # string sort

display_inventors
#> Error: <text>:23:5: unexpected symbol
#> 22: # the inventors that didn't strickly meet our criteria (they came along for the ride with
#> 23: the ones
#>         ^
```

Now we'll hit the inventor endpoint with a similar query, as the Jupyter notebook suggests.


``` r

inventors_query <- 
  with_qfuns(
    or(
      and(
        text_phrase(inventor_name_first = "George"),
        text_phrase(inventor_name_last = "Washington")
      ),
      and(
        text_phrase(inventor_name_first = "Thomas"),
        text_phrase(inventor_name_last = "Jefferson")
      )
    )
  )

inventor_fields <- c("inventor_id","inventor_name_first","inventor_name_last")
inventor_res <- search_pv(inventors_query, fields=inventor_fields, endpoint="inventor")
dl2 <- unnest_pv_data(inventor_res$data)

actual_inventors <-
   dl2$inventors %>%
   arrange(inventor_name_last, inventor_name_first)
#> Error in dl2$inventors %>% arrange(inventor_name_last, inventor_name_first): could not find function "%>%"

actual_inventors
#> Error in eval(expr, envir, enclos): object 'actual_inventors' not found
```

Now, with actual_inventors' inventor_ids in hand, we'll ask the patent endpoint for their patents.
The results are quite different than what the first query returned. (These patents would 
have names matching at least one of our two famous forefathers.  The first query non-intuitively
matched names where the first and last name matches did not necessarily both occur on the same inventor.)


``` r
id_query <- qry_funs$eq(inventors.inventor_id=actual_inventors$inventor_id)
#> Error in qry_funs$eq(inventors.inventor_id = actual_inventors$inventor_id): object 'actual_inventors' not found

# We need to pass fields since we're sorting (sort field has to be passed as a field)
# Without a sort we could rely on the default fields being returned if we liked

patent_fields <-c("patent_id", "inventors.inventor_name_first", "inventors.inventor_name_last")
pat_res <- search_pv(id_query, fields=patent_fields, sort=c("patent_id" = "asc"))
#> Error in search_pv(id_query, fields = patent_fields, sort = c(patent_id = "asc")): object 'id_query' not found

dl <- unnest_pv_data(pat_res$data)
#> Error: patent_id not in primary entity data frame...Did you include it in your fields list?

# Also, the API's sort on patent_id, a string field, puts 10568228 first at the time of 
# this writing.  Would that be a bug or feature?  Below we'll apply our own sort
dl$patents[[1]][[1]]
#> Error in eval(expr, envir, enclos): object 'dl' not found

# we'll repeat the same filter we used on the first query's results
display_inventors <- 
   dl$inventors %>%
   filter(grepl("^(George|Thomas)", inventor_name_first ) | grepl("^(Washington|Jefferson)", inventor_name_last))  %>%
   arrange(nchar(patent_id), patent_id)  # string sort
#> Error in dl$inventors %>% filter(grepl("^(George|Thomas)", inventor_name_first) | : could not find function "%>%"


display_inventors
#> Error in eval(expr, envir, enclos): object 'display_inventors' not found
```
## Worth Noting

It's not directly mentioned, but toward the top of the notebook, the publication/rel_app_text endpoint appears in the
special_keys hash. Its entity is a rel_app_text_publications.  There's a similar patent/rel_app_text
endpoint whose entity is rel_app_texts.  Generally, the entity is the plural form of the
singular endpoint, special_keys lists the exceptions to that rule, as the code shows.  The otherreference endpoint is
not currently working, its entity is other_references and should have an entry in special_keys[^1].

## Acknowledgment

Again, credit goes to the Patentsview API team for creating the cited Jupyter notebook.  This is just portions of it
in R package form.  The repo didn't have a stated license but https://patentsview.org/contact says

> Users are free to use, share, or adapt the material for any purpose, subject to the standards of the 
> [Creative Commons Attribution 4.0 International License](https://creativecommons.org/licenses/by/4.0/).  

[^1]: Observation sent to the API team.

