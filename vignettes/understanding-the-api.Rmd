---
title: "Understanding the API"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Understanding the API}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



Oh, the interesting things you'll learn when you take the time to read the API's documentation!
Here are two gems gleaned from a [jupyter notebook](https://github.com/PatentsView/PatentsView-Code-Examples/blob/main/PatentSearch/0-patentsearch-api-demo.ipynb) in PatentsView's PatentsView-Code-Snippets
repo.

## Fields Shorthand
The notebook starts out fairly fluffy but things really get interesting really quickly.
See this under "constructing your query",  I don't remember seeing this anywhere else:

> Some endpoints contain groups of fields representing related entities connected to one of that
> endpoint's primary entity type; for example, the patent endpoint contains a field "inventors",
> which contains information on all inventors associated with any given patent. *The fields for
> related entities can be requested in the API request's fields parameter as a group by using the
> group name in the fields parameter*, or individually by specifying the required field as "{entity_type}.{subfield}".

Mind blown, so we can, for example, request all the nested application fields from the patent endpoint
by simply requesting "application" in the fields list.  

<a name="all-fields">
The new version of the R package will let its users leverage this same feature, allowing
group names to be specified in the fields parameter.  


``` r
library(patentsview)

query <- qry_funs$eq(patent_id = "10568228")

# get_fields() now uses the new API shorthand rather than returning all of the 
# group's nested field names
shorthand <- get_fields("patent", groups=c("application"))
shorthand
#> [1] "application"

shorthand_results <- search_pv(query, fields=shorthand, method="POST")

# Now that the R package uses httr2, we can use its last_request()
# to see what was POSTed to the API
cat(httr2::last_request()$body$data)
#> {"q":{"_eq":{"patent_id":"10568228"}},"f":["application"],"o":{"size":1000}}

# Here we view the results
shorthand_results$data$patent$application
#> [[1]]
#>   application_id application_type filing_date series_code rule_47_flag
#> 1      15/995745               15  2018-06-01          15        FALSE
#>   filing_type
#> 1          15

# Now we'll explicitly request all the application fields and make a POST to the API
explicit_fields <- fieldsdf[fieldsdf$endpoint == "patent" & fieldsdf$group == "application", "field"]
explicit_results <- search_pv(query, fields=explicit_fields, method="POST")

# what was POSTed is different
cat(httr2::last_request()$body$data)
#> {"q":{"_eq":{"patent_id":"10568228"}},"f":["application.application_id","application.application_type","application.filing_date","application.filing_type","application.rule_47_flag","application.series_code"],"o":{"size":1000}}

# but the results from the API are the same
explicit_results$data$patent$application
#> [[1]]
#>   application_id application_type filing_date series_code rule_47_flag
#> 1      15/995745               15  2018-06-01          15        FALSE
#>   filing_type
#> 1          15

# (Observation reported to the API team: application_type, series_code and filing_type
# all seem to have the same values and not just in this one example.)

```

The difference in the requests is that in the former case, it's the API deciding what fields to return
while in the latter case, we used fieldsdf.
fieldsdf is created from the [API's OpenAPI object](https://search.patentsview.org/static/openapi.json)
when building the R package and specifies what fields can be requested from each endpoint.  The results 
could be different if the API's actual return is not in sync with the API's OpenAPI object.  Here we see 
that the requests are different but the results are the same (we used POSTs so the requests are easier 
to read since they don't need to be urlencoded).

The motivation to adopt the API's shorthand is that, with a modest query, explicitly requesting all of the
patent endpoint's fields can be too much to send via a GET request (the resulting URL can exceed 4K). 

## Unexpected Results

Then, as if that wasn't enough, some non-obvious behavior appears under the second bullet point
under the "Queries using related entity fields" header:

> When applying multiple conditions to related-entity fields, a central entity record will be 
> returned if any combination of its related entities satisfy those conditions.

In their example, they use George Washington as an inventor.  Humorously, there are modern
inventors with that name!  Abraham Lincoln is also used as an inventor.  Good ol' Abe is the only
US president to receive a [patent](https://ppubs.uspto.gov/pubwebapp/external.html?db=USPAT&type=ids&q=(0006469).pn.) but
it's too early to be in the patentsview database and there are no modern Abraham Lincolns to be found
as inventors.

To demonstrate the API's not-exactly-intuitive behavior, we'll keep George as an inventor but substitute 
Thomas Jefferson for Abe, as there are inventors going by that famous name, though they aren't on nickels or
two dollar bills in the US.


``` r
library(dplyr)

patents_query <- 
  with_qfuns(
    or(
      and(
        text_phrase(inventors.inventor_name_first = "George"),
        text_phrase(inventors.inventor_name_last = "Washington")
      ),
      and(
        text_phrase(inventors.inventor_name_first = "Thomas"),
        text_phrase(inventors.inventor_name_last = "Jefferson")
      )
    )
  )

patent_fields <-c("patent_id", "inventors.inventor_name_first", "inventors.inventor_name_last")
pat_res <- search_pv(patents_query, fields=patent_fields, endpoint="patent")
dl <- unnest_pv_data(pat_res$data)

# We got back all the inventors on the patents that met our search criteria.  We'll filter out
# the inventors that didn't strictly meet our criteria (they're coinventors that came along for 
# the ride with the ones that met our criteria), we want the noted behavior to be clear.

display_inventors <- 
   dl$inventors %>%
   filter(grepl("^(George|Thomas)", inventor_name_first ) | grepl("^(Washington|Jefferson)", inventor_name_last))

display_inventors
#>    patent_id inventor_name_first inventor_name_last
#> 1    4078607              Thomas          Jefferson
#> 2    4104193              Thomas          Jefferson
#> 3    5643452              George         Washington
#> 4    5645778              George         Washington
#> 5    5736046              George         Washington
#> 6    5897817              George         Washington
#> 7    5914971           George E.         Burke, Jr.
#> 8    5914971           Rodney B.         Washington
#> 9    6218441              George         Washington
#> 10   6881337              George         Washington
#> 11   6905071              Thomas           Amundsen
#> 12   6905071              George              Kolis
#> 13   6905071             Matthew          Jefferson
#> 14   7144505              George         Washington
#> 15   7598629           George E.         Burke, Jr.
#> 16   7598629           Rodney B.         Washington
#> 17   7971908              Thomas              Tilly
#> 18   7971908           Thomas M.           DiMambro
#> 19   7971908           Alfred A.          Jefferson
#> 20   8347213           Thomas M.            Clifton
#> 21   8347213          Bradley C.          Jefferson
#> 22   8717367           Thomas M.            Clifton
#> 23   8717367          Bradley C.          Jefferson
#> 24  10180440          Stanley T.          Jefferson
#> 25  10180440              Thomas                FAY
#> 26  10374815           Thomas J.             Bonola
#> 27  10374815             Lorri L          Jefferson
#> 28  10568228      George Elliott         Washington
#> 29  10664808                Joel         Washington
#> 30  11032709           Thomas J.             Bonola
#> 31  11032709             Lorri L          Jefferson
```
Some rows act as you'd expect, like patent 4078607's Thomas Jefferson.  In others, two inventors
combine to meet the search cititeria, like 6905071's
 **Thomas** Amundsen and Matthew **Jefferson**.  This might be a match we didn't intend.

Now we'll hit the inventor endpoint with a similar query, as the jupyter notebook suggests.


``` r

inventors_query <- 
  with_qfuns(
    or(
      and(
        text_phrase(inventor_name_first = "George"),
        text_phrase(inventor_name_last = "Washington")
      ),
      and(
        text_phrase(inventor_name_first = "Thomas"),
        text_phrase(inventor_name_last = "Jefferson")
      )
    )
  )

inventor_fields <- c("inventor_id","inventor_name_first","inventor_name_last")
inventor_res <- search_pv(inventors_query, fields=inventor_fields, endpoint="inventor")
actual_inventors <- unnest_pv_data(inventor_res$data)

actual_inventors[[1]]
#>             inventor_id inventor_name_first inventor_name_last
#> 1 fl:ge_ln:washington-4              George         Washington
#> 2 fl:ge_ln:washington-5      George Elliott         Washington
#> 3  fl:th_ln:jefferson-1              Thomas          Jefferson
```

Now, with actual_inventors' inventor_ids in hand, we'll ask the patent endpoint for their patents.
The results are quite different than what the first query returned. (These patents would 
have names matching at least one of our two famous forefather's names.  The first query non-intuitively
matched names where the first and last name matches did not necessarily both occur on the same inventor.)


``` r
id_query <- qry_funs$eq(inventors.inventor_id=actual_inventors$inventors$inventor_id)

patent_fields <-c("patent_id", "inventors.inventor_name_first", "inventors.inventor_name_last",
  "inventors.inventor_id")
pat_res <- search_pv(id_query, fields=patent_fields, sort=c(patent_id = "asc"))

dl <- unnest_pv_data(pat_res$data)

# we'll repeat the same name filter we used on the first query's results
display_inventors <- 
   dl$inventors %>%
   filter(grepl("^(George|Thomas)", inventor_name_first ) | grepl("^(Washington|Jefferson)", inventor_name_last)) %>%
   mutate(inventor = sub(".*/([^/]+)/$", "\\1", inventor)) # extract id from HATEOAS link

# sample pre-mutate value, note that we requested inventor_id but the API sent back `inventor`
dl$inventors$inventor[[1]]
#> [1] "https://search.patentsview.org/api/v1/inventor/fl:wa_ln:carter-1/"

display_inventors
#>    patent_id              inventor inventor_name_first inventor_name_last
#> 1    4078607  fl:th_ln:jefferson-1              Thomas          Jefferson
#> 2    4104193  fl:th_ln:jefferson-1              Thomas          Jefferson
#> 3    5643452 fl:ge_ln:washington-4              George         Washington
#> 4    5645778 fl:ge_ln:washington-4              George         Washington
#> 5    5736046 fl:ge_ln:washington-4              George         Washington
#> 6    5897817 fl:ge_ln:washington-4              George         Washington
#> 7    6218441 fl:ge_ln:washington-4              George         Washington
#> 8    6881337 fl:ge_ln:washington-4              George         Washington
#> 9    7144505 fl:ge_ln:washington-4              George         Washington
#> 10  10568228 fl:ge_ln:washington-5      George Elliott         Washington
```

## Acknowledgment

Again, credit goes to the Patentsview API team for creating the cited jupyter notebook.  This is just portions of it
in R package form.  The repo doesn't have a stated license but when I checked, I was told:

> For the repo license we are looking at the [GNU General Public License v3](https://www.gnu.org/licenses/quick-guide-gplv3.html) (GPL3).

That is the same license as R itself so I don't think we've violated anything.  For extra fun check
out [Russ' fork](https://github.com/mustberuss/PatentsView-Code-Snippets/blob/master/07_PatentSearch_API_demo/PV%20PatentSearch%20API%20tutorial.ipynb)
where there's python code for retrieving Mr. Jefferson's patents etc.  There was no reply when we asked if 
they'd be receptive to a PR.
